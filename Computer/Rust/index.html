<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="ccsss" name="author"/>
<link href="https://ccss17.github.io/Computer/Rust/" rel="canonical"/>
<link href="../../assets/images/bolt-solid.svg" rel="icon"/>
<meta content="mkdocs-1.2.2, mkdocs-material-7.2.6" name="generator"/>
<title>Rust Memo - ccss17</title>
<link href="../../assets/stylesheets/main.802231af.min.css" rel="stylesheet"/>
<link href="../../assets/stylesheets/palette.3f5d1f46.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Nanum+Gothic:300,400,400i,700%7C&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font-family:"Nanum Gothic";--md-code-font-family:""}</style>
<link href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" rel="stylesheet"/>
<link href="../../stylesheets/config.css" rel="stylesheet"/>
</head>
<body data-md-color-accent="" data-md-color-primary="white" data-md-color-scheme="default" dir="ltr">
<script>function __prefix(e){return new URL("../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
<script>var palette=__get("__palette");if(null!==palette&&"object"==typeof palette.color)for(var key in palette.color)document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#ownership-rules">
          Skip to content
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="Header" class="md-header__inner md-grid">
<a aria-label="ccss17" class="md-header__button md-logo" data-md-component="logo" href="../.." title="ccss17">
<img alt="logo" src="../../assets/images/bolt-solid.svg"/>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            ccss17
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Rust Memo
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Switch to dark mode" class="md-option" data-md-color-accent="" data-md-color-media="" data-md-color-primary="white" data-md-color-scheme="default" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_2" hidden="" title="Switch to dark mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5z"></path></svg>
</label>
<input aria-label="Switch to light mode" class="md-option" data-md-color-accent="" data-md-color-media="" data-md-color-primary="deep-purple" data-md-color-scheme="slate" id="__palette_2" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Switch to light mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1z"></path></svg>
</label>
</form>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="Tabs" class="md-tabs" data-md-component="tabs">
<div class="md-tabs__inner md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../..">
      ccss17
    </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../Math/MathHistory/">
        Math
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../paper/1404.6388/">
        Paper
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link md-tabs__link--active" href="../nand2tetris/">
        Computer
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../ProgrammerBase/">
        ProgrammerBase
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../security-tutorial/">
        security tutorial
      </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navigation" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="ccss17" class="md-nav__button md-logo" data-md-component="logo" href="../.." title="ccss17">
<img alt="logo" src="../../assets/images/bolt-solid.svg"/>
</a>
    ccss17
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../..">
        ccss17
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" id="__nav_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2">
        Math
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Math" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
          Math
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_1" id="__nav_2_1" type="checkbox"/>
<label class="md-nav__link" for="__nav_2_1">
        Foundation of Math
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Foundation of Math" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_1">
<span class="md-nav__icon md-icon"></span>
          Foundation of Math
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/MathHistory/">
        History of Math
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/Logic/FormalSystem/">
        Formal System
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/incompleteness/">
        Incompleteness theorem
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/turing/">
        Turing's proof
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/gentzen/">
        Consistency proof of Peano arithmetic
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_2" id="__nav_2_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2_2">
        Set Theory
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Set Theory" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_2">
<span class="md-nav__icon md-icon"></span>
          Set Theory
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/Set/Set/">
        Set
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/Set/numbers/">
        Number Theory
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/Set/InfiniteSet/">
        Infinite Set
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/Set/ZFC/">
        ZFC axiom system
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/ArithmeticOperations/">
        Arithmetic Operations
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/Polynomials/">
        Polynomials
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/HyperrealNumbers/">
        Hyperreal Numbers
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/SurrealNumbers/">
        Surreal Numbers
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_7" id="__nav_2_7" type="checkbox"/>
<label class="md-nav__link" for="__nav_2_7">
        Linear Algebra
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Linear Algebra" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_7">
<span class="md-nav__icon md-icon"></span>
          Linear Algebra
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/LinearAlgebra/VectorSpace/">
        Vector Space
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/LinearAlgebra/LinearTransformation/">
        Linear Transformation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/LinearAlgebra/MatrixOperation/">
        Matrix Operation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/LinearAlgebra/Determinants/">
        Determinants
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/LinearAlgebra/Diagonalization/">
        Diagonalization
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/LinearAlgebra/InnerProductSpaces/">
        Inner Product Spaces
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Math/LinearAlgebra/CanonicalForms/">
        Canonical Forms
      </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" id="__nav_3" type="checkbox"/>
<label class="md-nav__link" for="__nav_3">
        Paper
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Paper" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
          Paper
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../paper/1404.6388/">
        Performance of Python runtimes on a non-numeric scientific code
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../paper/1102.1523/">
        The NumPy array: a structure for efficient numerical computation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../paper/facenet/">
        Facenet (2015)
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../paper/quadruplet/">
        Quadruplet (2017)
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../paper/blueborne/">
        BlueBorne
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" id="__nav_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_4">
        Computer
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Computer" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
          Computer
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../nand2tetris/">
        Nand to Tetris
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../future/">
        Why the future doesn't need us
      </a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" data-md-toggle="toc" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
          Rust Memo
          <span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
        Rust Memo
      </a>
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<!-- <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label> -->
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#ownership-rules">
    Ownership Rules
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#move">
    Move
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#copy">
    Copy
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_1">
    함수 인자 전달
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
    함수 반환값 전달
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#reference">
    Reference
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mutable-reference">
    Mutable Reference
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#slice">
    Slice
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#struct">
    Struct
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#method">
    Method
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#automatic-referencing-and-dereferencing">
    Automatic referencing and dereferencing
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#associated-functions">
    Associated Functions
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#enum">
    Enum
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#enum-method">
    Enum Method
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#important-enum-option">
    Important Enum: Option
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#match">
    Match
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#if-let">
    if let
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#package-crate">
    Package 와 Crate
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#module">
    Module
  </a>
<nav aria-label="Module" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#module_1">
    Module 위계
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#use">
    use
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#separating-modules-into-different-files">
    Separating Modules into Different Files
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#collections">
    Collections
  </a>
<nav aria-label="Collections" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#vector">
    Vector
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#string">
    String
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#hashmap">
    HashMap
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#error">
    Error
  </a>
<nav aria-label="Error" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#unrecoverable-error">
    unrecoverable error
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#recoverable-error">
    recoverable error
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#choice-to-recoverable-or-unrecoverable">
    Choice to recoverable or unrecoverable
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#advice-to-error-handling">
    Advice to error handling
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#dereferencing-coercion">
    dereferencing coercion
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#main-function-return-type">
    main function return type
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#for">
    for
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#generic">
    Generic
  </a>
<nav aria-label="Generic" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#monomorphization">
    Monomorphization
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trait">
    Trait
  </a>
<nav aria-label="Trait" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#orphan-rule-coherence">
    orphan rule (coherence)
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#default-implementation">
    Default Implementation
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trait-as-parameter">
    Trait as Parameter
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trait-bound">
    Trait Bound
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-trait-bound">
    Multiple Trait Bound
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#where">
    where
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#return-trait">
    return Trait
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#conditionally-implement-method">
    conditionally implement method
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime">
    Lifetime
  </a>
<nav aria-label="Lifetime" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#borrow-checker">
    borrow checker
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#generic-lifetime">
    Generic Lifetime
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-annotation-in-function">
    Lifetime Annotation in Function
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-annotation-in-struct">
    Lifetime Annotation in Struct
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-elision">
    Lifetime Elision
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-elision-example-1">
    Lifetime Elision Example 1
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-elision-example-2">
    Lifetime Elision Example 2
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-annotation-in-method">
    Lifetime Annotation in Method
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#static-lifetime">
    Static Lifetime
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#example-generictraitlifetime">
    Example (Generic+Trait+Lifetime)
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#automated-tests">
    Automated Tests
  </a>
<nav aria-label="Automated Tests" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#test">
    Test 코드 작성
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#test-function">
    Test Function
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#testing">
    Testing 방법
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#custom-failure-message">
    Custom Failure Message
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#panic-test">
    panic test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#result-test">
    Result Test
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#controlling-test">
    Controlling Test
  </a>
<nav aria-label="Controlling Test" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#thread-safe-test">
    thread-safe test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#show-output-of-test">
    show output of test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#running-subset-of-test">
    Running subset of Test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ignore-some-tests">
    Ignore some Tests
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#test-organization">
    Test Organization
  </a>
<nav aria-label="Test Organization" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#unit-test">
    Unit test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#test-module-and-cfgtest">
    Test Module and #[cfg(test)]
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#integration-test">
    Integration test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#tests-directory">
    tests Directory
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#submodules-in-integration-test">
    Submodules in Integration test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#integration-test-for-binary-crate">
    Integration test for Binary Crate
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#derive-attribute">
    derive attribute
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#io-project">
    I/O Project
  </a>
<nav aria-label="I/O Project" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#first-try">
    First Try
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#separation-of-concerns">
    Separation of Concerns
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#extracting-the-argument-parser">
    Extracting the Argument Parser
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#grouping-values">
    Grouping Values
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#creating-constructor-for-config">
    Creating constructor for Config
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#improving-error-handling">
    Improving Error Handling
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#returning-a-result-from-new-instead-of-calling-panic">
    Returning a Result from new Instead of Calling panic!
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#calling-confignew-and-handling-errors">
    Calling Config::new and Handling Errors
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#extracting-logic-from-main">
    Extracting Logic from main
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#returning-errors-from-the-run-function">
    Returning Errors from the run Function
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#handling-errors-returned-from-run-in-main">
    Handling Errors Returned from run in main
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#splitting-code-into-a-library-crate">
    Splitting Code into a Library Crate
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#developing-the-librarys-functionality-with-test-driven-development">
    Developing the Library’s Functionality with Test-Driven Development
  </a>
<nav aria-label="Developing the Library’s Functionality with Test-Driven Development" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-failing-test">
    1) Failing Test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-writing-code-to-pass-the-test">
    2) Writing Code to Pass the Test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-the-search-function-in-the-run-function">
    Using the search Function in the run Function
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#working-with-environment-variables">
    Working with Environment Variables
  </a>
<nav aria-label="Working with Environment Variables" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1">
    1) 테스트 함수 작성
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2">
    2) 테스트에 통과하도록 코드 구현
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-run">
    3) 구현 코드를 run 에 추가
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_3">
    환경변수
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
    표준 에러 스트림
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#functional-language-features-iterators-and-closures">
    Functional Language Features: Iterators and Closures
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#closures">
    Closures
  </a>
<nav aria-label="Closures" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#closure-type-inference-and-annotation">
    Closure Type Inference and Annotation
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#storing-closures-using-generic-parameters-and-the-fn-traits">
    Storing Closures Using Generic Parameters and the Fn Traits
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#limitations-of-the-cacher-implementation">
    Limitations of the Cacher Implementation
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#capturing-the-environment-with-closures">
    Capturing the Environment with Closures
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#iterator">
    Iterator
  </a>
<nav aria-label="Iterator" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#iterator-trait">
    Iterator Trait
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#methods-that-consume-the-iterator">
    Methods that Consume the Iterator
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#methods-that-produce-other-iterators">
    Methods that Produce Other Iterators
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#creating-our-own-iterators-with-the-iterator-trait">
    Creating Our Own Iterators with the Iterator Trait
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#improving-our-io-project">
    Improving Our I/O Project
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#more-about-cargo-and-cratesio">
    More About Cargo and Crates.io
  </a>
<nav aria-label="More About Cargo and Crates.io" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#customizing-builds-with-release-profiles">
    Customizing Builds with Release Profiles
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#making-useful-documentation-comments">
    Making Useful Documentation Comments
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cargo-workspaces">
    Cargo Workspaces
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#smart-pointers">
    Smart Pointers
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#box">
    Box
  </a>
<nav aria-label="Box" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#enabling-recursive-types-with-boxes">
    Enabling Recursive Types with Boxes
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#treating-smart-pointers-like-regular-references-with-the-deref-trait">
    Treating Smart Pointers Like Regular References with the Deref Trait
  </a>
<nav aria-label="Treating Smart Pointers Like Regular References with the Deref Trait" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#following-the-pointer-to-the-value-with-the-dereference-operator">
    Following the Pointer to the Value with the Dereference Operator
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#defining-our-own-smart-pointer">
    Defining Our Own Smart Pointer
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#implicit-deref-coercions-with-functions-and-methods">
    Implicit Deref Coercions with Functions and Methods
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#how-deref-coercion-interacts-with-mutability">
    How Deref Coercion Interacts with Mutability
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#running-code-on-cleanup-with-the-drop-trait">
    Running Code on Cleanup with the Drop Trait
  </a>
<nav aria-label="Running Code on Cleanup with the Drop Trait" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#dropping-a-value-early-with-stdmemdrop">
    Dropping a Value Early with std::mem::drop
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#rc-the-reference-counted-smart-pointer">
    Rc, the Reference Counted Smart Pointer
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#refcell-and-the-interior-mutability-pattern">
    RefCell and the Interior Mutability Pattern
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#interior-mutability-a-mutable-borrow-to-an-immutable-value">
    Interior Mutability: A Mutable Borrow to an Immutable Value
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#a-use-case-for-interior-mutability-mock-objects">
    A Use Case for Interior Mutability: Mock Objects
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#having-multiple-owners-of-mutable-data-by-combining-rc-and-refcell">
    Having Multiple Owners of Mutable Data by Combining Rc and RefCell
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#reference-cycles-can-leak-memory">
    Reference Cycles Can Leak Memory
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#concurrency">
    Concurrency
  </a>
<nav aria-label="Concurrency" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#using-message-passing-to-transfer-data-between-threads">
    Using Message Passing to Transfer Data Between Threads
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#shared-state-concurrency">
    Shared-State Concurrency
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#extensible-concurrenty-sync-and-send-trait">
    Extensible Concurrenty (Sync and Send Trait)
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#oop">
    OOP
  </a>
<nav aria-label="OOP" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#objects-contain-data-and-behavior">
    Objects Contain Data and Behavior
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#encapsulation-that-hides-implementation-details">
    Encapsulation that Hides Implementation Details
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#inheritance-as-a-type-system-and-as-code-sharing">
    Inheritance as a Type System and as Code Sharing
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-trait-objects-that-allow-for-values-of-different-typespolymorphism">
    Using Trait Objects That Allow for Values of Different Types(Polymorphism)
  </a>
<nav aria-label="Using Trait Objects That Allow for Values of Different Types(Polymorphism)" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trait-objects-perform-dynamic-dispatch">
    Trait Objects Perform Dynamic Dispatch
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#object-safety-is-required-for-trait-objects">
    Object Safety Is Required for Trait Objects
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#implementing-an-object-oriented-design-pattern">
    Implementing an Object-Oriented Design Pattern
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#patterns-and-matching">
    Patterns and Matching
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#all-the-places-patterns-can-be-used">
    All the Places Patterns Can Be Used
  </a>
<nav aria-label="All the Places Patterns Can Be Used" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#match-arms">
    match Arms
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#conditional-if-let-expressions">
    Conditional if let Expressions
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#while-let-conditional-loops">
    while let Conditional Loops
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#for-loops">
    for Loops
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#let-statements">
    let Statements
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#function-parameters">
    Function Parameters
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#refutability-whether-a-pattern-might-fail-to-match">
    Refutability: Whether a Pattern Might Fail to Match
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#pattern-syntax">
    Pattern Syntax
  </a>
<nav aria-label="Pattern Syntax" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#matching-literals">
    Matching Literals
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#matching-named-variables">
    Matching Named Variables
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-patterns">
    Multiple Patterns
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#matching-ranges-of-values-with">
    Matching Ranges of Values with ..=
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#destructuring-to-break-apart-values">
    Destructuring to Break Apart Values
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#destructuring-enums">
    Destructuring Enums
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#destructuring-structs-and-tuples">
    Destructuring Structs and Tuples
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_">
    _ 패턴
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ignoring-an-unused-variable-by-starting-its-name-with-_">
    Ignoring an Unused Variable by Starting Its Name with _
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ignoring-remaining-parts-of-a-value-with">
    Ignoring Remaining Parts of a Value with ..
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#extra-conditionals-with-match-guards">
    Extra Conditionals with Match Guards
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#bindings">
    @ Bindings
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#advanced-features">
    Advanced Features
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#unsafe-rust">
    Unsafe Rust
  </a>
<nav aria-label="Unsafe Rust" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#unsafe-superpowers">
    Unsafe Superpowers
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#1-dereferencing-a-raw-pointer">
    1. Dereferencing a Raw Pointer
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-calling-an-unsafe-function-or-method">
    2. Calling an Unsafe Function or Method
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-access-or-modify-a-mutable-static-variable">
    3. Access or modify a mutable static variable
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-implement-an-unsafe-trait">
    4. Implement an unsafe trait
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#5-access-files-of-unions">
    5. Access files of unions
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#advanced-traits">
    Advanced Traits
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types">
    Specifying Placeholder Types in Trait Definitions with Associated Types
  </a>
<nav aria-label="Specifying Placeholder Types in Trait Definitions with Associated Types" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#default-generic-type-parameters-and-operator-overloading">
    Default Generic Type Parameters and Operator Overloading
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">
    Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-supertraits-to-require-one-traits-functionality-within-another-trait">
    Using Supertraits to Require One Trait’s Functionality Within Another Trait
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types">
    Using the Newtype Pattern to Implement External Traits on External Types
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-the-newtype-pattern-for-type-safety-and-abstraction">
    Using the Newtype Pattern for Type Safety and Abstraction
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#creating-type-synonyms-with-type-aliases">
    Creating Type Synonyms with Type Aliases
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#the-never-type-that-never-returns">
    The Never Type that Never Returns
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#dynamically-sized-types-and-the-sized-trait">
    Dynamically Sized Types and the Sized Trait
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#advanced-functions-and-closures">
    Advanced Functions and Closures
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#function-pointers">
    Function Pointers
  </a>
<nav aria-label="Function Pointers" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#returning-closures">
    Returning Closures
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#macros">
    Macros
  </a>
<nav aria-label="Macros" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#the-difference-between-macros-and-functions">
    The Difference Between Macros and Functions
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">
    Declarative Macros with macro_rules! for General Metaprogramming
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#procedural-macros-for-generating-code-from-attributes">
    Procedural Macros for Generating Code from Attributes
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#how-to-write-a-custom-derive-macro">
    How to Write a Custom derive Macro
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#attribute-like-macros">
    Attribute-like macros
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#function-like-macros">
    Function-like macros
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" id="__nav_5" type="checkbox"/>
<label class="md-nav__link" for="__nav_5">
        ProgrammerBase
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="ProgrammerBase" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
          ProgrammerBase
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/">
        README
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_2" id="__nav_5_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_5_2">
        Contents
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Contents" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_5_2">
<span class="md-nav__icon md-icon"></span>
          Contents
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/01-Day1/readme/">
        Day 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/02-Day2/readme/">
        Day 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/03-Day3/readme/">
        Day 3
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/04-Day4/readme/">
        Day 4
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/05-Day5/readme/">
        Day 5
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/docker/">
        Docker
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/codingconvention/">
        Coding Convention
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/build/">
        Build System
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/information/">
        Information
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/git/">
        Git
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/vscode/">
        VSCode
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/markdown/">
        Markdown
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/tmux/">
        Tmux
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/vim/">
        Vim
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ProgrammerBase/cli/">
        CLI
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" id="__nav_6" type="checkbox"/>
<label class="md-nav__link" for="__nav_6">
        security tutorial
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="security tutorial" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
          security tutorial
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/">
        README
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/01-Base/">
        Day1 Base
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/02-Computer1/">
        Day2 Computer Principle 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/03-Computer2/">
        Day3 Computer Principle 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/04-Reversing1/">
        Day4 Reversing 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/05-Reversing2/">
        Day5 Reversing 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/06-Exploit1/">
        Day6 Exploit 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/07-Exploit2/">
        Day7 Exploit 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/08-Exploit3/">
        Day8 Exploit 3
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/09-Exploit4/">
        Day9 Exploit 4
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../security-tutorial/10-Pentesting/">
        Day10 Pentesting
      </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<!-- <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label> -->
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#ownership-rules">
    Ownership Rules
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#move">
    Move
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#copy">
    Copy
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_1">
    함수 인자 전달
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
    함수 반환값 전달
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#reference">
    Reference
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mutable-reference">
    Mutable Reference
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#slice">
    Slice
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#struct">
    Struct
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#method">
    Method
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#automatic-referencing-and-dereferencing">
    Automatic referencing and dereferencing
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#associated-functions">
    Associated Functions
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#enum">
    Enum
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#enum-method">
    Enum Method
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#important-enum-option">
    Important Enum: Option
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#match">
    Match
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#if-let">
    if let
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#package-crate">
    Package 와 Crate
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#module">
    Module
  </a>
<nav aria-label="Module" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#module_1">
    Module 위계
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#use">
    use
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#separating-modules-into-different-files">
    Separating Modules into Different Files
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#collections">
    Collections
  </a>
<nav aria-label="Collections" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#vector">
    Vector
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#string">
    String
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#hashmap">
    HashMap
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#error">
    Error
  </a>
<nav aria-label="Error" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#unrecoverable-error">
    unrecoverable error
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#recoverable-error">
    recoverable error
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#choice-to-recoverable-or-unrecoverable">
    Choice to recoverable or unrecoverable
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#advice-to-error-handling">
    Advice to error handling
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#dereferencing-coercion">
    dereferencing coercion
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#main-function-return-type">
    main function return type
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#for">
    for
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#generic">
    Generic
  </a>
<nav aria-label="Generic" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#monomorphization">
    Monomorphization
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trait">
    Trait
  </a>
<nav aria-label="Trait" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#orphan-rule-coherence">
    orphan rule (coherence)
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#default-implementation">
    Default Implementation
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trait-as-parameter">
    Trait as Parameter
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trait-bound">
    Trait Bound
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-trait-bound">
    Multiple Trait Bound
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#where">
    where
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#return-trait">
    return Trait
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#conditionally-implement-method">
    conditionally implement method
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime">
    Lifetime
  </a>
<nav aria-label="Lifetime" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#borrow-checker">
    borrow checker
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#generic-lifetime">
    Generic Lifetime
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-annotation-in-function">
    Lifetime Annotation in Function
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-annotation-in-struct">
    Lifetime Annotation in Struct
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-elision">
    Lifetime Elision
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-elision-example-1">
    Lifetime Elision Example 1
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-elision-example-2">
    Lifetime Elision Example 2
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lifetime-annotation-in-method">
    Lifetime Annotation in Method
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#static-lifetime">
    Static Lifetime
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#example-generictraitlifetime">
    Example (Generic+Trait+Lifetime)
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#automated-tests">
    Automated Tests
  </a>
<nav aria-label="Automated Tests" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#test">
    Test 코드 작성
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#test-function">
    Test Function
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#testing">
    Testing 방법
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#custom-failure-message">
    Custom Failure Message
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#panic-test">
    panic test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#result-test">
    Result Test
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#controlling-test">
    Controlling Test
  </a>
<nav aria-label="Controlling Test" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#thread-safe-test">
    thread-safe test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#show-output-of-test">
    show output of test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#running-subset-of-test">
    Running subset of Test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ignore-some-tests">
    Ignore some Tests
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#test-organization">
    Test Organization
  </a>
<nav aria-label="Test Organization" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#unit-test">
    Unit test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#test-module-and-cfgtest">
    Test Module and #[cfg(test)]
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#integration-test">
    Integration test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#tests-directory">
    tests Directory
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#submodules-in-integration-test">
    Submodules in Integration test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#integration-test-for-binary-crate">
    Integration test for Binary Crate
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#derive-attribute">
    derive attribute
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#io-project">
    I/O Project
  </a>
<nav aria-label="I/O Project" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#first-try">
    First Try
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#separation-of-concerns">
    Separation of Concerns
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#extracting-the-argument-parser">
    Extracting the Argument Parser
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#grouping-values">
    Grouping Values
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#creating-constructor-for-config">
    Creating constructor for Config
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#improving-error-handling">
    Improving Error Handling
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#returning-a-result-from-new-instead-of-calling-panic">
    Returning a Result from new Instead of Calling panic!
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#calling-confignew-and-handling-errors">
    Calling Config::new and Handling Errors
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#extracting-logic-from-main">
    Extracting Logic from main
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#returning-errors-from-the-run-function">
    Returning Errors from the run Function
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#handling-errors-returned-from-run-in-main">
    Handling Errors Returned from run in main
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#splitting-code-into-a-library-crate">
    Splitting Code into a Library Crate
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#developing-the-librarys-functionality-with-test-driven-development">
    Developing the Library’s Functionality with Test-Driven Development
  </a>
<nav aria-label="Developing the Library’s Functionality with Test-Driven Development" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-failing-test">
    1) Failing Test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-writing-code-to-pass-the-test">
    2) Writing Code to Pass the Test
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-the-search-function-in-the-run-function">
    Using the search Function in the run Function
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#working-with-environment-variables">
    Working with Environment Variables
  </a>
<nav aria-label="Working with Environment Variables" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1">
    1) 테스트 함수 작성
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2">
    2) 테스트에 통과하도록 코드 구현
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-run">
    3) 구현 코드를 run 에 추가
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_3">
    환경변수
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
    표준 에러 스트림
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#functional-language-features-iterators-and-closures">
    Functional Language Features: Iterators and Closures
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#closures">
    Closures
  </a>
<nav aria-label="Closures" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#closure-type-inference-and-annotation">
    Closure Type Inference and Annotation
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#storing-closures-using-generic-parameters-and-the-fn-traits">
    Storing Closures Using Generic Parameters and the Fn Traits
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#limitations-of-the-cacher-implementation">
    Limitations of the Cacher Implementation
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#capturing-the-environment-with-closures">
    Capturing the Environment with Closures
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#iterator">
    Iterator
  </a>
<nav aria-label="Iterator" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#iterator-trait">
    Iterator Trait
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#methods-that-consume-the-iterator">
    Methods that Consume the Iterator
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#methods-that-produce-other-iterators">
    Methods that Produce Other Iterators
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#creating-our-own-iterators-with-the-iterator-trait">
    Creating Our Own Iterators with the Iterator Trait
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#improving-our-io-project">
    Improving Our I/O Project
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#more-about-cargo-and-cratesio">
    More About Cargo and Crates.io
  </a>
<nav aria-label="More About Cargo and Crates.io" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#customizing-builds-with-release-profiles">
    Customizing Builds with Release Profiles
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#making-useful-documentation-comments">
    Making Useful Documentation Comments
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cargo-workspaces">
    Cargo Workspaces
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#smart-pointers">
    Smart Pointers
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#box">
    Box
  </a>
<nav aria-label="Box" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#enabling-recursive-types-with-boxes">
    Enabling Recursive Types with Boxes
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#treating-smart-pointers-like-regular-references-with-the-deref-trait">
    Treating Smart Pointers Like Regular References with the Deref Trait
  </a>
<nav aria-label="Treating Smart Pointers Like Regular References with the Deref Trait" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#following-the-pointer-to-the-value-with-the-dereference-operator">
    Following the Pointer to the Value with the Dereference Operator
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#defining-our-own-smart-pointer">
    Defining Our Own Smart Pointer
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#implicit-deref-coercions-with-functions-and-methods">
    Implicit Deref Coercions with Functions and Methods
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#how-deref-coercion-interacts-with-mutability">
    How Deref Coercion Interacts with Mutability
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#running-code-on-cleanup-with-the-drop-trait">
    Running Code on Cleanup with the Drop Trait
  </a>
<nav aria-label="Running Code on Cleanup with the Drop Trait" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#dropping-a-value-early-with-stdmemdrop">
    Dropping a Value Early with std::mem::drop
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#rc-the-reference-counted-smart-pointer">
    Rc, the Reference Counted Smart Pointer
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#refcell-and-the-interior-mutability-pattern">
    RefCell and the Interior Mutability Pattern
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#interior-mutability-a-mutable-borrow-to-an-immutable-value">
    Interior Mutability: A Mutable Borrow to an Immutable Value
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#a-use-case-for-interior-mutability-mock-objects">
    A Use Case for Interior Mutability: Mock Objects
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#having-multiple-owners-of-mutable-data-by-combining-rc-and-refcell">
    Having Multiple Owners of Mutable Data by Combining Rc and RefCell
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#reference-cycles-can-leak-memory">
    Reference Cycles Can Leak Memory
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#concurrency">
    Concurrency
  </a>
<nav aria-label="Concurrency" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#using-message-passing-to-transfer-data-between-threads">
    Using Message Passing to Transfer Data Between Threads
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#shared-state-concurrency">
    Shared-State Concurrency
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#extensible-concurrenty-sync-and-send-trait">
    Extensible Concurrenty (Sync and Send Trait)
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#oop">
    OOP
  </a>
<nav aria-label="OOP" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#objects-contain-data-and-behavior">
    Objects Contain Data and Behavior
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#encapsulation-that-hides-implementation-details">
    Encapsulation that Hides Implementation Details
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#inheritance-as-a-type-system-and-as-code-sharing">
    Inheritance as a Type System and as Code Sharing
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-trait-objects-that-allow-for-values-of-different-typespolymorphism">
    Using Trait Objects That Allow for Values of Different Types(Polymorphism)
  </a>
<nav aria-label="Using Trait Objects That Allow for Values of Different Types(Polymorphism)" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trait-objects-perform-dynamic-dispatch">
    Trait Objects Perform Dynamic Dispatch
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#object-safety-is-required-for-trait-objects">
    Object Safety Is Required for Trait Objects
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#implementing-an-object-oriented-design-pattern">
    Implementing an Object-Oriented Design Pattern
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#patterns-and-matching">
    Patterns and Matching
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#all-the-places-patterns-can-be-used">
    All the Places Patterns Can Be Used
  </a>
<nav aria-label="All the Places Patterns Can Be Used" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#match-arms">
    match Arms
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#conditional-if-let-expressions">
    Conditional if let Expressions
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#while-let-conditional-loops">
    while let Conditional Loops
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#for-loops">
    for Loops
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#let-statements">
    let Statements
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#function-parameters">
    Function Parameters
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#refutability-whether-a-pattern-might-fail-to-match">
    Refutability: Whether a Pattern Might Fail to Match
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#pattern-syntax">
    Pattern Syntax
  </a>
<nav aria-label="Pattern Syntax" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#matching-literals">
    Matching Literals
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#matching-named-variables">
    Matching Named Variables
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-patterns">
    Multiple Patterns
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#matching-ranges-of-values-with">
    Matching Ranges of Values with ..=
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#destructuring-to-break-apart-values">
    Destructuring to Break Apart Values
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#destructuring-enums">
    Destructuring Enums
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#destructuring-structs-and-tuples">
    Destructuring Structs and Tuples
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_">
    _ 패턴
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ignoring-an-unused-variable-by-starting-its-name-with-_">
    Ignoring an Unused Variable by Starting Its Name with _
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ignoring-remaining-parts-of-a-value-with">
    Ignoring Remaining Parts of a Value with ..
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#extra-conditionals-with-match-guards">
    Extra Conditionals with Match Guards
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#bindings">
    @ Bindings
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#advanced-features">
    Advanced Features
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#unsafe-rust">
    Unsafe Rust
  </a>
<nav aria-label="Unsafe Rust" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#unsafe-superpowers">
    Unsafe Superpowers
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#1-dereferencing-a-raw-pointer">
    1. Dereferencing a Raw Pointer
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-calling-an-unsafe-function-or-method">
    2. Calling an Unsafe Function or Method
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-access-or-modify-a-mutable-static-variable">
    3. Access or modify a mutable static variable
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-implement-an-unsafe-trait">
    4. Implement an unsafe trait
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#5-access-files-of-unions">
    5. Access files of unions
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#advanced-traits">
    Advanced Traits
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types">
    Specifying Placeholder Types in Trait Definitions with Associated Types
  </a>
<nav aria-label="Specifying Placeholder Types in Trait Definitions with Associated Types" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#default-generic-type-parameters-and-operator-overloading">
    Default Generic Type Parameters and Operator Overloading
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">
    Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-supertraits-to-require-one-traits-functionality-within-another-trait">
    Using Supertraits to Require One Trait’s Functionality Within Another Trait
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types">
    Using the Newtype Pattern to Implement External Traits on External Types
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#using-the-newtype-pattern-for-type-safety-and-abstraction">
    Using the Newtype Pattern for Type Safety and Abstraction
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#creating-type-synonyms-with-type-aliases">
    Creating Type Synonyms with Type Aliases
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#the-never-type-that-never-returns">
    The Never Type that Never Returns
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#dynamically-sized-types-and-the-sized-trait">
    Dynamically Sized Types and the Sized Trait
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#advanced-functions-and-closures">
    Advanced Functions and Closures
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#function-pointers">
    Function Pointers
  </a>
<nav aria-label="Function Pointers" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#returning-closures">
    Returning Closures
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#macros">
    Macros
  </a>
<nav aria-label="Macros" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#the-difference-between-macros-and-functions">
    The Difference Between Macros and Functions
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">
    Declarative Macros with macro_rules! for General Metaprogramming
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#procedural-macros-for-generating-code-from-attributes">
    Procedural Macros for Generating Code from Attributes
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#how-to-write-a-custom-derive-macro">
    How to Write a Custom derive Macro
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#attribute-like-macros">
    Attribute-like macros
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#function-like-macros">
    Function-like macros
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1>Rust Memo</h1>
<p>Rust 는 <a href="https://doc.rust-lang.org/book/">Official Documentation</a> 이 매우 잘 정립되어 있어서 이것을 기반으로 쉽게 배울 수 있는데 이 문서의 특징은 기존의 C++ 언어 같은 memory-unsafe 언어와는 달리 어떻게 Rust 가 memory-safe 언어를 이룰 수 있었는지에 대한 철학과 규칙을 설명한다는 것이다. </p>
<p>다음 리스트는 기존의 C/C++ 같은 memory-unsafe 언어가 근본적으로 우리를 해킹취약점으로부터 구원할 수 없기 때문에 애초에 Rust 나 Swift 같은 memory-safe 언어를 사용해야 한다는 주장의 논거가 되는 글들이다.</p>
<ul>
<li>
<p><a href="https://alexgaynor.net/2019/apr/21/modern-c++-wont-save-us/">Modern C++ Won't Save Us</a></p>
</li>
<li>
<p><a href="https://www.yodaiken.com/2021/05/19/undefined-behavior-in-c-is-a-reading-error/">Undefined behavior in C is a reading error.</a></p>
</li>
<li>
<p><a href="https://www.cppstories.com/2021/security-sins/">C++ Software Security Sins</a></p>
</li>
<li>
<p><a href="https://kornel.ski/rust-c-speed">Speed of Rust vs. C</a></p>
</li>
<li>
<p><a href="https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/">Google is now writing low-level Android code in Rust</a></p>
</li>
<li>
<p><a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Google-Wants-Rust-In-Kernel">Google Wants Rust In Kernel</a></p>
</li>
<li>
<p><a href="https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/">Microsoft: 70 percent of all security bugs are memory safety issues</a></p>
</li>
<li>
<p><a href="https://www.chromium.org/Home/chromium-security/memory-safety">Chromium project finds that 70% of security defects are memory safety problems</a></p>
</li>
<li>
<p><a href="https://daniel.haxx.se/blog/2020/10/09/rust-in-curl-with-hyper/">Memory safe ‘curl’ for a more secure internet</a></p>
</li>
</ul>
<p>특히 이 문서가 memory-safe 언어를 사용해야 하는 중요한 근거가 될 수 있을듯.</p>
<ul>
<li><a href="https://security.googleblog.com/2021/02/mitigating-memory-safety-issues-in-open.html">Mitigating Memory Safety Issues in Open Source Software</a></li>
</ul>
<p>C/C++ 시대는 가고 memory-safe 언어(Rust, Go, Swift 등)의 시대가 오지 싶네.</p>
<p>그래서 Rust 를 익혀보자 이거지요. 그러니까 위 공식 문서에서 설명되는 Rust 만의 독특한 철학과 규칙들을 좀 정리해두어야 할 필요가 있다. Rust 의 문법은 정리할 필요가 없지만, 다른 언어에서 찾아볼 수 없는 Rust 만의 독특한 문법같은 경우는 예외적으로 정리해둘 필요가 있다. </p>
<p>다음 메일기록은 Linux community 가 Rust 를 Linux kernel 이 지원하는 공식적인 두번째 언어로 채택했다는 것을 알려준다.</p>
<ul>
<li><a href="https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/">https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/</a></li>
</ul>
<h2 id="ownership-rules">Ownership Rules<a class="headerlink" href="#ownership-rules" title="Permanent link">¶</a></h2>
<ul>
<li>
<p>Each value in Rust has a variable that’s called its owner.</p>
</li>
<li>
<p>There can only be one owner at a time.</p>
</li>
<li>
<p>When the owner goes out of scope, the value will be dropped.</p>
<ul>
<li>
<p>메모리를 사용하면 지금까지 그것을 해제하는 두 가지 방법이 있었다. 첫째는 GC 를 사용하는 것이다. GC 는 더 이상 참조될 수 없는 포인터가 발견되면 자동으로 메모리를 해제해준다. 둘째는 직접 메모리를 해제해주는 것이다. 하지만 직접 해제를 너무 빨리하면 부적절한 포인터가 발생하고 너무 늦게하면 메모리가 낭비되며 두번 해제하면 double free 버그가 발생한다. </p>
<p>Rust 는 이와 달리 scope 를 넘어서면 drop 함수를 호출하여 자동으로 메모리를 해제해주는 방식을 택했다. </p>
</li>
</ul>
</li>
</ul>
<h2 id="move">Move<a class="headerlink" href="#move" title="Permanent link">¶</a></h2>
<p>String 은 스택에 ptr, len, capacity 를 저장하는데 String 변수를 다른 변수에 저장하면 ptr, len, capacity 가 스택에 저장되고, 힙에 있는 데이터 자체가 복사되지는 않는다. 하지만 Rust 가 scope 를 넘어서면 메모리를 해제해주기 때문에 두 String 변수가 살아있으면 double free 버그가 발생한다. 따라서 String 변수를 다른 변수에 저장하면 Rust 는 이전 변수를 더 이상 사용할 수 없고 해제할 필요도 없는 죽은 변수로 취급한다.</p>
<p>그러므로 Rust 가 동적 메모리 포인터를 복사하는 방식은 shallow copy 와 비슷하다. shallow copy 는 힙에 있는 실제 데이터를 복사하지 않고 포인터ptr, 길이len, 용량capacity만 복사하는 것이기 때문이다. 하지만 Rust 는 shallow copy 를 하는 것이 아닌데, 왜냐하면 이전의 변수를 죽이기 때문이다. 그러므로 Rust 는 Move 를 한다고 말하는 게 맞다.</p>
<h2 id="copy">Copy<a class="headerlink" href="#copy" title="Permanent link">¶</a></h2>
<p>단 integer 같이 완전히 stack 에 저장되고 데이터 사이즈를 파악할 수 있는 것들은 다른 변수에 저장할 때 실제 데이터까지 잘 복사가 된다.</p>
<p>만약 어떤 타입에 Copy trait 가 선언되면 integer 를 복사하는 것처럼 저장될 때 복사된다. 이 trait 는 Drop trait 와 함께 선언될 수 없다. integer, bool, float, character, tuple 같은 것들에 Copy trait 가 선언되어있다.</p>
<h2 id="_1">함수 인자 전달<a class="headerlink" href="#_1" title="Permanent link">¶</a></h2>
<p>함수 인자 전달은 Move 이거나 Copy 이다. Move 로 파라미터를 전달하면 그 변수의 Ownership 이 넘어간 것이므로 더 이상 사용할 수 없다. Copy 로 파라미터를 전달하면 계속 변수를 사용할 수 있다.</p>
<h2 id="_2">함수 반환값 전달<a class="headerlink" href="#_2" title="Permanent link">¶</a></h2>
<p>함수 반환값 전달도 Move 이거나 Copy 이다. 함수가 return 하는게 Move 이면 Ownership 이 상위 함수로 이동한다.</p>
<h2 id="reference">Reference<a class="headerlink" href="#reference" title="Permanent link">¶</a></h2>
<p>하지만 함수가 Ownership 을 가져가지 않고 값만 사용하게 하고 싶다면 Reference 를 사용한다. Reference 를 만들면 Ownership 은 갖고 있지 않게 된다.</p>
<p>만약 <code>let s1: String</code> 의 Ownership 을 넘겨주지 않고 값만 넘겨주고 싶다면 <code>let s :&amp;String = &amp;s1</code> 처럼 한다. String 이 ptr, len, capacity 를 갖고 있다면 &amp;String 은 ptr 만 갖고 있다. </p>
<p>Reference 를 함수 파라미터로 넘겨주는 것을 borrowing 이라 한다. borrowing 해온 변수는 수정할 수 없다.</p>
<h2 id="mutable-reference">Mutable Reference<a class="headerlink" href="#mutable-reference" title="Permanent link">¶</a></h2>
<p>그런데 예외적으로 Reference 를 사용할 때에도 값을 변경해야 하는 경우가 있다. 이 경우 <code>let mut s1: String</code> 에 대하여 <code>let s: &amp;mut String = &amp;mut s1</code> 와 같이 하면 된다. 이렇게 Mutable Reference 를 만들 수 있다. 그리고 dereferencing 을 사용하여 <code>*s = (VALUE)</code> 로 변경할 수 있다.</p>
<p>하지만 Mutable Reference 는 위험하기 때문에 다음과 같은 제약사항이 있다. </p>
<ul>
<li>
<p>특정 데이터에 대한 스코프 내에서 Mutable Reference 는 유일하다.</p>
<p>다른 언어들은 이런 제약이 없지만 이 제약으로 인하여 Rust 는 컴파일할 때 data race 를 예방한다. 이로써 두개 이상의 포인터가 같은 데이터에 같이 접근하는 data race 를 예방한다.</p>
</li>
<li>
<p>Reference 가 있다면 Mutable Reference 는 없다.</p>
<p>이 제약이 존재하는 이유는 Reference 를 가져간 공간에서는 해당 데이터가 불변할 거라고 기대하기 때문이다. (그러면 owner 가 데이터를 바꾸는 경우에도 컴파일 에러가 발생하나? cannot assign to <code>s</code> because it is borrowed 라고 에러가 발생하네.)</p>
<p>이때 Reference 의 스코프는 Reference 가 마지막으로 사용된 때까지 이므로 Reference 가 선언되어도 마지막으로 사용된 이후에 Mutable Reference 가 선언되고 사용되면 아무런 문제가 발생하지 않는다.</p>
</li>
</ul>
<h2 id="slice">Slice<a class="headerlink" href="#slice" title="Permanent link">¶</a></h2>
<p>Slice 도 Reference 와 같이 데이터에 대한 Ownership 을 갖지 않는 데이터 타입이다. 하지만 Reference 와 다르게 Slice 는 연속적인 데이터의 부분 데이터를 참조한다.</p>
<p><code>let s: String = String::from("hello word")</code> 의 Slice 를 만드려면 <code>let world: &amp;str = s[6..11]</code> 와 같이 만들 수 있다. 이것은 s 의 7번째 바이트부터 5바이트만큼의 slice 를 만든다는 것이다. </p>
<p>기존의 String 이 ptr, len, capacity 로 구성되었다면 slice 는 ptr, len 으로 구성된다.</p>
<p>String 의 Slice 를 생성할 수 있지만, Slice 의 Slice 도 생성할 수 있다.</p>
<p>String literal 은 String Slice 이다. 즉, <code>let s: &amp;str = "abc";</code> 이다.</p>
<p>지금까지 String 의 Slice 만 살펴보았지만 Slice 는 일반적인 타입이다. integer 배열의 Slice 를 만들 수도 있다. <code>let a: [i32; 5] = [1,2,3,4,5]</code> 의 slice 를 <code>let slice: &amp;[i32] = &amp;a[1..];</code> 와 같이 만들 수 있다.</p>
<hr/>
<h2 id="struct">Struct<a class="headerlink" href="#struct" title="Permanent link">¶</a></h2>
<p>Struct 는 관련된 데이터를 모아주는 데이터타입이다. OOP 에서 Data 와 기능이 있다면 Struct 가 Data 를 담당한다. </p>
<p>기본 Struct 외에도 tuple Struct 와 Unit-Like Struct 를 선언할 수도 있다. Unit-Like Struct 는 아무 필드가 없지만, 아무 데이터가 없는 타입에 대한 trait 를 구현할 때 사용된다.</p>
<p>Struct 를 사용하는 연습을 할 때 <code>&amp;str</code> 이 아니라 String 타입으로 문자열을 멤버로 선언했다. 그 이유는 Struct 의 멤버 전체가 Struct 가 살아있을 때까지 살아있는다는 보장이 필요하기 때문이다. 그러나 물론 Struct 에서 Reference 를 멤버로 가질 수 있는 장치인 lifetime 이 있다. lifetime 은 Reference 인 Struct 멤버가 Struct 의 수명보다 같거나 길다는 것을 보장해준다. 만약 lifetime 없이 Struct 에 Reference 를 멤버로 정하면 에러가 발생한다.</p>
<h2 id="method">Method<a class="headerlink" href="#method" title="Permanent link">¶</a></h2>
<p>Method 는 Function 과 거의 비슷한 문법을 가지지만, Function 과 달리 Struct 과 관련되어 <code>impl</code> 블록 안에 정의된다. Method 의 첫번째 파라미터에는 <code>self</code> 키워드가 있어야 한다. <code>self</code> 는 Struct 의 인스턴스를 뜻한다. </p>
<p>많은 경우 Method 의 첫번째 파라미터를 <code>&amp;self</code> 로 정하여 인스턴스의 Ownership 을 가져오지 않는다. 만약 <code>self</code> 로 한다면 Ownership 이 가져와져서 Method 의 스코프가 끝날 때 인스턴스의 메모리가 해제되기 때문에 예외적인 상황에서만 사용된다. <code>self</code> 를 사용하는 경우는 인스턴스 자체를 바꾸고 caller 가 원래의 인스턴스를 사용하지 못하게 하는 경우를 들 수 있다.</p>
<p><code>&amp;mut self</code> 로 Method 에서 인스턴스의 데이터를 변경할 수 있다. 인스턴스를 수정해야 할 때 왠만하면 <code>self</code> 보다 <code>&amp;mut self</code> 를 사용하겠지만, <code>&amp;mut self</code> 는 인스턴스 자체가 Mutable 로 선언되어야 한다는 단점이 있다. immutable 인스턴스를 기반으로 새로운 인스턴스를 만들어서 반환해야 할 때 <code>self</code> 를 쓰면 되겠지.</p>
<h2 id="automatic-referencing-and-dereferencing">Automatic referencing and dereferencing<a class="headerlink" href="#automatic-referencing-and-dereferencing" title="Permanent link">¶</a></h2>
<p>C/C++ 에서는 인스턴스의 멤버를 참조할 때 <code>.</code> 을 사용하고 포인터의 멤버를 참조할 때 <code>-&gt;</code> 를 사용한다. 하지만 Rust 는 Automatic referencing and dereferencing 기능이 있어서 Reference 의 멤버를 참조할 때 원래 인스턴스에서 멤버를 참조하는 것처럼 <code>.</code> 을 사용한다.</p>
<h2 id="associated-functions">Associated Functions<a class="headerlink" href="#associated-functions" title="Permanent link">¶</a></h2>
<p><code>impl</code> 블록 안에는 <code>self</code> 파라미터가 없는 Associated Function 을 정의할 수 있다. 이는 Struct 의 인스턴스를 받지 않으므로 Method 가 아니지만, Struct 와 밀접한 관련이 있는 함수이다. 가령 <code>String::from</code> 이 Associated Function 이다. 이처럼 Associated Function 은 대표적으로 Struct 의 Constructor 로 사용된다.</p>
<hr/>
<h2 id="enum">Enum<a class="headerlink" href="#enum" title="Permanent link">¶</a></h2>
<p>커스텀 타입을 만드는 방법은 Struct 외에도 Enum 이 있다. Enum 은 특정 타입의 데이터가 여러 변형을 가지는 것을 표현하기 위하여 사용된다. 가령 IP 의 버전에는 v4, v6 이 있는데 이 변형을 표현하기 위하여 enum 을 사용할 수 있다.</p>
<p>Enum 은 여러 변형에 대한 추상 데이터가 되어 모든 변형들을 한꺼번에 다룰 수 있다. 가령 함수 선언에서 enum 을 쓰면 모든 변형을 파라미터로 받을 수 있다.</p>
<p>Enum 의 변형에 데이터 타입을 연관시킬 수 있는데, 이렇게 하면 Enum 변형이 가지는 데이터를 표현할 추가적인 Struct 를 선언하지 않아도 된다.</p>
<h2 id="enum-method">Enum Method<a class="headerlink" href="#enum-method" title="Permanent link">¶</a></h2>
<p>Enum 도 Struct 와 같이 <code>impl</code> 블록 안에 Method 를 구현할 수 있다.</p>
<h2 id="important-enum-option">Important Enum: Option<t><a class="headerlink" href="#important-enum-option" title="Permanent link">¶</a></t></h2>
<p><code>Option&lt;T&gt;</code> 는 Rust 에서 null 로 인하여 발생하는 수많은 버그를 해결하기 위하여 만든 Enum 이다. 이 <code>Option&lt;T&gt;</code> 는 <code>Some&lt;T&gt;</code> 과 <code>None</code> 이라는 변형을 가지는데, 이것 외에 null 을 표현할 수 있는 변수는 존재하지 않는다. 이 설계 덕분에 <code>Option&lt;T&gt;</code> 가 아닌 모든 변수는 null 이 아니라는 보장을 얻을 수 있다. </p>
<h2 id="match">Match<a class="headerlink" href="#match" title="Permanent link">¶</a></h2>
<p>Match 는 Enum 의 모든 변형들의 경우에 대한 처리를 할 때 사용된다. 그래서 어떤 변형이라도 <code>match</code> 에서 제외되면 에러가 발생한다. <code>match</code> 가 <code>if-else</code> 와 다른 점은 <code>if-else</code> 는 <code>bool</code> 타입을 넣을 수 있는데 <code>match</code> 에는 어떤 타입이라도 넣을 수 있다는 것이다.</p>
<p>기본적으로 <code>match</code> 의 case 에 대상 데이터와 다른 자료형을 넣을 수 없고, 자유변수가 들어간다면 임의의 대상 데이터가 매칭된다. case 에는 자료형 자체가 아니라 literal 이 들어가야 하는데, 나는 처음에 자료형 자체를 넣어야 하는 줄 알고 <code>u32</code> 같은 자료형을 넣어봤는데 대상 데이터가 String 인데도 매칭이 되는거야. 그래서 조사해보니까 <code>u32</code> 가 자유변수로 인식되어서 <code>u32</code> 라는 변수에 String 타입 대상 데이터가 전달되었던 거였지.</p>
<h2 id="if-let">if let<a class="headerlink" href="#if-let" title="Permanent link">¶</a></h2>
<p><code>match</code> 는 데이터의 모든 경우에 대한 행동을 정의하지 않으면 사용할 수 없다. 하지만 우리는 하나의 경우에 대해서만 다루고 싶을 때도 있다. 하나의 경우만 다루더라도 <code>_ =&gt; ()</code> 을 써야하듯이 <code>match</code> 는 너무 장황해진다.</p>
<p>그러므로 이렇게 하나의 경우만 다룰 경우 <code>match</code> 대신 <code>if let</code> 문법을 쓰면 된다. <code>if let</code> 은 <code>=</code> 으로 매칭 패턴과 대상 데이터를 구분하는데, 이는 <code>match</code> 의 매칭 패턴, 대상 데이터와 완전히 동일하다.</p>
<hr/>
<h2 id="package-crate">Package 와 Crate<a class="headerlink" href="#package-crate" title="Permanent link">¶</a></h2>
<p>crate 는 바이너리 혹은 라이브러리이다. crate root 는 Rust 가 컴파일을 시작할 소스 파일이다. </p>
<p>package 란 특정한 기능을 제공하는 하나 이상의 crate 들이다. package 는 반드시 하나 이상의 바이너리 crate 를 가져야 하고, 반드시 0개나 1개의 라이브러리 crate 를 가져야 한다. </p>
<p>package 는 Cargo.toml 파일을 갖고 crate 들을 어떻게 빌드할지 정의한다.  Cargo.toml 이 crate 를 어떻게 빌드할지 정한다고 했지만, 우리가 <code>cargo new</code> 를 통해 생성한 package 가 갖고 있는 엔트리 포인트인 <code>src/main.rs</code> 가 Cargo.toml 에는 없다. 이는 <code>src/main.rs</code> 가 바이너리 crate 의 디폴트 엔트리 포인트이기 때문이다.</p>
<p>Cargo 는 <code>src/main.rs</code> 가 있으면 이를 package 의 이름과 같은 바이너리 crate 로 인식한다. 또한 <code>src/lib.rs</code> 가 있으면 이를 package 의 이름과 같은 라이브러리 crate 로 인식한다.</p>
<p>package 는 바이너리 crate 소스를 src/bin/ 에 위치시킴으로써 여러 바이너리 crate 를 가질 수 있다.</p>
<h2 id="module">Module<a class="headerlink" href="#module" title="Permanent link">¶</a></h2>
<p><code>pub</code> 키워드는 아이템을 public 으로 만든다.</p>
<p><code>mod</code> 키워드는 Module 을 만든다. Module 은 crate 의 코드를 가독성과 재사용성을 위해 여러 그룹들로 모을 수 있게 해준다. Module 은 또한 아이템을 public 으로 만들거나 private 으로 만든다.</p>
<p>src/main.rs 와 src/lib.rs 가 crate root 라고 했는데 그 이유가 이 파일의 내용이 "crate" 라는 Module 을 이루고 이 Module 이 crate 의 모듈 구조(module tree)의 root 가 되기 때문이다.</p>
<p>Module 내부의 아이템을 사용하기 위하여 path 를 사용한다. path 는 절대 경로와 상대 경로가 있다. 절대 경로는 crate root 인 <code>crate</code> 부터 해당 아이템까지의 모든 경로를 다 사용하여 아이템을 참조하는 것이다. 상대경로는 현재 Module 로부터 경로를 시작하여 아이템을 참조하는 것이다. <code>super</code> 키워드로 상대경로를 한 단계 상위의 Module 에서부터 시작할 수도 있다.</p>
<p>하위 Module 은 상위 Module 의 아이템을 사용할 수 있지만, 상위 Module 은 하위 Module 이 public 이 아닌 이상 하위 Module 의 아이템을 사용할 수 없다. 만약 서로 같은 레벨의 아이템들이라면 다른 아이템이 public 이 아니어도 참조할 수 있다.</p>
<p>Struct 도 Module 안에 정의할 수 있다. Struct 를 public 으로 만든 것으로 필드값들이 public 이 되는 것은 아니다. Struct 의 필드값 각각에 <code>pub</code> 키워드를 사용해야 각 필드에 접근 할 수 있다.</p>
<p>Struct 를 public 으로 지정한 이후에 필드도 public 으로 지정해야만 Struct 의 필드에 접근할 수 있는 것과 달리, Enum 은 public 으로 지정되면 모든 변형이 public 이 된다. </p>
<h3 id="module_1">Module 위계<a class="headerlink" href="#module_1" title="Permanent link">¶</a></h3>
<p>같은 레벨이면 namespace 로 참조하지 않아도 item 을 참조할 수 있다. 가령 <code>main</code> 함수 바로 위에 선언된 <code>test</code> 라는 함수를 <code>main</code> 함수에서 바로 호출할 수 있다.</p>
<p>하지만 Module 로 분리되면 다른 레벨이 된다. 이 경우 같은 Module 인데 상하 관계가 분리되었는지, 아예 다른 Module 로 분리되었는지 나뉜다.</p>
<p>같은 Module 인데 상하 관계가 분리되었다면 하위 레벨에서 상위 레벨의 item 을 그냥 참조할 수 있다. 하지만 상위 레벨에서 하위 레벨의 public 이 아니면 참조할 수 없다.</p>
<p>아예 다른 Module 로 분리되었다면 상대 경로나 절대 경로로 Module Path 를 지정해주어야 item 을 참조할 수 있다.</p>
<h2 id="use">use<a class="headerlink" href="#use" title="Permanent link">¶</a></h2>
<p><code>use</code> 키워드는 아이템에 대한 경로를 가져온다. Module 의 경로를 매번 반복하기가 너무 힘들 때 <code>use</code> 를 쓴다. <code>use</code> 에 절대경로를 입력할 수도 있고 상대경로를 입력할 수도 있다.</p>
<p><code>as</code> 키워드로 <code>use</code> 키워드로 가져온 아이템에 다른 이름을 부여할 수 있다.</p>
<p><code>pub use</code> 키워드로 <code>use</code> 키워드가 편리하게 만든 경로 단축을 외부에서도 사용하게 할 수 있다.</p>
<h2 id="separating-modules-into-different-files">Separating Modules into Different Files<a class="headerlink" href="#separating-modules-into-different-files" title="Permanent link">¶</a></h2>
<p><code>mod</code> 키워드로 Module 을 선언 후 바디를 정의하지 않고 세미콜론 <code>;</code> 으로 Module 선언을 끝내버리면, Rust 는 Module 이름과 같은 다른 파일(src/[Module Name].rs)에서 Module 바디의 정의를 찾는다. </p>
<p>분리된 Module 내에서도 Module 을 분리시켜 선언한다면 (src/[Module Name]/[Sub Module Name].rs) 에서 Module 바디를 찾는다.</p>
<hr/>
<h2 id="collections">Collections<a class="headerlink" href="#collections" title="Permanent link">¶</a></h2>
<p>built-in array 나 tuple 외에 데이터가 힙 메모리에 저장되는 데이터 타입을 Collections 이라 한다. </p>
<h3 id="vector">Vector<a class="headerlink" href="#vector" title="Permanent link">¶</a></h3>
<p>Vector 도 Mutable Reference 와 immutable Reference 를 함께 가질 수 없다는 규칙을 따라야 한다. 그러므로 <code>let mut v = vec![1]; let n = &amp;v[0]; v.push(1);</code> 이라는 코드는 에러이다. <code>&amp;v[0]</code> 으로 immutable Reference 를 가져온 후 <code>v.push(1)</code> 로 Mutable Reference 가 생성되기 때문이다.</p>
<p>Vector 는 같은 타입의 데이터만 저장되도록 하기 때문에 어떤 상황에서 불편할 수 있다. 이럴 때는 필요한 데이터 타입을 Enum 으로 정의해서 Enum 데이터를 Vector 에 저장하면 된다.</p>
<h3 id="string">String<a class="headerlink" href="#string" title="Permanent link">¶</a></h3>
<p><code>String::push_str(s)</code> 함수는 s 의 Ownership 을 가져가지 않는다.</p>
<p>String 을 서로 붙일 때 <code>let a="a".to_string();let b="b".to_string();let c=a+&amp;b;</code> 와 같이 하면 a 는 c 로 Move 되어서 더 이상 사용될 수 없다.</p>
<p>String 은 indexing 을 지원하지 않는다. String 은 <code>Vec&lt;u8&gt;</code> 의 wrapper 이다. 따라서 <code>let s = String::from("Hola");</code> 와 같은 영어를 저장할 때 4byte 로 잘 저장된다. 하지만 <code>let hello = String::from("Здравствуйте");</code> 와 같은 UTF-8 언어를 저장할 때는 문자 당 2byte 가 필요해진다. <code>let s = &amp;hello[0];</code> 으로 인덱싱을 하면 "З" 이라는 문자가 UTF-8 로 인코딩 되어 2byte 를 사용하면서 208, 151 로 저장되기 때문에 208 이 반환되어야 한다. 하지만 208 은 올바른 문자가 아니다. 우리가 원하는 것은 "З" 인데 이것을 UTF-8 2byte 로 표현하려면 208, 151 이 필요하다. 따라서 개발자가 기대한 값이 반환되지 않는 상황과 그 상황으로 인한 버그를 차단하기 위하여 Rust 는 아예 String 에 대한 indexing 을 지원하지 않기로 결정했다. </p>
<p>하나의 숫자로 String 을 [] 로 indexing 은 차단하는 대신 정말로 굳이 String slice 가 필요한 경우를 위하여 숫자 범위로 String 을 [] 로 indexing 하는 것은 허용한다. 그래서 <code>let s = &amp;hello[0..4];</code> 와 같은 첫 4byte 를 가져오겠다는 코드는 허용된다. 하지만 0..1 이나 0..3 같이 slice 를 만들면 invalid chracter boundary 를 참조했다면서 panic 에 빠진다. 그래서 범위를 참조할 때 엄청 조심해야 한다.</p>
<h3 id="hashmap">HashMap<a class="headerlink" href="#hashmap" title="Permanent link">¶</a></h3>
<p>이 Collections 은 Key, Value 구조를 갖는 데이터 구조이다. Ownership 을 갖는 데이터만 Key:Value 로 등록해야 한다. Reference 를 HashMap 에 등록하려면 Reference 가 HashMap 이 살아있는 동안 반드시 살아있어야 한다는 보장(lifetime)이 필요하다. lifetime 없이는 Reference 를 HashMap 에 등록할 수 없다.</p>
<hr/>
<h2 id="error">Error<a class="headerlink" href="#error" title="Permanent link">¶</a></h2>
<p>Rust 는 error 를 recoverable 과 unrecoverable 로 구분한다. 다른 언어는 이 구분을 하지 않고 모든 error 를 같은 방식으로 처리하지만, Rust 는 recoverable 을 위하여 <code>Result&lt;T, E&gt;</code> 타입을 만들었고 unrecoverable 을 위하여 panic! 을 만들었다. </p>
<h3 id="unrecoverable-error">unrecoverable error<a class="headerlink" href="#unrecoverable-error" title="Permanent link">¶</a></h3>
<p>panic 이 일어났을 때 stack 을 역추적하면서 clean up 을 하는 unwinding 을 한다. 하지만 unwinding 은 상당히 많은 작업을 필요로 하므로 panic 의 행동을 unwinding 에서 abort 로 바꿀 수 있다. abort 는 메모리 정리를 하지 않고 바로 종료시킨 후 메모리 정리를 OS 에 맡긴다. 만약 최종 컴파일된 실행파일의 크기를 최대한 줄이고 싶다면 Cargo.toml 에 </p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="n">profile</span><span class="p">.</span><span class="n">release</span><span class="p">]</span> 
<span class="n">panic</span> <span class="o">=</span> <span class="s">'abort'</span> 
</code></pre></div>
<p>라고 설정하면 된다.</p>
<h3 id="recoverable-error">recoverable error<a class="headerlink" href="#recoverable-error" title="Permanent link">¶</a></h3>
<p>recoverable 에러는 </p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span>
<span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>
<p>로 다뤄진다. 가령 <code>let f = File::open("test.txt");</code> 은 <code>Result&lt;File, Error&gt;</code> 를 반환하므로 </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="err">에러처리</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>와 같이 사용하면 된다. Err 일 경우 panic 을 하든지, 다른 파일 이름을 입력하게 하든지 에러 처리를 하면 된다. Option Enum 처럼 Result Enum 도 prelude 에 있으므로 <code>Result::Ok</code> 가 아니라 그냥 <code>Ok</code> 로 해도 된다.</p>
<p>error 를 caller 함수에서 처리하도록 propagating 하는 방법도 있다. 이는 callee 함수에서 <code>Result&lt;T, E&gt;</code> 자체를 반환하는 것이다. 하지만 <code>Result&lt;T, E&gt;</code> 를 반환하기 위하여 <code>match</code> 를 사용해야 하는데, 이 propagating 패턴이 자주 사용되어서 <code>?</code> 로도 propagating 할 수 있게 되었다.</p>
<p><code>?</code> 는 Result 바로 뒤에 위치하여 <code>Result&lt;T, E&gt;</code> 를 propagating 하기 위한 <code>match</code> 문과 거의 비슷하게 작동한다. <code>Result</code> 가 Ok 라면 Ok 의 값이 반환되고 <code>Err</code> 라면 <code>Err</code> 가 return 된다. 따라서 <code>?</code> 로 propagating 을 했을 경우 <code>?</code> 는 <code>Err</code> 만 return 해주기 때문에, 마지막에 <code>Ok</code> 값을 return 해주어야 한다.</p>
<p>propagating 에서 <code>?</code> 가 <code>match</code> 와 다른점은 <code>?</code> 에서의 에러는 에러 타입을 변환하는데 사용되는 <code>From</code> trait 가 정의된 <code>from</code> 함수를 거쳐간다는 것이다. <code>?</code> 가 <code>from</code> 함수를 호출하면 발생한 에러 타입이 함수의 반환에서의 에러 타입으로 변환된다. 이는 함수 내에서 발생하는 모든 에러를 함수의 반환 에러 타입이 대표할 수 있을 때 유용하다.</p>
<p>일반적으로 <code>?</code> 는 propagating 뿐만 아니라 <code>Result</code> 타입, <code>Option</code> 타입 등 <code>std::ops::Try</code> 를 구현한 타입을 반환하는 모든 곳에서 사용될 수 있다.</p>
<h3 id="choice-to-recoverable-or-unrecoverable">Choice to recoverable or unrecoverable<a class="headerlink" href="#choice-to-recoverable-or-unrecoverable" title="Permanent link">¶</a></h3>
<p><code>panic!</code> 은 unrecoverable 인 상황에서만 사용한다. 하지만 다른 많은 경우 <code>Result</code> 를 반환해라. 그러면 caller 에서 <code>Result</code> 의 <code>Err</code> 를 보고 또 다시 recoverable 인지 unrecoverable 인지 판단할 수 있다.</p>
<p>예측 가능한 에러라면 recoverable 이고, 예측 불가능한 에러라면 unrecoverable 이다. 에러를 fix 할 방법이 있으면 recoverable 이고 방법이 없으면 unrecoverable 이다. </p>
<h3 id="advice-to-error-handling">Advice to error handling<a class="headerlink" href="#advice-to-error-handling" title="Permanent link">¶</a></h3>
<p>Rust 튜토리얼에서는 랜덤값 맞추기 예제가 나오는데 유저는 1~100 까지의 숫자를 입력해야 한다. 이것의 에러를 매번 검사하는 것이 아니라 새로운 타입을 만들고 그것에 적용되는 메소드를 만들면 값이 생성될 때 에러처리가 자동으로 된다. 이렇게 하면 모든 곳에서 매번 에러 처리를 할 필요가 없는 거지.</p>
<hr/>
<h2 id="dereferencing-coercion">dereferencing coercion<a class="headerlink" href="#dereferencing-coercion" title="Permanent link">¶</a></h2>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="s">"a"</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="s">"b"</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="o">=</span><span class="n">a</span><span class="o">+&amp;</span><span class="n">b</span><span class="p">;</span><span class="w"> </span>
</code></pre></div>
<p>와 같은 코드가 가능한 이유는 <code>+</code> 가 <code>fn add(self, s: &amp;str) -&gt; String</code> 이라는 함수로 변환되기 때문이다. 첫번째 파라미터가 <code>self</code> 이므로 Reference 기호 <code>&amp;</code> 를 <code>a</code> 에는 안붙혀도 되고, <code>a</code> 의 Ownership 이 이동하는 것이다.</p>
<p>이때 <code>&amp;b</code> 는 <code>&amp;String</code> 이고 <code>&amp;str</code> 이 아닌데 어떻게 두번째 파라미터로 전달될 수 있었을까? 이는 Rust 가 <code>&amp;b</code> 를 <code>&amp;b[..]</code> 으로 변환시켜서 <code>&amp;String</code> 을 <code>&amp;str</code> 로 변환시키기 때문이다. 이것이 deref coercion 이다.</p>
<h2 id="main-function-return-type">main function return type<a class="headerlink" href="#main-function-return-type" title="Permanent link">¶</a></h2>
<p><code>main</code> 함수의 반환값은 <code>()</code> 와 <code>Result&lt;T, E&gt;</code> 이 가능하다.</p>
<h2 id="for">for<a class="headerlink" href="#for" title="Permanent link">¶</a></h2>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">max</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">l</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>&amp;l</code> 이라고 안하면 <code>l</code> 의 Ownership 이 for-loop 안으로 이동되고 for-loop 의 스코프가 끝날 때 해제되버린다. <code>&amp;n</code> 이라고 안하고 <code>n</code> 이라고 하면 <code>n</code> 은 <code>&amp;i32</code> 이기 때문에 <code>*n</code> 으로 해야 max 와 연산할 수 있다. </p>
<hr/>
<h2 id="generic">Generic<a class="headerlink" href="#generic" title="Permanent link">¶</a></h2>
<p>여러 데이터 타입에 적용되는 반복되는 코드를 Generic 으로 통합시킬 수 있다. Method 와 Struct 와 enum 에 Generic 을 사용할 수 있다. <code>impl</code> 블록도 Generic 으로 구현할 수 있고, 특정 데이터 타입에만 구현할 Method 를 선언하는 <code>impl</code> 블록을 선언할 수도 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="kt">f32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Generic 으로 구현된 <code>impl</code> 블록 안에서도 Generic 메소드를 선언할 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Point</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="monomorphization">Monomorphization<a class="headerlink" href="#monomorphization" title="Permanent link">¶</a></h3>
<p>C++ 같은 경우 Template 을 많이 사용하면 v-table 인가 그런것 때문에 성능이 떨어진다고 들었었는데, Rust 는 Monomorphization 이라는 Generic 을 컴파일 상에서 특정 데이터 타입으로 바꿔주는 기법 때문에 성능이 안떨어진다.</p>
<hr/>
<h2 id="trait">Trait<a class="headerlink" href="#trait" title="Permanent link">¶</a></h2>
<p>trait 는 특정 데이터 타입들이 공유하는 공통된 기능이다. Java 에서 interface 와 살짝 비슷한 개념이다. trait 에 선언된 함수가 trait 를 구현한 struct 에 똑같은 함수 선언으로 구현되어야 한다.</p>
<p>다른 라이브러리에 있는 trait 를 가져와서 자신이 정의한 struct 에 구현할 수도 있다. 이 경우 <code>use &lt;PACKAGE&gt;::&lt;PATH_TO_TRAIT&gt;::&lt;TRAIT&gt;;</code> 를 사용한 다음 struct 에 trait 를 구현하면 된다. </p>
<h3 id="orphan-rule-coherence">orphan rule (coherence)<a class="headerlink" href="#orphan-rule-coherence" title="Permanent link">¶</a></h3>
<p>이때 중요한 것은 trait 를 struct 에 구현할 때 trait 나 struct 중 하나는 반드시 local 패키지에 선언되어있어야 한다. 즉, 외부 패키지의 trait 를 외부 패키지의 struct 에 구현할 수 없다.</p>
<p>이 규칙이 없다면 Rust 는 같은 데이터 타입에 대한 같은 trait 를 구현한 두개 이상의 crate 를 허용하게 된다.</p>
<h3 id="default-implementation">Default Implementation<a class="headerlink" href="#default-implementation" title="Permanent link">¶</a></h3>
<p>trait 에 method 선언만 하는 것이 아니라 method 본체를 구현해 놓으면 trait 를 구현할 struct 의 Default Implementation 이 된다. Default Implementation 을 사용하고 싶다면 <code>impl &lt;TRAIT&gt; for &lt;STRUCT&gt; { }</code> 와 같이 <code>impl</code> 블록을 비어있는채로 냅두면 된다. </p>
<h3 id="trait-as-parameter">Trait as Parameter<a class="headerlink" href="#trait-as-parameter" title="Permanent link">¶</a></h3>
<p>trait 를 함수의 파라미터로 전달할 수도 있다. 이 경우 trait 를 구현한 struct 들을 대표할 수 있게 된다. <code>fn f(p: &amp;impl Trait)</code> 와 같이 사용된다. </p>
<h3 id="trait-bound">Trait Bound<a class="headerlink" href="#trait-bound" title="Permanent link">¶</a></h3>
<p><code>impl Trait</code> 는 Trait bound 의 syntax sugar 이다. trait bound 는 </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">f</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Trait</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"></span>
</code></pre></div>
<p>와 같이 사용한다. Generic 과 비슷한데 콜론을 쓰고 Trait 를 명시하면 된다.</p>
<p>하지만 차이점이 있는데, </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">Trait</span><span class="p">,</span><span class="w"> </span><span class="n">q</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"></span>
</code></pre></div>
<p>라고 하면 p 와 q 가 다른 타입이어도 되지만 </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">f</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Trait</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">q</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"></span>
</code></pre></div>
<p>라고 하면 p 와 q 가 같은 타입이어야 한다.</p>
<h3 id="multiple-trait-bound">Multiple Trait Bound<a class="headerlink" href="#multiple-trait-bound" title="Permanent link">¶</a></h3>
<p>여러 Trait 를 구현한 struct 를 파라미터로 전달하기 위해서 </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="k">impl</span><span class="w"> </span><span class="n">Trait1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="p">))</span><span class="w"></span>
</code></pre></div>
<p>이나 </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">f</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Trait1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"></span>
</code></pre></div>
<p>와 같이 하면 된다.</p>
<h3 id="where">where<a class="headerlink" href="#where" title="Permanent link">¶</a></h3>
<p>trait bound 가 많을 경우 함수 선언을 읽기가 힘들어진다. 이를 위하여 trait bound 를 함수 선언 다음에 정의할 수 있도록 <code>where</code> 문을 쓰면 된다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">f</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="n">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="kp">&amp;</span><span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> 
</code></pre></div>
<p>위 코드가 다음 코드와 동일하다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">f</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="kp">&amp;</span><span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span>
    <span class="nc">where</span><span class="w"> </span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">U</span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="n">Debug</span><span class="w"></span>
</code></pre></div>
<h3 id="return-trait">return Trait<a class="headerlink" href="#return-trait" title="Permanent link">¶</a></h3>
<p>Trait 를 반환하기 위해서 <code>fn f() -&gt; impl Trait</code> 와 같이 <code>impl Trait</code> 를 반환형으로 삼으면 된다. 하지만 함수가 반드시 하나의 타입을 반환해야 한다. 가령 <code>fn f() -&gt; impl Summary</code> 로 선언된 함수에서 조건에 따라 NewsArticle 이나 Tweet 타입이 반환되면 컴파일이 되지 않는다.</p>
<h3 id="conditionally-implement-method">conditionally implement method<a class="headerlink" href="#conditionally-implement-method" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"></span>
</code></pre></div>
<p>라고 하면 <code>ToString</code> Trait 를 <code>struct T</code> 위에 구현하는데 <code>T</code> 는 <code>Display</code> Trait 가 정의된 것이라고 해석한다. 이 선언이 <code>std</code> 에 정의되어 있으므로 <code>Display</code> Trait 가 정의된 모든 데이터 타입에 대하여 <code>to_string</code> 함수를 사용할 수 있는 것이다. </p>
<p><code>impl</code> 블록 안에서 <code>Self</code> 라고 하면 해당 타입을 지칭하게 된다. </p>
<hr/>
<h2 id="lifetime">Lifetime<a class="headerlink" href="#lifetime" title="Permanent link">¶</a></h2>
<p>Lifetime 은 Reference 가 적절한 시간동안 살아있다는 것을 보장해주는 Generic 이다. 모든 Reference 는 스코프 내에서 유효하다는 lifetime 을 갖는다. Lifetime 의 목적은 Dangling Reference 가 발생하는 것을 차단하는 것이다.</p>
<h3 id="borrow-checker">borrow checker<a class="headerlink" href="#borrow-checker" title="Permanent link">¶</a></h3>
<p>Rust 는 컴파일 시 Reference 와 대상 데이터의 lifetime 을 계산한다. 그리고 다음 조건이 충족되지 않으면 에러를 발생시킨다.</p>
<ul>
<li>Reference 의 lifetime 이 대상 데이터의 lifetime 에 포함된다.</li>
</ul>
<h3 id="generic-lifetime">Generic Lifetime<a class="headerlink" href="#generic-lifetime" title="Permanent link">¶</a></h3>
<p>다음과 같이 함수를 짜면 Lifetime 이 필요하다는 에러가 발생한다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 함수에서 <code>x</code> 와 <code>y</code> 의 값을 정확히 모르기 때문에 <code>if</code> 문이 실행될지 <code>else</code> 문이 실행될지 알 수 없다. 또한 Reference 들의 lifetime 도 알 수 없다. borrow checker 도 이 Reference 들이 항상 유효한지 알 수 없다. 왜냐하면 <code>x</code>, <code>y</code> 의 lifetime 이 반환 Reference 의 lifetime 과 어떤 관계를 갖는지 알 수 없기 때문이다. 이 에러를 해결하기 위하여 Reference 간의 관계를 정의하는 Generic Lifetime 을 추가하면 borrow checker 가 lifetime 분석을 해낼 수 있다.</p>
<p>Rust 가 이 함수에게 원하는 것은 <code>x,y</code> 와 반환 Reference 가 최소한 함수가 끝날 때 까지 살아있다는 보장이다. </p>
<h3 id="lifetime-annotation-in-function">Lifetime Annotation in Function<a class="headerlink" href="#lifetime-annotation-in-function" title="Permanent link">¶</a></h3>
<p>Lifetime annotation 은 Reference 의 수명에 영향을 끼치지 않는다. Lifetime annotation 은 단지 여러 Reference 의 lifetime 간의 관계를 설명해준다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">longest</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>기존의 <code>longest</code> 함수에 위와 같이 lifetime <code>'a</code> 를 추가함으로써 <code>x,y</code> 그리고 반환값이 최소한 lifetime <code>'a</code> 만큼 살아있음을 보장해준다. 이러면 <code>x,y</code> 와 반환 Reference 가 최소한 함수가 끝날 때 다 함께 살아있다는 보장이 되므로 드디어 컴파일이 된다.</p>
<p>이것은 실제상황에서 함수가 반환하는 Reference 의 lifetime 이 파라미터로 전달되는 Reference 의 lifetime 보다 같거나 작다는 것을 의미한다.</p>
<p>이처럼 함수에 Lifetime annotation 을 정의하는 것은 Reference 의 lifetime 에 실질적인 영향을 주지 못하지만, borrow checker 가 이 lifetime 관계를 따르지 않는 Reference 가 전달되는 것을 제한할 수 있도록 하는 역할을 한다.</p>
<p>즉, <code>x, y</code> 와 반환 Reference 가 최소한 <code>'a</code> 만큼 살아있다는 것이 보장되므로 <code>longest</code> 가 컴파일된다는 말인데, 그러면 <code>'a</code> 는 어떻게 결정되는가? 먼저 <code>x</code> 의 수명이 <code>'a</code> 로 정의되었으므로 <code>'a</code> 의 수명은 <code>x</code> 가 되는데, <code>y</code> 도 <code>'a</code> 로 정의되었으므로 <code>x</code> 와 <code>y</code> 의 겹치는 수명이 <code>'a</code> 의 값이 된다. <code>'a</code> 의 수명은 이렇게 파라미터의 Reference 의 교집합으로 결정된다. 이때 반환 Reference 도 <code>'a</code> 로 정의되었으므로 반환 Referencer 가 최소한 <code>'a</code> 만큼은 살아있다는 제한이 생긴다. 이렇게 파라미터에 의해 결정된 Lifetime annotation 을 기반으로 반환 Reference 의 수명을 보장해준다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">str1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"aaaaaaaaaaaaaaaaaaaa"</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rst</span><span class="p">;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">str2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"aaaaaaa"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">rst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longest</span><span class="p">(</span><span class="n">str1</span><span class="p">.</span><span class="n">as_str</span><span class="p">(),</span><span class="w"> </span><span class="n">str2</span><span class="p">.</span><span class="n">as_str</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">rst</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>그러므로 위와 같은 코드는 컴파일 되지 않는다. <code>str1, str2</code> 의 수명의 교집합으로 반환 Reference 의 수명이 결정되었기 때문에 반환 Reference 는 최소한 inner scope 에서 수명이 끝난다. 그런데도 <code>rst</code> 를 inner scope 바깥에서 사용하고 있기 때문에 컴파일이 되지 않는다.</p>
<p>항상 모든 파라미터에 lifetime 을 정의해야 하는 것은 아니다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">longest</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 함수는 무조건 첫번째 파라미터를 반환한다. 그래서 lifetime <code>'a</code> 를 <code>x</code> 와 반환 Reference 에만 정의해주었다. 이로써 반환 Reference 가 <code>x</code> 와 같거나 작은 수명을 갖는다는 제한이 생긴다. 이 함수에서 <code>y</code> 는 <code>x</code> 와 반환 Reference 와 아무런 관계가 없으므로 <code>'a</code> 를 정의할 필요가 없다.</p>
<p>반환 Reference 에 정의된 lifetime 은 파라미터 중 하나와 연관되어야 한다. 그렇지 않으면 반환 Reference 가 함수 내부의 데이터에 대한 Reference 가 되므로 Dangling Reference 가 된다. </p>
<p>결과적으로 lifetime 이란 파라미터의 lifetime 과 반환 Reference 의 lifetime 을 연결시키는 것이다. 파라미터와 반환 Reference 가 연결되면 Rust 는 memory-safe 연산을 이룰 수 있고 Dangling pointer 를 차단할 수 있는 충분한 정보를 얻을 수 있는 것이다. </p>
<h3 id="lifetime-annotation-in-struct">Lifetime Annotation in Struct<a class="headerlink" href="#lifetime-annotation-in-struct" title="Permanent link">¶</a></h3>
<p>Struct 는 멤버로 Reference 를 가질 수 있는데 이 경우 Reference 가 Struct 보다 일찍 죽지 않는다는 것을 보장하는 lifetime 이 정의되어야 한다. Reference 멤버가 Struct 보다 먼저 죽으면 Dangling 이 되기 때문이지.</p>
<h3 id="lifetime-elision">Lifetime Elision<a class="headerlink" href="#lifetime-elision" title="Permanent link">¶</a></h3>
<p>이제 우리는 Reference 를 사용하는 모든 Function 과 Struct 가 Reference 의 lifetime 을 정의해야 한다는 것을 알았다. 하지만 우리는 이미 다음과 같이 lifetime 이 없는데도 Reference 를 잘 사용하는 함수를 정의했었다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">bytes</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">b' '</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>사실 이 코드는 Rust 초기 버전(pre-1.0) 에서 컴파일 되지 않으며, 이때 당시 lifetime 이 명시되지 않은 모든 Reference 가 컴파일 되지 않았다. 이때 당시였다면 위 함수를 </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">first_word</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w"></span>
</code></pre></div>
<p>와 같이 정의해야만 했다. 하지만 Rust 개발진은 똑같은 패턴의 상황에서 lifetime annotation 을 똑같이 매번 써야 한다는 것을 깨달았다. 이 상황은 예측가능 하며 결정론적 패턴이 존재했다. 그래서 이 패턴을 컴파일러에 주입시켰고 borrow checker 가 이 패턴을 맞닦드리면 lifetime annotation 이 없어도 lifetime 을 추론할 수 있도록 만들었던 것이다. 이 패턴을 lifetime elision rules 이라 한다. 만약 당신의 코드가 이 패턴에 부합하면 lifetime 을 명시하지 않아도 된다.</p>
<p>파라미터 Reference 의 lifetime 을 input lifetime 이라 하고 반환 Reference 의 lifetime 을 output lifetime 이라 한다.</p>
<p>컴파일러는 3가지 규칙으로 lifetime elision rules 을 판단한다. 이 규칙은 <code>fn</code> 블록(함수 정의) 뿐 아니라 <code>impl</code> 블록에도 적용된다.</p>
<ol>
<li>
<p>(input lifetime 에 적용되는 규칙) 각각의 파라미터는 각각의 lifetime 을 갖는다. </p>
<p>가령 파라미터가 하나이면 <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code> 와 같이 하나의 lifetime 을 갖고, 파라미터가 두 개 이면 <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code> 와 같이 두 개의 lifetime 을 갖는다.</p>
</li>
<li>
<p>(output lifetime 에 적용되는 규칙) input lifetime 이 하나이면 그 lifetime 이 모든 output lifetime 에 할당된다.</p>
<p>가령 <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code> 와 같다.</p>
</li>
<li>
<p>(output lifetime 에 적용되는 규칙) input lifetime 이 여러개 있고 그 중 하나가 <code>&amp;self</code> 나 <code>&amp;mut self</code> 라면 이것은 Method 이기 때문에 <code>self</code> 의 lifetime 이 모든 output lifetime 에 할당된다.</p>
</li>
</ol>
<h3 id="lifetime-elision-example-1">Lifetime Elision Example 1<a class="headerlink" href="#lifetime-elision-example-1" title="Permanent link">¶</a></h3>
<p><code>first_word</code> 함수에 이 세 가지 규칙을 적용해보자. 먼저 함수가</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> 
</code></pre></div>
<p>와 같이 Reference 를 입력으로 받는데도 lifetime 이 명시되어 있지 않으므로 규칙 1) 을 적용하여 </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">first_word</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> 
</code></pre></div>
<p>로 만든다. input lifetime 이 하나이므로 규칙 2) 가 적용되어</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">first_word</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span> 
</code></pre></div>
<p>가 된다. 이로써 모든 Reference 가 lifetime 을 갖게 되어 프로그래머가 lifetime 을 명시하지 않아도 된다.</p>
<h3 id="lifetime-elision-example-2">Lifetime Elision Example 2<a class="headerlink" href="#lifetime-elision-example-2" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 함수를 컴파일 했을 때 실패했었고,</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">longest</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w"></span>
</code></pre></div>
<p>와 같이 lifetime 을 명시했을 때 컴파일이 성공했다. 왜 실패했는지 따져보자. 먼저 규칙 1) 을 적용하면</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">longest</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="o">'</span><span class="na">b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">b</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w"></span>
</code></pre></div>
<p>가 된다. 규칙 2) 와 규칙 3) 의 조건에 부합하지 않으므로 적용되지 않는다. 규칙 1), 2), 3) 을 모두 적용했음에도 불구하고 추론되지 않은 lifetime 이 있다. 반환 Reference 의 lifetime 이 밝혀지지 않았기 때문이다. 그러므로 컴파일에 실패한 것이다.</p>
<h3 id="lifetime-annotation-in-method">Lifetime Annotation in Method<a class="headerlink" href="#lifetime-annotation-in-method" title="Permanent link">¶</a></h3>
<p>lifetime 이 정의된 Struct 에 Method 를 구현하기 위해 먼저 <code>impl</code> 키워드 바로 다음에 lifetime 을 선언해주어야 한다. Method 의 Reference 는 Struct 의 필드로 정의된 Reference 이거나 독립적인 Reference 이다. </p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">ImportantExcerpt</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">part</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ImportantExcerpt</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">level</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="mi">3</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">announce_and_return_part</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">announcement</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Attention please: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">announcement</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">part</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>함수 이름 다음에 나타나는 lifetime annotation 은 <code>impl</code> 블록 다음에 나오는 lifetime annotation 으로 대체된다.</p>
<p><code>level</code> 에는 규칙 1) 이 적용되어 모든 Reference 의 lifetime 을 결정할 수 있다. <code>announce_and_return_part</code> 에는 규칙 1) 과 3) 이 적용되어 모든 lifetime 을 결정할 수 있다.</p>
<h3 id="static-lifetime">Static Lifetime<a class="headerlink" href="#static-lifetime" title="Permanent link">¶</a></h3>
<p>Static Lifetime 인 <code>'static</code> 가 있는 Reference 는 프로그램이 실행되는 전체 시간동안 살아있다는 것을 뜻하는 Reference 이다.</p>
<p>모든 string literal 은 <code>'static</code> 을 가진다. 따라서 </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="nb">static</span> <span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">"I have a static lifetime."</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>와 같이 정의할 수 있다.</p>
<blockquote>
<p>근데 <code>'static</code> 에 대해서 잘 이해가 안된다. 그리고 string literal 이 <code>'static</code> 이라는 것도 이해가 잘 안되고. </p>
</blockquote>
<p>에러 메시지 같은 것들에 <code>'static</code> 을 사용하고 싶을 수도 있지만, <code>'static</code> 을 사용하기 전에 Reference 가 실제로 프로그램 전체 수명 동안 살아있는지 확인해야 하고, 그것이 가능하다고 해도 당신이 Reference 가 그렇게 길게 살아있길 원하는지 고려해봐라.</p>
<h3 id="example-generictraitlifetime">Example (Generic+Trait+Lifetime)<a class="headerlink" href="#example-generictraitlifetime" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Display</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">longest_with_an_announcement</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ann</span>: <span class="nc">T</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span>
<span class="nc">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nc">Display</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Announcement! {}"</span><span class="p">,</span><span class="w"> </span><span class="n">ann</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 함수는 Generic, Trait, Lifetime 이 모두 포함된 올인원 함수이다. </p>
<hr/>
<h2 id="automated-tests">Automated Tests<a class="headerlink" href="#automated-tests" title="Permanent link">¶</a></h2>
<p>Test 는 버그가 존재한다는 것을 효과적으로 밝힐 수 있지만, 버그가 존재하지 않는다는 것을 보이는데에는 힘을 발휘하지 못한다. 하지만 이것은 우리가 Test 를 하지 않아도 된다는 것을 의미하지 않는다.</p>
<p>프로그램의 <strong>Correctness</strong> 란 코드가 <strong>우리의 의도대로 행동한다</strong> 는 것이다. Rust 는 Correctness 를 고려하며 설계했지만 이것은 복잡한 개념이었고 증명하기가 쉽지 않았다. Rust 의 타입 시스템이 Correctness 의 짐을 많이 지고 있지만 이것이 Incorrectness 를 모두 밝힐 수는 없었다. 따라서 Rust 는 Automated test 를 제공하기로 했다. </p>
<p>가령 두 숫자를 더하여 반환하는 <code>add_two</code> 함수를 만들었다고 하자. 이 함수는 Rust 의 타입 시스템과 borrow checker 로 올바른 자료형과 올바른 Reference 만을 받아들일 것이다. 하지만 Rust 는 <strong>이 함수가 정말로 우리의 의도대로 행동한다</strong> 는 것은 보장해주지 않는다. 그러므로 이 시점에서 Test 가 필요하다. </p>
<h3 id="test">Test 코드 작성<a class="headerlink" href="#test" title="Permanent link">¶</a></h3>
<p>Test 코드란 non-test 코드가 <strong>우리가 의도한 대로 행동한다</strong> 는 것을 검증하는 코드이다. Test 코드는 보통 다음 3단계로 행동한다.</p>
<ol>
<li>
<p>필요한 데이터와 상태를 준비한다. </p>
</li>
<li>
<p>non-test 코드에 대한 test 를 진행한다. </p>
</li>
<li>
<p>결과를 assert 한다. </p>
</li>
</ol>
<h3 id="test-function">Test Function<a class="headerlink" href="#test-function" title="Permanent link">¶</a></h3>
<p>Test 함수란 <code>test</code> Attribute 가 붙혀진 함수이다. Attribute 란 Rust 코드에 대한 metadata 이다. 가령 우리는 이미 </p>
<div class="highlight"><pre><span></span><code><span class="cp">#[derive(Debug)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">UsState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Alabama</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Alaska</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>와 같은 Attribute 를 사용했었다. 이와 같이 함수를 Test 함수로 만들기 위하여 <code>#[test]</code> Attribute 를 붙이면 된다. 그리고 <code>test</code> Attribute 가 붙은 함수를 실행하고 검증하기 위하여 <code>cargo test</code> 명령어를 실행하면 된다. </p>
<p><code>#[test]</code> 함수들을 모듈로 묶기 위해서는 <code>[cfg(test)]</code> Attribute 가 붙은 <code>mod</code> 에 Test 함수를 정의하면 된다. </p>
<h3 id="testing">Testing 방법<a class="headerlink" href="#testing" title="Permanent link">¶</a></h3>
<p>Test 함수에 <code>assert!</code>, <code>assert_eq!</code>, <code>assert_ne!</code> 로 non-test 코드가 의도한대로 행동하는지 확인한다. 정상적인 값이 반환되면 아무일 없이 넘어가고 비정상적인 값이 반환되면 <code>panic!</code> 을 호출하게 되는데 Test 함수는 이 <code>panic!</code> 을 catch 해서 Test 결과로 보고하는 것이다.</p>
<p><code>assert_ne!</code> 는 보통 함수의 반환값이 명확하지는 않지만 이것만큼은 분명히 아니라고 확신할 때 사용된다. </p>
<p><code>assert_eq!</code> 로 기댓값을 비교하기 위해서는 <code>PartialEq</code> Trait 가 정의되어 있어야 한다. 모든 primitive type 과 대부분의 std 가 제공하는 타입은 <code>PartialEq</code> 를 정의했지만, 당신이 만든 Struct 나 Enum 을 특정 기댓값과 assert 하고 싶다면 <code>PartialEq</code> 을 정의해야 할 것이다. 또한 assertion 이 실패했을 때 <code>Debug</code> Trait 가 정의되어 있어야지 에러 메시지를 출력할 수 있기 때문에 <code>Debug</code> Trait 도 정의해야 할 것이다.</p>
<p>그런데 <code>PartialEq</code> 와 <code>Debug</code> Trait 는 derivable traite 이기 때문에 당신이 만든 Struct 와 Enum 정의 위에 단지</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[derive(PartialEq, Debug)]</span><span class="w"></span>
</code></pre></div>
<p>를 추가하면 된다. </p>
<h3 id="custom-failure-message">Custom Failure Message<a class="headerlink" href="#custom-failure-message" title="Permanent link">¶</a></h3>
<p>assertion 진행 중 Test 가 실패하면 단지 "assertion 에 실패했다" 라는 식의 메시지밖에 볼 수 없다. 만약 Test 개수가 수백개가 넘어가면 각각의 Test 의 의미가 잘 생각나지 않을 때도 있다. 그렇기에 Test 를 만드는 시점에서 Test 가 실패했을 때 단순히 "assertion 에 실패했다" 는 메시지가 아니라 왜 Test 가 실패했고 실패한 중요한 원인이 되는 데이터를 출력해주는 것이 중요하다. </p>
<p><code>assert!</code> 두번째 파라미터에 format string 을 넣고 세번째 파라미터부터 <code>{}</code> 에 들어갈 데이터를 넣을 수 있다. 이런 식으로 Custom Failure Message 를 제작해둘 수 있다.</p>
<h3 id="panic-test">panic test<a class="headerlink" href="#panic-test" title="Permanent link">¶</a></h3>
<p>코드가 의도한대로 행동한다는 것을 Test 하는 것도 중요하지만, 비정상적인 입력을 받았을 때 <code>panic</code> 을 일으키는 것을 확인하는 것도 중요하다. 이를 위해 <code>should_panic</code> attribute 를 Test 함수에 붙이면 된다. </p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span><span class="w"></span>
<span class="cp">#[should_panic]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">test_function</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="c1">// panicable code</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>근데 non-test 코드 중에서 여러가지의 <code>panic</code> 이 있을 수 있다.  <code>should_panic</code> test 가 정확하게 우리가 원하는 <code>panic</code> 이 일어났다는 보장을 얻기 위하여 <code>should_panic</code> 의 <code>expected</code> 파라미터에 <code>panic</code> 메시지가 반드시 포함해야 할 failure message 명시할 수 있다. </p>
<h3 id="result-test">Result<t e=""> Test<a class="headerlink" href="#result-test" title="Permanent link">¶</a></t></h3>
<p>Test 함수에서 Test 에 성공했다 실패했다를 <code>panic</code> 이 일어났냐 안일어났냐로 판단한다고 했다. 하지만 이 기준을 <code>Result&lt;T, E&gt;</code> 로 바꿀 수도 있다. 다음과 같이 Test 에 성공하면 <code>Ok</code> 를 반환하고 실패하면 <code>Err</code> 를 반환하면 된다. </p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">it_works</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"two plus two does not equal four"</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="controlling-test">Controlling Test<a class="headerlink" href="#controlling-test" title="Permanent link">¶</a></h2>
<h3 id="thread-safe-test">thread-safe test<a class="headerlink" href="#thread-safe-test" title="Permanent link">¶</a></h3>
<p>Test 가 여러개면 Rust 는 default 로 멀티 스레드로 Test 함수를 검증한다. 따라서 당신은 Test 들이 서로 의존적이지 않고 공유되는 상태나 환경이 없도록 thread-safe 하게 만들어야 한다. </p>
<p>가령 파일을 만들고 내용을 작성하는 Test 들이 여러개일 경우 내용이 엉키겠지. 만약 Test 들을 thread-safe 하게 만들기가 불가능하다면 <code>cargo test -- --test=threads=1</code> 이라고 실행하면 된다.</p>
<h3 id="show-output-of-test">show output of test<a class="headerlink" href="#show-output-of-test" title="Permanent link">¶</a></h3>
<p>Rust 는 default 로 실패한 Test 의 stdout 을 보여준다. 하지만 성공한 Test 의 출력도 보고 싶다면 <code>cargo test -- --show-output</code> 이라고 하면 된다. </p>
<h3 id="running-subset-of-test">Running subset of Test<a class="headerlink" href="#running-subset-of-test" title="Permanent link">¶</a></h3>
<p>Test 가 엄청 많아지면 그것들을 매번 다 Test 하는 것이 비효율적일 때도 있다. <code>cargo test &lt;TEST FUNCTION&gt;</code> 이라고 하면 원하는 Test 함수만 test 할 수 있어.</p>
<p>하지만 여러 함수 이름을 전달할 수는 없지. 그 대신 패턴을 전달할 수 있어. 가령 <code>cargo test add</code> 라고 하면 <code>add</code> 가 포함된 Test 함수가 test 되는거야.</p>
<h3 id="ignore-some-tests">Ignore some Tests<a class="headerlink" href="#ignore-some-tests" title="Permanent link">¶</a></h3>
<p>몇몇 Test 들은 시간 소모가 매우 심하다. 이런 Tests 들을 <code>cargo test</code> 를 실행했을 때 무시하기 위하여 <code>#[ignore]</code> attribute 를 붙힐 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span><span class="w"></span>
<span class="cp">#[ignore]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">expensive_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// code that takes an hour to run</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>ignore</code> attribute 가 붙은 Test 까지 다 테스트하기 위해서는 <code>cargo test -- --ignored</code> 를 실행하면 된다. </p>
<h2 id="test-organization">Test Organization<a class="headerlink" href="#test-organization" title="Permanent link">¶</a></h2>
<p>Test 라는 개념은 커뮤니티마다 다양하게 정의된다. Rust 커뮤니티는 Test 를 크게 unit test 와 integration test 로 분류한다.</p>
<p>Unit test 란 특정 코드를 부분적으로, 독립적으로, 소규모로, private 인터페이스도 테스트하는 것이다. Integration test 란 전체 코드를, 종속적으로, 대규모로, public 인터페이스만을 사용하여 다 테스트 하는 것이다. Rust 커뮤니티는 이 두 Test 를 다 시행하는 것을 중요하게 생각한다.</p>
<h3 id="unit-test">Unit test<a class="headerlink" href="#unit-test" title="Permanent link">¶</a></h3>
<p>unit test 의 convention 은 unit test 를 <code>src</code> 디렉토리의 각각의 파일안에 정의하고, <code>tests</code> 라는 Module 에 Test 함수를 정의하는 것이다. 이 <code>tests</code> Module 에는 <code>#[cfg(test)]</code> 라는 attribute 가 정의되어야 한다. </p>
<h3 id="test-module-and-cfgtest">Test Module and #[cfg(test)]<a class="headerlink" href="#test-module-and-cfgtest" title="Permanent link">¶</a></h3>
<p><code>#[cfg(test)]</code> 는 Rust 에게 이 코드는 <code>cargo test</code> 를 실행했을 때만 컴파일하고 실행하라고 말해주는 attribute 이다. 그래서 이 attribute 는 컴파일 시간을 절약해주고 릴리즈 버전의 바이너리에 테스트 코드가 포함되지 않게 해준다. </p>
<p>Integration test 에 대해서도 살펴볼텐데 이 테스트는 non-test 코드와 같은 디렉토리에 저장되지 않기 때문에 <code>#[cfg(test)]</code> 를 쓰지 않아도 되고, Unit test 는 non-test 코드와 같은 파일에 저장되므로 <code>#[cfg(test)]</code> 가 필요하다. </p>
<p><code>#[cfg(test)]</code> 의 <code>cfg</code> 는 configuration 을 뜻하고 Rust 가 괄호 안에 있는 item 이 configuration 에 설정되도록 만든다. 이 경우 configuration 옵션에 <code>test</code> 가 추가되는 것이다. </p>
<h3 id="integration-test">Integration test<a class="headerlink" href="#integration-test" title="Permanent link">¶</a></h3>
<p>Integration test 는 당신의 라이브러리에서 완전히 외부에 선언되고, 그러므로 public API 만 사용하여 테스트를 한다. 이 Test 의 목적은 라이브러리가 잘 작동하는지 전체적으로 확인하는 것이다. 이렇게 전체 코드가 서로 잘 작동하는지 확인하는 이유는 Unit test 로 개인적으로 잘 작동하는 것이 확인된 코드들이 integrated 되었을 때 오작동을 하는 경우도 있기 때문이다.</p>
<p>Integration test 를 위하여 먼저 패키지 root 에 <code>tests</code> 라는 디렉토리를 만들어라.</p>
<h3 id="tests-directory">tests Directory<a class="headerlink" href="#tests-directory" title="Permanent link">¶</a></h3>
<p>Cargo 는 <code>tests</code> 디렉토리에 Integration test 가 존재한다는 것을 안다. Cargo 는 각각의 파일들을 독립적인 crate 로 컴파일한다. 따라서 Integration test 에 <code>#[cfg(test)]</code> 가 필요 없고 <code>use &lt;PACKAGE&gt;;</code> 선언이 필요하다.</p>
<h3 id="submodules-in-integration-test">Submodules in Integration test<a class="headerlink" href="#submodules-in-integration-test" title="Permanent link">¶</a></h3>
<p><code>tests</code> 디렉토리의 파일들이 각각 독립적인 crate 로 컴파일 되므로 대부분의 test 함수에서 공통적으로 필요한 파일들을 가령 <code>tests/common.rs</code> 에 모아둘 수 있다. 이 파일에 아래와 같이 대부분의 test 함수가 호출해야 하는 함수를 정의 했다고 하자. </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">setup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// setup code specific to your library's tests would go here</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 함수는 test 함수가 아니고 <code>tests/common.rs</code> 자체에 test 코드가 없는데도 <code>cargo test</code> 를 실행하면 <code>tests/common.rs</code> 의 test 항목이 발생한다. 이것을 피하기 위하여 <code>tests/common.rs</code> 대신 <code>tests/common/mod.rs</code> 를 만들 수 있다. 이렇게 하면 Rust 가 <code>common</code> 모듈을 Integration test 로 여기지 않게 된다. </p>
<p>일반적으로 <code>tests</code> 에서 디렉토리를 또 생성하고 그 디렉토리 밑에 파일이 생성되면 Cargo 가 그것을 non-test 코드로 여긴다. </p>
<p>이제 아래와 같이 다른 test 코드에서 <code>tests/common/mod.rs</code> 의 코드를 가져다가 쓸 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">adder</span><span class="p">;</span><span class="w"></span>

<span class="k">mod</span> <span class="nn">common</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[test]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">it_adds_two</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">common</span>::<span class="n">setup</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">adder</span>::<span class="n">add_two</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="integration-test-for-binary-crate">Integration test for Binary Crate<a class="headerlink" href="#integration-test-for-binary-crate" title="Permanent link">¶</a></h3>
<p>패키지에 <code>src/lib.rs</code> 가 없고 <code>src/main.rs</code> 만 있다면 <code>tests</code> 디렉토리에 Integration test 를 정의할 수 없다. 라이브러리 crate 만 Integration test 로 테스트할 수 있다. 이는 바이너리 crate 는 unit test 만 할 수 있다는 것이다.</p>
<p>Rust 가 <code>src/main.rs</code> 의 integration test 를 제한하는 이유는 <code>src/main.rs</code> 가 <code>src/lib.rs</code> 에 있는 코드를 호출하는 적은 양의 코드만을 지니고 있다고 가정하기 때문이다. 중요한 코드와 로직은 모두 라이브러리 crate 에 정의되어 있으므로 라이브러리 crate 의 Integration test 가 된다면 <code>src/main.rs</code> 의 Integration test 는 불필요하다는 것이다. </p>
<blockquote>
<p>근데 그래도 굳이 제한을 했어야 했을까? 그럴 필요까지는 없었는데 Rust 커뮤니티가 원한 것은 Rust 개발자가 <code>src/main.rs</code> 에는 오로지 Drive 코드만 넣고 중요한 로직과 기능은 <code>src/lib.rs</code> 에 넣는 것이라고 생각된다. 그래서 그것을 강제한 것이지.</p>
</blockquote>
<hr/>
<h2 id="derive-attribute">derive attribute<a class="headerlink" href="#derive-attribute" title="Permanent link">¶</a></h2>
<p>어떤 Struct 나 Enum 에 <code>derive</code> attribute 가 추가되면 trait 의 default implementation 이 해당 데이터 타입에 추가된다. </p>
<hr/>
<h2 id="io-project">I/O Project<a class="headerlink" href="#io-project" title="Permanent link">¶</a></h2>
<p><code>grep</code> 프로그램을 만들어보자.  </p>
<h3 id="first-try">First Try<a class="headerlink" href="#first-try" title="Permanent link">¶</a></h3>
<p>초안은 다음과 같다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Search: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">query</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"In file: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">"Something went worng reading the file"</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"With text:</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 초안에는 다음과 같은 문제가 있다. </p>
<ol>
<li>
<p>한 함수가 parse 를 하고 read 를 하는 등 2가지 기능을 한다. 이렇게 다양한 기능을 한 함수에 넣으면 테스트와 수정이 점점 더 힘들어진다.</p>
</li>
<li>
<p><code>query</code> 와 <code>filename</code> 이 configuration variable 로 저장되었다. 변수가 많아질수록 각각의 변수들의 목적이 기억나지 않을 것이다. 이를 위해 configuration variable 을 하나의 Struct 로 묶자. 일반적으로 함께 쓰이는 변수들은 다 Struct 로 묶어야 한다.</p>
</li>
<li>
<p>파일을 읽을 때 <code>expect</code> 로 하나의 에러 메시지를 출력해주지만, 파일 읽기에서 발생할 수 있는 에러는 매우 다양하다. 그래서 사용자에게 충분한 정보를 줄 수 없다.</p>
</li>
<li>
<p><code>expect</code> 로 에러를 처리하지만 모든 에러 핸들링 코드가 한 장소에 정의되었다면 관리하기가 훨씬 편하다.</p>
</li>
</ol>
<h3 id="separation-of-concerns">Separation of Concerns<a class="headerlink" href="#separation-of-concerns" title="Permanent link">¶</a></h3>
<p><code>main</code> 함수에 여러 기능을 집어넣는 일이 흔해지자 Rust 커뮤니티는 <code>main</code> 함수의 모듈성을 위하여 다음과 같은 가이드라인을 만들었다. </p>
<ul>
<li>
<p>프로그램을 <code>main.rs</code> 와 <code>lib.rs</code> 로 분리하되 프로그램의 로직은 모두 <code>lib.rs</code> 에 넣어라. </p>
</li>
<li>
<p>CLI 파싱 로직이 간단하다면 <code>main.rs</code> 에 있어도 된다. </p>
</li>
<li>
<p>CLI 파싱 로직이 복잡해지면 <code>main.rs</code> 에서 분리하여 <code>lib.rs</code> 에 넣어라.</p>
</li>
</ul>
<p>이 과정이 끝나면 <code>main</code> 함수가 할 일은 다음과 같이 축약된다. </p>
<ul>
<li>
<p>CLI 파싱 로직을 호출한다. </p>
</li>
<li>
<p>configuration 을 setup 한다.</p>
</li>
<li>
<p><code>lib.rs</code> 의 <code>run</code> 함수를 호출한다. </p>
</li>
<li>
<p><code>run</code> 이 에러를 반환하면 에러를 처리한다. </p>
</li>
</ul>
<p>이 패턴은 <code>main.rs</code> 가 프로그램의 실행을 관리하고, <code>lib.rs</code> 가 프로그램의 로직을 관리한다는 철학을 기반으로 만들어졌다. </p>
<h3 id="extracting-the-argument-parser">Extracting the Argument Parser<a class="headerlink" href="#extracting-the-argument-parser" title="Permanent link">¶</a></h3>
<p>그러면 먼저 CLI 파싱 로직을 다음과 같이 분리하자.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_config</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse_config</span><span class="p">(</span><span class="n">args</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="nb">String</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="grouping-values">Grouping Values<a class="headerlink" href="#grouping-values" title="Permanent link">¶</a></h3>
<p>이제 configuration value 를 다음과 같이 그룹핑해보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_config</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Searching for {}"</span><span class="p">,</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">query</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"In file {}"</span><span class="p">,</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">filename</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">query</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">filename</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse_config</span><span class="p">(</span><span class="n">args</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="nb">String</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>Config</code> 에 String 을 Clone 하여 Ownership 을 부여하고 있는데 다른 다양한 방법으로 더 효율적으로 String 을 다룰 수 있다. Clone 은 런타임 비용이 많이 들어가기 때문에 최적화가 필요한 프로그램에서 사용되지 않는다. 지금은 아주 작은 프로그램이므로 Clone 을 사용해도 상관없다.</p>
<p>효율적이 방법에 대해서는 챕터 13 의 "함수형 언어: Iterator 와 Closure" 에서 더 다뤄본다. </p>
<h3 id="creating-constructor-for-config">Creating constructor for Config<a class="headerlink" href="#creating-constructor-for-config" title="Permanent link">¶</a></h3>
<p><code>parse_config</code> 함수의 목적은 <code>Config</code> 인스턴스를 생성하는 것이었다. 이 함수를 좀 더 Rustacean 하게 만들기 위하여, 그리고 다른 곳에서 매번 인스턴스를 생성하는 함수를 만들어야 하는 것을 방지하기 위하여, <code>Config::new</code> 라는 Method 를 다음과 같이 만들자. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Config</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// --snip--</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="nb">String</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="improving-error-handling">Improving Error Handling<a class="headerlink" href="#improving-error-handling" title="Permanent link">¶</a></h3>
<p><code>new</code> 함수에서 에러가 발생하면 단지 <code>index out of bounds: the len is 1 but the index is 1</code> 라는 메시지만 나오는데 이는 별 도움이 안된다. 그러니까 다음과 같이 에러 메시지를 상황에 따라 구체화시켜주자.</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// --snip--</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="nb">String</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="s">"not enough arguments"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">// --snip--</span>
</code></pre></div>
<h3 id="returning-a-result-from-new-instead-of-calling-panic">Returning a Result from new Instead of Calling panic!<a class="headerlink" href="#returning-a-result-from-new-instead-of-calling-panic" title="Permanent link">¶</a></h3>
<p>하지만 위와 같이 <code>panic</code> 시켜버리는 것은 caller 에게 에러를 처리할 기회 주지 않는 것이다. 그러니까 다음과 같이 <code>Result&lt;T, E&gt;</code> 를 반환하여 Error propagating 을 해주자. </p>
<div class="highlight"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="nb">String</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">"not enough arguments"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="calling-confignew-and-handling-errors">Calling Config::new and Handling Errors<a class="headerlink" href="#calling-confignew-and-handling-errors" title="Permanent link">¶</a></h3>
<p>그러면 <code>main</code> 에서 에러를 처리할 기회를 얻고, 에러 코드로 프로세스를 종료시켜주는 등 사용자에게 더 많은 정보를 제공해줄 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">process</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Config</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">).</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Problem parsing arguments: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="c1">// --snip--</span>
</code></pre></div>
<h3 id="extracting-logic-from-main">Extracting Logic from main<a class="headerlink" href="#extracting-logic-from-main" title="Permanent link">¶</a></h3>
<p>이제 CLI 파싱 로직을 고쳐보았으니 configuration 세팅과 error 핸들링을 제외한 <code>main</code> 함수의 로직을 <code>run</code> 함수로 옮기자. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Config</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">).</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Problem parsing arguments: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="n">run</span><span class="p">(</span><span class="n">config</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">"Something went wrong reading the file"</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"With text:</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="returning-errors-from-the-run-function">Returning Errors from the run Function<a class="headerlink" href="#returning-errors-from-the-run-function" title="Permanent link">¶</a></h3>
<p>이제 <code>run</code> 또한 error propagating 을 하게 만들어서 <code>main</code> 이 <code>run</code> 의 에러를 처리할 수 있도록 하자.</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="c1">// --snip--</span>

<span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"With text:</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Error 타입으로 <code>Box&lt;dyn Error&gt;</code> 라는 trait object 를 반환하고 있는데 이는 챕터 17 의 OOP 에서 배우게 될 것이다. 지금은 이것이 단지 <code>Error</code> trait 를 구현한 타입이라고 이해하면 된다. </p>
<p>즉 특정 데이터 타입을 명시해주지 않겠다는 것인데 이로써 여러 에러 타입을 일반적으로 다룰 수 있게 된다. <code>dyn</code> 키워드는 dynamic 의 줄임말이다.</p>
<p>그리고 <code>expect</code> 를 <code>?</code> 로 바꿔주었다. 성공시에는 그냥 <code>Ok(())</code> 를 반환하는데 이는 unit type <code>()</code> 를 <code>Ok</code> 타입으로 wrap 한 것이다. 이는 <code>run</code> 함수를 side effect 를 위하여 호출하는 것이고, 반환값이 필요하지 않는다는 것을 뜻한다.  </p>
<h3 id="handling-errors-returned-from-run-in-main">Handling Errors Returned from run in main<a class="headerlink" href="#handling-errors-returned-from-run-in-main" title="Permanent link">¶</a></h3>
<p>이제 다음과 같이 <code>run</code> 이 반환하는 <code>Result&lt;T, E&gt;</code> 를 <code>main</code> 에서 처리해줄 차례이다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Application error: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>unwrap_or_else</code> 가 아닌 <code>if let</code> 을 사용하는 것은 반환값이 없으니까 <code>match</code> 의 경우 중 <code>Err</code> 의 경우만 처리해주겠다는 것이다. </p>
<h3 id="splitting-code-into-a-library-crate">Splitting Code into a Library Crate<a class="headerlink" href="#splitting-code-into-a-library-crate" title="Permanent link">¶</a></h3>
<p>이제 다음과 같은 로직을 다루는 코드를 <code>src/lib.rs</code> 로 옮길 차례이다.</p>
<ul>
<li>
<p><code>run</code> 함수</p>
</li>
<li>
<p>관련 <code>use</code> 선언</p>
</li>
<li>
<p><code>Config</code> Struct</p>
</li>
<li>
<p><code>Config</code> Struct 의 Method(<code>Config::new</code>)</p>
</li>
</ul>
<p>다음과 같이 <code>src/lib.rs</code> 로 로직 코드를 옮겼고 외부에서 사용할 수 있도록 <code>pub</code> 키워드도 추가해준다.</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">query</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">filename</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="nb">String</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// --snip--</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이제 이 코드를 <code>src/main.rs</code> 에 가져와서 사용하자. </p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">process</span><span class="p">;</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">minigrep</span>::<span class="n">Config</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">minigrep</span>::<span class="n">run</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// --snip--</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="developing-the-librarys-functionality-with-test-driven-development">Developing the Library’s Functionality with Test-Driven Development<a class="headerlink" href="#developing-the-librarys-functionality-with-test-driven-development" title="Permanent link">¶</a></h2>
<p>전체적인 코드 작성은 끝났다. 이제 할 일은 TDD 를 통해 라이브러리를 테스트하며 확장하는 것이다. TDD 는 다음과 같이 이루어진다. </p>
<ol>
<li>
<p>실패하는 Test 를 작성하여 당신의 의도대로 프로그램이 실패하는지 확인하라.</p>
</li>
<li>
<p>Test 를 패스하는 코드를 작성하라.</p>
</li>
<li>
<p>그 Test 가 통과하는지 확인하라. </p>
</li>
<li>
<p>1단계부터 다시 반복하라.</p>
</li>
</ol>
<p>이 과정은 소프트웨어를 만드는 방법론 중 하나이지만, TDD 는 안정성있는 코드를 만들 수 있도록 도와준다. 우리는 이 TDD 를 통해 최종적으로 <code>search</code> 함수를 만들 것이다.</p>
<h3 id="1-failing-test">1) Failing Test<a class="headerlink" href="#1-failing-test" title="Permanent link">¶</a></h3>
<p><code>tests</code> Module 안에 Test 함수를 먼저 짜고 우리가 원하는 <code>search</code> 함수의 행동의 예시를 명시한다. </p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">one_result</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"duct"</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"\</span>
<span class="s">Rust:</span>
<span class="s">safe, fast, productive.</span>
<span class="s">Pick three."</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="s">"safe, fast, productive."</span><span class="p">],</span><span class="w"> </span><span class="n">search</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 Test 함수는 <code>search</code> 함수가 <code>"duct"</code> 을 찾고 이것을 포함하는 라인들을 반환하는 것을 명시한다. 하지만 아직 <code>search</code> 함수의 정의조차 없기에 컴파일도 할 수 없다.</p>
<p>그러니 일단 컴파일이 되도록 <code>search</code> 함수를 정의해준다.</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">search</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">query</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">vec!</span><span class="p">[]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>여기서 Lifetime <code>'a</code> 를 사용했는데 Lifetime 은 파라미터의 lifetimei 과 반환 lifetime 을 연결해준다고 했었다. 이 경우 반환되는 벡터가 포함하는 String slice 가 <code>contents</code> 파라미터의 referencing slice 이므로 같은 Lifetime 으로 연결해줬다. </p>
<p>이는 Rust 에게 <code>search</code> 함수가 반환하는 데이터가 <code>search</code> 함수로 들어오는 <code>contents</code> 라는 데이터만큼 살아 있음을 보장해준다. Lifetime 을 뺀다면 Rust 가 lifetime elision 을 해도 Lifetime 을 유추할 수 없어서 컴파일 에러가 발생한다. </p>
<h3 id="2-writing-code-to-pass-the-test">2) Writing Code to Pass the Test<a class="headerlink" href="#2-writing-code-to-pass-the-test" title="Permanent link">¶</a></h3>
<p>1) 단계의 Test 함수는 실패한다. 이제 <code>search</code> 함수를 고쳐서 Test 에 통과하도록 만들자.</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">search</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">query</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">query</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">results</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">results</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>lines</code> 함수를 사용하여 라인을 반환해주는 Iterator 를 생성하고 <code>query</code> 가 있는지 확인하여 있으면 리스트에 추가해주면 끝난다. Iterator 에 대해서 챕터 13 함수형 언어에서 다룬다. </p>
<p>이렇게 짜면 테스트에 통과한다. </p>
<h3 id="using-the-search-function-in-the-run-function">Using the search Function in the run Function<a class="headerlink" href="#using-the-search-function-in-the-run-function" title="Permanent link">¶</a></h3>
<p>이렇게 TDD 로 <code>search</code> 함수를 만들어보았다. 그러면 <code>search</code> 를 <code>run</code> 에 포함시키자. </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">.</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">contents</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이로써 grep 프로그램을 minimal 하게 만들어보았다. 이렇게 minigrep 프로젝트는 완성을 했지만 환경변수 사용과 에러 스트림 출력 기능이 추가되면 더 개선시킬 수 있다.</p>
<h2 id="working-with-environment-variables">Working with Environment Variables<a class="headerlink" href="#working-with-environment-variables" title="Permanent link">¶</a></h2>
<p>minigrep 프로그램을 사용할 때 옵션을 유저가 지정하게 할 수도 있지만 환경변수로 저장하게 하면 더 편하게 사용할 수 있다. </p>
<p>여기에서는 간단하게 case-insensitive 옵션을 환경변수로 지정하는 방법을 살펴보자. </p>
<p>이를 위하여 먼저 TDD 로 <code>search_case_insensitive</code> 함수를 만들자.</p>
<h3 id="1">1) 테스트 함수 작성<a class="headerlink" href="#1" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">case_sensitive</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// --snip--</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">case_insensitive</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"rUsT"</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"\</span>
<span class="s">Rust:</span>
<span class="s">safe, fast, productive.</span>
<span class="s">Pick three.</span>
<span class="s">Trust me."</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="fm">vec!</span><span class="p">[</span><span class="s">"Rust:"</span><span class="p">,</span><span class="w"> </span><span class="s">"Trust me."</span><span class="p">],</span><span class="w"></span>
<span class="w">            </span><span class="n">search_case_insensitive</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="2">2) 테스트에 통과하도록 코드 구현<a class="headerlink" href="#2" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">search_case_insensitive</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">query</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">contents</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">query</span><span class="p">.</span><span class="n">to_lowercase</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">to_lowercase</span><span class="p">().</span><span class="n">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">query</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">results</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">results</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>일단 <code>to_lowercase</code> 함수로 <code>query</code> 를 소문자로 만든다. 이때 <code>query</code> 는 <code>&amp;str</code> 에서 <code>String</code> 이 된다. <code>to_lowercase</code> 함수는 Reference 가 아닌 아예 새로운 데이터를 만들기 때문이다. </p>
<p>그리고 <code>line</code> 에 <code>query</code> 가 있는지 체크하기 전에 <code>to_lowercase</code> 로 소문자로 만든 후 체크한다.</p>
<h3 id="3-run">3) 구현 코드를 <code>run</code> 에 추가<a class="headerlink" href="#3-run" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">query</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">filename</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">case_sensitive</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// --snip--</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">case_sensitive</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">.</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">contents</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">search_case_insensitive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">.</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">contents</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>Config</code> Struct 에 <code>case_sensitive</code> 변수를 추가하여 구분하도록 한다. </p>
<h3 id="_3">환경변수<a class="headerlink" href="#_3" title="Permanent link">¶</a></h3>
<p>이렇게 TDD 로 <code>search_case_insensitive</code> 를 만들어 보았다. </p>
<p>이제 환경변수로써 <code>case_sensitive</code> 를 설정할 수 있도록 만들자. </p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span><span class="p">;</span><span class="w"></span>
<span class="c1">// --snip--</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="nb">String</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">"not enough arguments"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">case_sensitive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">var</span><span class="p">(</span><span class="s">"CASE_INSENSITIVE"</span><span class="p">).</span><span class="n">is_err</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">query</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">case_sensitive</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>env::var</code> 로 환경변수의 값을 가져올 수 있다. 환경변수가 세팅되어 있으면 <code>env::var</code> 함수는 <code>Ok</code> 를 반환하고 아니면 <code>Err</code> 를 반환한다. <code>is_err</code> 함수는 <code>Ok</code> 라면 <code>true</code> 를, <code>Err</code> 라면 <code>false</code> 를 반환한다.</p>
<p>PowerShell 에서는 </p>
<div class="highlight"><pre><span></span><code><span class="n">PS</span><span class="p">&gt;</span> <span class="nv">$Env:CASE_INSENSITIVE</span><span class="p">=</span><span class="n">1</span><span class="p">;</span> <span class="n">cargo</span> <span class="n">run</span> <span class="n">to</span> <span class="n">poem</span><span class="p">.</span><span class="n">txt</span>
</code></pre></div>
<p>로 실행할 수 있고 bash-like 에서는 </p>
<div class="highlight"><pre><span></span><code>$ <span class="nv">CASE_INSENSITIVE</span><span class="o">=</span><span class="m">1</span> cargo run to poem.txt
</code></pre></div>
<p>로 실행할 수 있다. </p>
<h2 id="_4">표준 에러 스트림<a class="headerlink" href="#_4" title="Permanent link">¶</a></h2>
<p>stdout 과 stderr 를 구분하여 에러들은 stderr 로 출력하는 것은 사용자가 에러 메시지를 구분하기 쉽게 해준다. </p>
<p>minigrep 에서 에러 메시지들은 모두 stderr 로 출력해주자. Rust 표준 라이브러리는 <code>eprintln!</code> 매크로를 제공하여 에러 스트림으로 출력할 수 있게 해준다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Config</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">).</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">"Problem parsing arguments: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">minigrep</span>::<span class="n">run</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">"Application error: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
</code></pre></div>
<hr/>
<h2 id="functional-language-features-iterators-and-closures">Functional Language Features: Iterators and Closures<a class="headerlink" href="#functional-language-features-iterators-and-closures" title="Permanent link">¶</a></h2>
<p>이 장에서 다음과 같은 Rust 의 함수형 언어 특징을 살펴본다.</p>
<ul>
<li>
<p>Closures</p>
</li>
<li>
<p>Iterators</p>
</li>
</ul>
<p>이 두 특징으로 minigrep 을 개선시켜볼 것이다. 마지막으로 이 두 특징의 성능을 벤치마킹해볼 거야.</p>
<h2 id="closures">Closures<a class="headerlink" href="#closures" title="Permanent link">¶</a></h2>
<p>Rust 의 Closure 는 변수나 파라미터로 다른 함수에 전달 할 수 있는 anonymous function 이다. Closure 는 Function 과 달리 그것이 정의된 scope 의 변수를 사용할 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">simulated_expensive_calculation</span><span class="p">(</span><span class="n">intensity</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"calculating slowly..."</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">intensity</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">generate_workout</span><span class="p">(</span><span class="n">intensity</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">random_number</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="s">"Today, do {} pushups!"</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">simulated_expensive_calculation</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="s">"Next, do {} situps!"</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">simulated_expensive_calculation</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">random_number</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Take a break today! Remember to stay hydrated!"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="s">"Today, run for {} minutes!"</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">simulated_expensive_calculation</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>generate_workout</code> 함수는 <code>simulated_expensive_calculation</code> 함수를 여러번 호출하고 있다. 이 코드를 추상화시켜보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">generate_workout</span><span class="p">(</span><span class="n">intensity</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">random_number</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">expensive_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">simulated_expensive_calculation</span><span class="p">(</span><span class="n">intensity</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Today, do {} pushups!"</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Next, do {} situps!"</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">random_number</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Take a break today! Remember to stay hydrated!"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Today, run for {} minutes!"</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>먼저 위와 같이 <code>simulated_expensive_calculation</code> 함수가 여러번 호출되는 것을 추출하여 하나의 변수에 저장해두는 방법이 있다. 하지만 세 번째 <code>if</code> 문에서는 이 결과값이 필요 없다. </p>
<p><code>simulated_expensive_calculation</code> 의 결과값을 변수에 저장해두는 대신 Closure 에 <code>simulated_expensive_calculation</code> 함수 전체를 저장해줄 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">expensive_closure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">num</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"calculating slowly..."</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">num</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<p>Closure 는 위와 같이 <code>=</code> 다음부터 정의되어 파이프 <code>|</code> 의 쌍으로 시작한다. 이 안에 파라미터를 정의하게 되는데, 위의 경우 <code>num</code> 이라는 파라미터가 있다. </p>
<p>만약 Closure 의 로직이 단일 expression 이라면 중괄호 <code>{ }</code> 가 필요없지만 여러 statement 들이 필요하면 <code>{ }</code> 로 묶어 줄 수 있다. 이를 기반으로 다음과 같이 코드를 고쳐보자.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">generate_workout</span><span class="p">(</span><span class="n">intensity</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">random_number</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">expensive_closure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">num</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"calculating slowly..."</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">num</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Today, do {} pushups!"</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_closure</span><span class="p">(</span><span class="n">intensity</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Next, do {} situps!"</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_closure</span><span class="p">(</span><span class="n">intensity</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">random_number</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Take a break today! Remember to stay hydrated!"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="s">"Today, run for {} minutes!"</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">expensive_closure</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>하지만 이렇게 하면 여전히 첫번째 <code>if</code> 문에서 Closure 를 여러번 호출하게 된다. 우리는 이 문제를 그냥 <code>if</code> 블록에서 변수를 하나 선언하여 Closure 의 결과값을 저장하는 것으로 해결하자. </p>
<h3 id="closure-type-inference-and-annotation">Closure Type Inference and Annotation<a class="headerlink" href="#closure-type-inference-and-annotation" title="Permanent link">¶</a></h3>
<p>Closure 는 Function 과 달리 명시적인 파라미터 데이터 타입 선언이 없다. 이는 Function 이 외부 인터페이스를 가지므로 모든 사용자가 파라미터 데이터 타입에 대한 합의를 해야 하는 것과 달리 Closure 는 외부 인터페이스를 제공하지 않기 때문이다. </p>
<p>즉, Closure 는 Function 과 달리 내부 인터페이스에서 사용되고 Function 이 일반적인 맥락에서 사용되는 것과 달리 Closure 는 국소적인 맥락에서 사용된다. </p>
<p>따라서 rustc 가 Closure 의 파라미터 데이터 타입을 쉽게 유추할 수 있으므로 Rust 는 개발자에게 Closure 의 파라미터 데이터 타입을 항상 명시하도록 하는 것은 비효율적이라고 결론을 내렸다. </p>
<p>그러나 물론 Closure 의 파라미터와 반환형에 데이터 타입을 선언하는 것이 금지되는 것은 아니다. 다음과 같이 할 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">expensive_closure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">num</span>: <span class="kt">u32</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"calculating slowly..."</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">num</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<p>다음 네 가지 코드는 모두 같은 기능을 한다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span>  <span class="nf">add_one_v1</span><span class="w">   </span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">add_one_v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span>: <span class="kt">u32</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">add_one_v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">add_one_v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w">               </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>하지만 rustc 는 Closure 의 파라미터와 반환 타입을 반드시 한 데이터 타입으로 유추한다. 가령 다음의 코드는 에러가 발생하는데 Closure 의 <code>x</code> 의 타입이 <code>String</code> 으로 유추되었는데 <code>5</code> 가 전달되었기 때문이다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">example_closure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_closure</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_closure</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<h3 id="storing-closures-using-generic-parameters-and-the-fn-traits">Storing Closures Using Generic Parameters and the Fn Traits<a class="headerlink" href="#storing-closures-using-generic-parameters-and-the-fn-traits" title="Permanent link">¶</a></h3>
<p>이제 처음의 예시로 다시 되돌아가보면, 시간이 많이 필요한 연산 결과를 <code>if</code> 블록 앞에 저장해두는 방법도 있었고, 꼭 필요할 때만 연산하는 방법도 있었다. 하지만 다른 곳에서 해당 연산이 또 필요하다면 Closure 를 다시 호출해야 한다. </p>
<p>이 문제를 해결하기 위해 Closure 를 멤버로 갖는 Struct 를 만들고 이 Struct 가 Closure 의 결과값도 저장하게 할 수 있다. 즉, 이 Struct 는 Closure 가 필요할 때만 호출하고 이미 호출되었다면 Caching 된 결과값을 반환만 해준다는 것이다.(memoization or lazy evaluation)</p>
<p>Struct 에 Closure 를 만들기 위해서는 Closure 의 데이터 타입이 명시되어야 한다. 이때 각각의 Struct 인스턴스의 Closure 인스턴스는 설령 같은 signature 를 갖고 있더라도 서로 구별되는 유일한 타입이 된다. </p>
<p>모든 Closure 는 <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code> Trait 중 최소한 하나를 구현한다. <code>Fn</code> Trait 를 사용하는 Closure 를 갖는 Struct 예시를 들어보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Cacher</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nb">Fn</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">calculation</span>: <span class="nc">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Trait bound <code>T</code> 는 파라미터로 <code>u32</code> 를 받고 <code>u32</code> 를 반환하는, <code>Fn</code> trait 를 사용하는 Closure 이다. </p>
<blockquote>
<p>근데 Closure 를 Struct 멤버로 갖는 거랑 Trait 를 Method 로 구현한 Struct 랑 무슨 차이지.</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cacher</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nb">Fn</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">calculation</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cacher</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Cacher</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">calculation</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">value</span>: <span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">value</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">calculation</span><span class="p">)(</span><span class="n">arg</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">v</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 Struct 를 바탕으로 위와 같이 <code>new</code> Method 와 <code>value</code> Method 를 정의하여 Closure 가 한번만 실행되게끔 만든다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">generate_workout</span><span class="p">(</span><span class="n">intensity</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">random_number</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">expensive_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cacher</span>::<span class="n">new</span><span class="p">(</span><span class="o">|</span><span class="n">num</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"calculating slowly..."</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">num</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Today, do {} pushups!"</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">intensity</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Next, do {} situps!"</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">intensity</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">random_number</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Take a break today! Remember to stay hydrated!"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="s">"Today, run for {} minutes!"</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">expensive_result</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이를 기반으로 위와 같이 Closure 를 변수에 저장하는 것이 아니라 Struct 를 변수에 저장하여 Caching 기법으로 Closure 가 여러번 실행되는 것을 방지할 수 있다. </p>
<h3 id="limitations-of-the-cacher-implementation">Limitations of the Cacher Implementation<a class="headerlink" href="#limitations-of-the-cacher-implementation" title="Permanent link">¶</a></h3>
<p>하지만 위와 같이 Cacher 를 구현하면 한번 저장된 데이터가 절대로 바뀌지 않는다는 단점이 있다. 그러므로 <code>value</code> 필드를 단일 값이 아니라 arg 를 키로 갖는 hash map 으로 정의할 수도 있다. </p>
<p>또 다른 문제는 위의 Cacher 는 오직 <code>u32</code> 타입만 받고 반환한다는 것이다. 이를 해결하기 위해서는 Cacher 에 Generic 을 적용해야 한다. </p>
<p>hash map 과 Generic 를 적용한 코드는 Official Documentation 에 없어서 다음과 같이 만들어보았다. </p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">hash</span>::<span class="n">Hash</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Cacher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nb">Fn</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">U</span>: <span class="nb">Copy</span> <span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Eq</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">calculation</span>: <span class="nc">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cacher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nb">Fn</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">U</span>: <span class="nb">Copy</span> <span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Eq</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">calculation</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cacher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Cacher</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">calculation</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">value</span>: <span class="nc">HashMap</span>::<span class="n">new</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">value</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">calculation</span><span class="p">)(</span><span class="n">arg</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">v</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[test]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">generate_workout</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">expensive_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cacher</span>::<span class="n">new</span><span class="p">(</span><span class="o">|</span><span class="n">num</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Executing Closure"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">num</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{} =&gt; {}"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{} =&gt; {}"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{} =&gt; {}"</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{} =&gt; {}"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{} =&gt; {}"</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{} =&gt; {}"</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">expensive_result</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="capturing-the-environment-with-closures">Capturing the Environment with Closures<a class="headerlink" href="#capturing-the-environment-with-closures" title="Permanent link">¶</a></h3>
<p>지금까지 Closure 를 inline anonymous 함수처럼 사용해왔지만 Closure 는 함수에는 없는 기능을 갖고 있다. Closure 는 자신이 정의된 scope 에 있는 변수를 Capture 하여 접근할 수 있다. </p>
<p>Closure 는 scope 의 변수들을 Capture 할 때 그것들을 저장하기 위하여 메모리를 사용한다. 하지만 이 메모리 사용은 우리가 scope 에 있는 변수들을 사용하지 않을 때 오버헤드가 된다. 그에비해 Inner Function 은 scope 의 변수들을 Capture 하지 않기 때문에 이런 오버헤드가 발생하지 않는다. </p>
<p>Closure 는 세 가지 방식으로 Capture 를 한다. 1) taking ownership, 2) borrowing mutably, 3) borrowing immutably 이 세 가지 방식은 다음과 같은 trait 로 인코딩 되었다. </p>
<ol>
<li>
<p><code>FnOnce</code> Trait : scope 의 변수들의 Ownership 을 가져와서 Closure 로 Move 한다. Once 라는 말은 같은 변수의 Ownership 을 두 번이상 가져올 수 없기 때문이다. </p>
</li>
<li>
<p><code>FnMut</code> Trait : scope 의 변수들의 Reference 를 mutably 하게 가져온다.</p>
</li>
<li>
<p><code>Fn</code> Trait : scope 의 변수들의 Reference 를 immutably 하게 가져온다.</p>
</li>
</ol>
<p>당신이 Closure 를 사용하면 Rust 가 어떤 Trait 가 사용되어야 한지 infer 해준다.</p>
<p>만약 Closure 가 변수의 Ownership 을 강제로 가져오게 하고 싶다면 Closure 정의 앞에 <code>move</code> 키워드를 넣으면 된다. 이 기법은 thread 에서 많이 사용되는데, Closure 를 새로운 thread 에 보낼 때 데이터를 Move 시킴으로써 새로운 thread 가 owner 가 되게 할 수 있기 때문이다. </p>
<p><code>move</code> Closure 도 <code>Fn</code>, <code>FnMut</code> 를 구현한다. 왜냐하면 세가지 Fn Trait 들은 Closure 가 무엇을 Capture 할지 정하는 것이고, 어떻게 Capture 할지 정하는 것은 아니기 때문이다. <code>move</code> 키워드란 어떻게 Capture 할지 정하는 것이다. </p>
<h2 id="iterator">Iterator<a class="headerlink" href="#iterator" title="Permanent link">¶</a></h2>
<p>Iterator 는 sequence 데이터에 차례로 어떤 작업을 할 수 있도록 해준다. </p>
<p>Rust 의 Iterator 는 lazy 하다. 이는 Iterator 를 사용하는 Method 를 호출하기 전까지 sequence 데이터에 아무런 영향이 없다는 것이다. 가령 다음과 같이 <code>Vec::iter</code> 로 Iterator 를 만드는 것 자체는 아무런 일도 하지 않는다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">v1_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span><span class="w"></span>
</code></pre></div>
<p>Iterator 를 만들면 다양하게 사용할 수 있다. 대표적으로 <code>for</code> 루프에서 사용하지.</p>
<h3 id="iterator-trait">Iterator Trait<a class="headerlink" href="#iterator-trait" title="Permanent link">¶</a></h3>
<p>모든 Iterator 는 <code>Iterator</code> Trait 를 구현한다. 이 Trait 는 다음과 같이 정의되어 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>type Item</code> 과 <code>Self::Item</code> 문법에 대해서는 챕터 19 에서 다룬다. 어쨌든 Iterator 는 오직 <code>next</code> Method 만 구현하면 된다는 것이다. 이 <code>next</code> 는 호출될때마다 Iterator 의 아이템 중 하나를 <code>Some</code> 으로 wrap 해서 반환하고 iteration 이 끝나면 <code>None</code> 을 반환한다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v1_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span><span class="w"></span>

<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v1_iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v1_iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v1_iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v1_iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>위 코드에서 <code>next</code> 가 반환하는 것은 vector 의 immutable reference 이다. <code>iter</code> 가 immutable reference 로 구성된 Iterator 를 생성하기 때문이다. 만약 데이터의 Ownership 을 갖는 Iterator 를 만들고 싶다면 <code>into_iter</code> 를 호출하면 된다. 만약 mutable reference 로 구성된 Iterator 를 생성하고 싶다면 <code>iter_mut</code> 를 호출하면 된다.</p>
<h3 id="methods-that-consume-the-iterator">Methods that Consume the Iterator<a class="headerlink" href="#methods-that-consume-the-iterator" title="Permanent link">¶</a></h3>
<p>Iterator 자체를 소모하는 Method 들을 consuming adaptor 라고 한다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">iterator_sum</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">v1_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">total</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">v1_iter</span><span class="p">.</span><span class="n">sum</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">total</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>가령 위에서 <code>sum</code> 은 Iterator 의 Ownership 을 받아서 Sum 연산을 수행한다. 그래서 <code>sum</code> 호출 이후에 <code>v1_iter</code> 를 사용할 수 없다. </p>
<h3 id="methods-that-produce-other-iterators">Methods that Produce Other Iterators<a class="headerlink" href="#methods-that-produce-other-iterators" title="Permanent link">¶</a></h3>
<p>consuming adaptor 가 아닌 iterator adaptor 라는 것도 있는데, 얘는 <code>Iterator</code> trait 에 정의된 한 Iterator 를 다른 Iterator 로 변환한다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">v1</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="n">v1</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>위 코드는 <code>map</code> 에 Closure 를 전달하여 새로운 Iterator 를 만드는 것이다. 즉 <code>map</code> 은 iterator adaptor 인 것이다. 하지만 <code>map</code> 이 반환하는 것은 Iterator 이므로 lazy 하다. 그래서 Iterator 를 consume 해주는 <code>collect</code> Method 를 사용해야 벡터로 저장할 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">v1</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">v2</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]);</span><span class="w"></span>
</code></pre></div>
<blockquote>
<p>&lt;_&gt; 라고 한 것은 어떤 문법?</p>
</blockquote>
<p><code>filter</code> iterator adaptor 는 Closure 가 <code>true</code> 를 반환할 때에만 새로운 Iterator 에 포함시킨다. </p>
<h3 id="creating-our-own-iterators-with-the-iterator-trait">Creating Our Own Iterators with the Iterator Trait<a class="headerlink" href="#creating-our-own-iterators-with-the-iterator-trait" title="Permanent link">¶</a></h3>
<p>지금까지 <code>Vec</code> 에 <code>iter</code>, <code>into_iter</code>, <code>iter_mut</code> 을 호출하여 Iterator 를 만들어 봤는데, <code>HashMap</code> 같은 다른 collections 에서부터도 Iterator 를 만들 수 있다. 일반적으로 <code>Iterator</code> Trait 를 구현한 모든 데이터타입으로부터 Iterator 를 만들 수 있다. </p>
<p>가령 1 부터 5 까지 카운팅하는 Iterator 를 만들어보자. 먼저 <code>Counter</code> 라는 Struct 를 만든다. </p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Counter</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">count</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Counter</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Counter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">count</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>관례적으로 <code>new</code> Function (생성자) 을 만들어준다. 이제 <code>Iterator</code> Trait 를 구현해보자. 그러려면 <code>next</code> Method 를 구현하면 되지.</p>
<div class="highlight"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>associated <code>Item</code> type 을 <code>u32</code> 로 지정했는데 이로써 <code>next</code> 의 반환 타입은 <code>u32</code> 가 된다. </p>
<p>이렇게 만들어본 우리의 Iterator 를 <code>next</code> Method 를 직접 호출해봄으로써 테스트해보자. </p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">calling_next_directly</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Counter</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>즉, <code>Counter::new()</code> 를 <code>vec![1,2,3,4,5].into_iter()</code> 와 거의 동일하다고 보면 된다. </p>
<p>이렇게 구현된 Iterator 는 엄연히 Iterator 이므로 다음과 같이 Standard Library 에 있는 Iterator Method 들을 모두 사용할 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">sum</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="n">Counter</span>::<span class="n">new</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">Counter</span>::<span class="n">new</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">sum</span><span class="p">();</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<h2 id="improving-our-io-project">Improving Our I/O Project<a class="headerlink" href="#improving-our-io-project" title="Permanent link">¶</a></h2>
<p>iterator 로 minigrep 을 개선해보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">search</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">query</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">query</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">results</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">results</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위와 같은 코드를 iterator 로 개선할 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">search</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">query</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;&amp;'</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">contents</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">line</span><span class="o">|</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">query</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이렇게 함수형 언어 특징으로 mutable state 를 최대한 줄이는 것이 좋다. 왜냐면 나중에 병렬 처리를 할 때 접근 관리를 해주어야 하는 영역을 최소화할 수 있기 때문이다. </p>
<p>심지어 for-loop 같은 것들 보다 iterator 를 사용하는게 성능이 좀 더 빠르다. </p>
<hr/>
<h2 id="more-about-cargo-and-cratesio">More About Cargo and Crates.io<a class="headerlink" href="#more-about-cargo-and-cratesio" title="Permanent link">¶</a></h2>
<h3 id="customizing-builds-with-release-profiles">Customizing Builds with Release Profiles<a class="headerlink" href="#customizing-builds-with-release-profiles" title="Permanent link">¶</a></h3>
<p>Cargo 는 디폴트로 dev 레벨로 컴파일을 하는데 이는 최적화 레벨이 낮은 대신 컴파일 속도가 빨라서 디버깅을 빨리 할 수 있다. release 를 할때가 되었으면 release 레벨로 컴파일을 해라. 그러면 최적화를 빡세게 해서 프로그램의 성능을 높일 수 있다. dev 레벨과 release 레벨의 디폴트 최적화 단계는 각각 0, 3 단계이다. 그러나 이 최적화 단계 또한 커스터마이징 가능하다. </p>
<p><a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo 의 모든 빌드 옵션</a> 을 살펴보라.</p>
<h3 id="making-useful-documentation-comments">Making Useful Documentation Comments<a class="headerlink" href="#making-useful-documentation-comments" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">/// Adds one to the number given.</span>
<span class="sd">///</span>
<span class="sd">/// # Examples</span>
<span class="sd">///</span>
<span class="sd">/// ```</span>
<span class="sd">/// let arg = 5;</span>
<span class="sd">/// let answer = my_crate::add_one(arg);</span>
<span class="sd">///</span>
<span class="sd">/// assert_eq!(6, answer);</span>
<span class="sd">/// ```</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위와 같이 <code>///</code> 으로 주석을 달면 Markdown 형식으로 HTML 변환이 되어 문서로 만들어진다. <code>cargo doc --open</code> 으로 확인하라. </p>
<p><code>//!</code> 는 아이템을 만드는 주석이고 <code>pub use</code> 로 선언된 Module 들도 자동으로 문서화가 된다. </p>
<p>re-export 를 하면 실제 Module 경로가 매우 복잡해도 <code>use crate::path</code> 할 때 경로를 짧게 만들 수 있다. </p>
<p><code>cargo publish</code> 로 crate 를 publish 하라.</p>
<p><code>cargo yank</code> 로 미래의 프로젝트들이 이전 버전의 crate 를 의존성으로 두는 것을 방지할 수 있다. </p>
<h2 id="cargo-workspaces">Cargo Workspaces<a class="headerlink" href="#cargo-workspaces" title="Permanent link">¶</a></h2>
<p>library crate 가 점점 더 커지면 이것을 다른 package 로 분리하고 싶어질 때가 온다. 이를 위해 Cargo 는 여러 package 를 관리하게 해주는 Workspaces 를 제공한다. </p>
<p>Workspaces 는 같은 <code>Cargo.lock</code> 과 같은 output 디렉토리를 공유하는 package 집합이다.</p>
<p>이제 실행기능을 제공하는 Binary crate 와 1 을 더하는 기능을 제공하는 library crate, 2 를 더하는 기능을 제공하는 library crate, 이 세 가지 crate 를 같은 Workspaces 로 관리해보자. </p>
<div class="highlight"><pre><span></span><code>$ mkdir add
$ <span class="nb">cd</span> add
$ cat &gt; Cargo.toml
<span class="o">[</span>workspace<span class="o">]</span>

<span class="nv">members</span> <span class="o">=</span> <span class="o">[</span>
    <span class="s2">"adder"</span>,
<span class="o">]</span>
$ cargo new adder
</code></pre></div>
<p>이제 <code>cargo build</code> 로 빌드 할 수 있다. 이제 library crate 를 추가해보자. <code>Cargo.toml</code> 을 다음과 같이 고치고, </p>
<div class="highlight"><pre><span></span><code><span class="k">[workspace]</span>

<span class="n">members</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"adder"</span><span class="p">,</span>
    <span class="s">"add-one"</span><span class="p">,</span>
<span class="p">]</span>
</code></pre></div>
<p>다음 명령어로 library crate 를 만든다. </p>
<div class="highlight"><pre><span></span><code>$ cargo new add-one --lib
     Created library <span class="sb">`</span>add-one<span class="sb">`</span> package
</code></pre></div>
<p><code>add-one/src/lib.rs</code> 는 다음과 같이 채우자.</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이제 이 library crate 를 Binary crate 에서 사용하기 위하여 <code>adder/Cargo.toml</code> 에 다음을 추가하자. </p>
<div class="highlight"><pre><span></span><code><span class="k">[dependencies]</span>

<span class="n">add-one</span> <span class="o">=</span> <span class="p">{</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"../add-one"</span> <span class="p">}</span>
</code></pre></div>
<p>workspace 는 하나의 <code>Cargo.lock</code> 을 공유하기 때문에 한 crate 에서 어떤 package 의존성을 선언하면 다른 crate 에서도 해당 버전의 package 를 사용하게 된다. 만약 <code>add-one</code> 에서 다음과 같은 </p>
<div class="highlight"><pre><span></span><code><span class="k">[dependencies]</span>
<span class="n">rand</span> <span class="o">=</span> <span class="s">"0.8.3"</span>
</code></pre></div>
<p>package 를 사용하면 다른 crate 에서도 동일한 버전을 사용해야 한다. 하지만 이 dependencies 를 해당 crate 의 <code>Cargo.toml</code> 에 추가해주어야 사용할 수 있다. </p>
<hr/>
<h2 id="smart-pointers">Smart Pointers<a class="headerlink" href="#smart-pointers" title="Permanent link">¶</a></h2>
<blockquote>
<p><a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">https://doc.rust-lang.org/book/ch15-00-smart-pointers.html</a></p>
</blockquote>
<p>pointer 는 주소값을 저장하는 변수에 대한 개념이다. Rust 에서 pointer 에 해당하는 개념은 reference 이다. reference 는 데이터를 borrow 해올 뿐이라서 데이터를 지칭하는 것 외에 아무런 기능을 하지 않는다. </p>
<p>반면 Smart pointer 는 reference 보다 더 다양한 기능을 제공한다. 가령 어떤 종류의 Smart pointer 는 reference counting 기능을 제공한다. </p>
<p>또한 reference 가 단순히 데이터를 borrow 해오는데 비해 smart pointer 는 많은 경우 데이터의 owner 가 된다. </p>
<p>사실 우리는 이미 smart pointer 를 다뤘었다. 그것은 <code>String</code> 과 <code>Vec&lt;T&gt;</code> 이다. </p>
<p>Smart pointer 는 struct 를 통하여 구현되는데, 일반적인 struct 들과 다른 점은 smart pointer 가 <code>Deref</code> 와 <code>Drop</code> Trait 를 구현한다는 것이다. </p>
<p><code>Deref</code> trait 는 smart pointer 가 reference 처럼 행동하게 해준다. <code>Drop</code> trait 는 smart pointer 가 scope 를 벗어났을 때 drop 되는 시점을 커스터마이징 하게 해준다.</p>
<p>smart pointer 는 Rust 에서 자주 발견되는 디자인 패턴이고 많은 라이브러리에 독자적으로 구현되어 있으며 당신도 구현할 수 있다. 지금은 표준 라이브러리에 구현된 smart pointer 인 <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>Ref&lt;T&gt;</code> 를 알아본다. </p>
<p>이후에 interior mutability 패턴과 reference cycles 개념을 알아보자.</p>
<h2 id="box">Box<a class="headerlink" href="#box" title="Permanent link">¶</a></h2>
<p><code>Box&lt;T&gt;</code> 는 데이터를 stack 이 아닌 heap 에 저장하게 해준다. stack 에 남는 것은 heap 에 있는 데이터를 가르킬 pointer 이다. Box smart pointer 는 다음과 같은 상황에 유용하다.</p>
<ul>
<li>
<p>컴파일 시 사이즈를 알 수 없는 데이터 타입을 사용할 때 </p>
</li>
<li>
<p>매우 큰 데이터를 사용하면서 ownership 을 옮겨야 하는데 Copy 되지 않아야 할 때 </p>
</li>
<li>
<p>When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type (-&gt; trait object ch17)</p>
</li>
</ul>
<p><code>Box</code> 의 기본적인 사용법은 다음과 같다. scope 를 벗어나면 stack 에 있는 pointer 와 heap 에 있는 data 모두 할당해제가 된다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="fm">println!</span><span class="p">(</span><span class="s">"b = {}"</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>하지만 많은 상황에서 <code>i32</code> 변수 하나 정도는 <code>Box</code> 에 저장하는 것보다 그냥 stack 에 저장하는 것이 더 낫다. </p>
<h3 id="enabling-recursive-types-with-boxes">Enabling Recursive Types with Boxes<a class="headerlink" href="#enabling-recursive-types-with-boxes" title="Permanent link">¶</a></h3>
<p>재귀 타입 데이터는 데이터 구조 내부에 자기 자신의 타입을 갖는다. 이러한 타입은 이론적으로 무한히 끝나지 않기에 Rust 가 데이터 크기를 가늠할 수 없다. 그래서 재귀 타입에 대하여 Rust 는 에러를 발생시킨다. 그러나 Box 를 사용하면 정확한 크기를 알 수 있기 때문에 재귀 타입 데이터를 사용할 수 있다. 정확한 크기를 알 수 있기 때문에 재귀 타입 데이터를 사용할 수 있다. </p>
<p>함수형 프로그래밍에서 자주 사용되는 cons 리스트를 예시로 들어보자. 다음과 같이 cons 리스트를 표현할 enum 을 정의하면 Rust 가 컴파일 시 사이즈를 가늠할 수 없기에 에러가 발생한다. </p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">List</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Cons</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Nil</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>하지만 일단 이 enum 을 기반으로 cons 리스트를 형식적으로라도 만들어보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">List</span>::<span class="p">{</span><span class="n">Cons</span><span class="p">,</span><span class="w"> </span><span class="n">Nil</span><span class="p">};</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">Nil</span><span class="p">)));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>물론 에러가 발생한다. 에러 타입은 "데이터 타입이 무한한 크기를 지닌다" 는 것이다. </p>
<p>이것을 해결하는 방법은 <code>List</code> 를 재귀적으로 <code>List</code> 에 포함시키는 것이 아니라 <code>Box&lt;List&gt;</code> 를 포함시키는 것이다. Box smart pointer 는 pointer 이기 때문에 데이터의 크기과 관계 없이 항상 동일한 사이즈를 갖는다. </p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">List</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Cons</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Nil</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">List</span>::<span class="p">{</span><span class="n">Cons</span><span class="p">,</span><span class="w"> </span><span class="n">Nil</span><span class="p">};</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Nil</span><span class="p">))))));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이렇게 하면 Rust 는 <code>List</code> 의 사이즈가 <code>i32</code> 와 pointer 크기 만큼이라는 것을 알 수 있고 정상적으로 컴파일을 할 수 있게 된다. </p>
<h2 id="treating-smart-pointers-like-regular-references-with-the-deref-trait">Treating Smart Pointers Like Regular References with the Deref Trait<a class="headerlink" href="#treating-smart-pointers-like-regular-references-with-the-deref-trait" title="Permanent link">¶</a></h2>
<p><code>Deref</code> trait 를 구현하는 것은 dereference operator <code>*</code> 의 행동을 커스터마이징하게 해준다. <code>Deref</code> 를 구현함으로써 smart pointer 를 reference 처럼 사용할 수 있다. </p>
<h3 id="following-the-pointer-to-the-value-with-the-dereference-operator">Following the Pointer to the Value with the Dereference Operator<a class="headerlink" href="#following-the-pointer-to-the-value-with-the-dereference-operator" title="Permanent link">¶</a></h3>
<p>reference 는 기본적으로 pointer 이다. 그러므로 실제 값을 가져오기 위하여 <code>*</code> 를 사용해야 한다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>이제 reference 대신 Box smart pointer 를 사용해보자. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>

<span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>Box smart pointer 에서도 reference 에서와 같이 dereference operator <code>*</code> 을 사용할 수 있다.</p>
<h3 id="defining-our-own-smart-pointer">Defining Our Own Smart Pointer<a class="headerlink" href="#defining-our-own-smart-pointer" title="Permanent link">¶</a></h3>
<p>Box smart pointer 를 새로 구현해보면서 dereference operator 를 관찰해보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">MyBox</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 <code>MyBox</code> 에는 아직 <code>*</code> 를 사용할 수 없다. 그러니 <code>Deref</code> trait 를 다음과 같이 구현해보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>실제로 <code>*y</code> 는 Rust 가 내부적으로 <span class="arithmatex">\(*(y.deref())\)</span> 로 치환해주는 것이다. <code>deref</code> Method 가 reference 를 반환하기에 <code>*</code> 가 여전히 필요하다. <code>deref</code> 가 데이터 자체를 반환한다면 ownership 이 넘어가버린다. </p>
<p>하지만 그렇다면 <code>deref</code> 가 무한히 호출되지 않을까. </p>
<h3 id="implicit-deref-coercions-with-functions-and-methods">Implicit Deref Coercions with Functions and Methods<a class="headerlink" href="#implicit-deref-coercions-with-functions-and-methods" title="Permanent link">¶</a></h3>
<p>Deref coercion 은 <code>Deref</code> trait 가 구현된 타입에서 작동한다. 이것은 reference 인 타입을 다른 타입으로 변환해준다. </p>
<p>가령 <code>&amp;String</code> 을 <code>&amp;str</code> 로 변환해준다. <code>String</code> 이 <code>Deref</code> trait 를 구현했기 때문이고 그것이 <code>str</code> 을 반환하기 때문이다. </p>
<p>Deref coercion 은 reference 를 타입이 맞지 않는 파라미터로 전달했을 때 자동으로 일어난다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Hello, {}!"</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위와 같은 함수는 string slice 를 파라미터로 받도록 정의되었지만 Deref coercion 덕분에 Mybox 타입의 값에 대한 reference 로도 호출될 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyBox</span>::<span class="n">new</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"Rust"</span><span class="p">));</span><span class="w"></span>
<span class="n">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>위 코드는 <code>MyBox&lt;String&gt;</code> 의 reference 를 <code>hello</code> 로 전달한다. MyBox 에는 <code>Deref</code> trait 가 구현되어 있기 때문에 Deref coercion 가 작동한다. 즉, <code>deref</code> 가 호출됨으로써 <code>&amp;MyBox&lt;String&gt;</code> 가 <code>&amp;String</code> 으로 변환된다.</p>
<p>표준 라이브러리는 <code>String</code> 에 <code>Deref</code> 를 구현해놓았기 때문에 <code>deref</code> 가 또 호출되어 <code>&amp;String</code> 이 <code>&amp;str</code> 로 변환된다. </p>
<p>만약 Rust 에 Deref coercion 이 없었다면 다음과 같이 <code>hello</code> 를 호출해야 한다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyBox</span>::<span class="n">new</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"Rust"</span><span class="p">));</span><span class="w"></span>
<span class="n">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)[</span><span class="o">..</span><span class="p">]);</span><span class="w"></span>
</code></pre></div>
<p><code>(*m)</code> 이 <code>MyBox&lt;String&gt;</code> 을 <code>String</code> 으로 바꾼다. 이후에 <code>&amp;</code> 과 <code>[..]</code> 이 <code>String</code> 을 <code>&amp;str</code> 로 바꾼다. </p>
<h3 id="how-deref-coercion-interacts-with-mutability">How Deref Coercion Interacts with Mutability<a class="headerlink" href="#how-deref-coercion-interacts-with-mutability" title="Permanent link">¶</a></h3>
<p><code>Deref</code> trait 가 immutable reference 에 대한 <code>*</code> 의 작동을 override 하는 것이라면,</p>
<p><code>DerefMut</code> trait 는 mutable reference 에 대한 <code>*</code> 의 작동을 override 하는 것이다. </p>
<p>일반적으로 Rust 는 다음의 데이터 타입이 감지되면 deref coercion 을 작동시킨다. </p>
<ul>
<li>
<p>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code> </p>
</li>
<li>
<p>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></p>
</li>
<li>
<p>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></p>
</li>
</ul>
<p>처음 두 케이스는 mutability 를 제외하고 동일하다. <code>U</code> 를 향한 <code>Deref</code> 가 구현된 <code>T</code> 의 reference 인 <code>&amp;T</code> 를 만난다면 Rust 는 <code>&amp;U</code> 로 변환해준다.</p>
<p>세번째 경우는 Rust 가 mutable 을 immutable 로 deref coercion 해준다는 것을 말해준다. 그러나 Rust 는 절대로 immutable 을 mutable 로 변환하지 않는다. </p>
<h2 id="running-code-on-cleanup-with-the-drop-trait">Running Code on Cleanup with the Drop Trait<a class="headerlink" href="#running-code-on-cleanup-with-the-drop-trait" title="Permanent link">¶</a></h2>
<p>Smart pointer 에 중요한 trait 는 <code>Deref</code> 와 <code>Drop</code> 이다. </p>
<p><code>Drop</code> trait 는 어느 타입에든 구현가능하고, File 이나 network 연결 같은 release 가 필요한 코드에도 구현가능하다. </p>
<p>Rust 는 scope 를 벗어나면 자동으로 할당 해제를 해준다. <code>Drop</code> trait 를 구현하는 것은 scope 를 벗어났을 때 하는 행동을 정의하는 것이다. </p>
<p><code>Drop</code> trait 는 mutable <code>self</code> 를 파라미터로 받는 <code>drop</code> 메소드를 구현하는 것이다. </p>
<p>다음과 같이 예를 들어보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">CustomSmartPointer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CustomSmartPointer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Dropping CustomSmartPointer with data `{}`!"</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>CustomSmartPointer</code> 인스턴스가 scope 를 벗어나면 <code>drop</code> 메소드가 자동으로 호출된다.</p>
<h3 id="dropping-a-value-early-with-stdmemdrop">Dropping a Value Early with std::mem::drop<a class="headerlink" href="#dropping-a-value-early-with-stdmemdrop" title="Permanent link">¶</a></h3>
<p><code>drop</code> 을 비활성화시키는 것은 쉽지 않고, 그럴 일도 자주 없다. 그 대신 더 일찍 <code>drop</code> 을 시키는 방법은 있다. </p>
<p>가령 smart pointer 가 lock 을 관리하고 있을 때 lock 을 해제하고 싶다면 <code>drop</code> 을 일찍 해야 한다. 이 경우 <code>drop</code> Method 를 호출하는게 아니라 <code>std::mem::drop</code> 을 호출해야 한다. <code>drop</code> method 를 직접 호출하면 에러가 발생한다. </p>
<p>왜냐하면 Rust 는 scope 를 벗어났을 때 <code>drop</code> 을 자동으로 호출하므로 double free 가 발생하기 때문이다. </p>
<p><code>std::mem::drop</code> 을 사용하는 예시는 다음과 같다. </p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">CustomSmartPointer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CustomSmartPointer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Dropping CustomSmartPointer with data `{}`!"</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CustomSmartPointer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">data</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"some data"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"CustomSmartPointer created."</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"CustomSmartPointer dropped before the end of main."</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="rc-the-reference-counted-smart-pointer">Rc<t>, the Reference Counted Smart Pointer<a class="headerlink" href="#rc-the-reference-counted-smart-pointer" title="Permanent link">¶</a></t></h3>
<p>한 데이터에 여러 ownership 이 필요할 때 <code>Rc&lt;T&gt;</code> 를 사용한다. </p>
<p>가령 그래프에서 한 노드에 여러 엣지가 있을 경우 개념적으로 여러 엣지가 해당 노드의 ownership 을 갖고 있다. 모든 엣지가 사라질 때까지 그 노드는 해제되면 안된다. </p>
<p><code>Rc&lt;T&gt;</code> 는 zero-reference 가 되었을 때 해제를 실행한다. <code>Rc&lt;T&gt;</code> 는 싱글 스레드에서만 사용된다. </p>
<h3 id="refcell-and-the-interior-mutability-pattern">RefCell<t> and the Interior Mutability Pattern<a class="headerlink" href="#refcell-and-the-interior-mutability-pattern" title="Permanent link">¶</a></t></h3>
<p>interior mutability 는 데이터에 대한 immutable reference 가 있을 때에도 데이터를 수정하는 것이다. 이런 경우 데이터를 수정하기 위하여 <code>unsafe</code> 코드 블록을 사용한다. </p>
<p><code>RefCell&lt;T&gt;</code> 는 하나의 ownership 을 가진다. <code>Box&lt;T&gt;</code> 가 데이터의 불변성을 컴파일 시에 확증해주면, <code>RefCell&lt;T&gt;</code> 는 런타임 시에 확증한다. reference 가 borrow rule 을 어기면 컴파일 에러가 발생하지만, <code>RefCell</code> 이 borrow rule 을 어기면 실행흐름이 panic 되고 종료된다. </p>
<p>borrow rule:</p>
<ul>
<li>
<p>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</p>
</li>
<li>
<p>References must always be valid.</p>
</li>
</ul>
<p>borrow rule 을 컴파일 상에서 체크하는 것은 에러를 빨리 발견할 수 있고 런타임에 영향을 미치지 않게 해준다. 그래서 많은 경우 뭐든 컴파일 시에 체크하는 게 베스트이다. </p>
<p>런타임 시에 rule 을 체크하는 것은 분명 memory-safe 한 코드인데도 컴파일 룰에 의하여 허용되지 않은 상황에 유용하다. </p>
<p>Rust 컴파일러는 본질적으로 보수적이다. 옳지 않은 코드는 당연히 컴파일되지 않고, 올바른데도 의심되는 코드도 컴파일하지 않는다. </p>
<p><code>RefCell&lt;T&gt;</code> 은 당신이 당신의 코드가 borrow rule 을 따른다는 것을 확신하지만 컴파일러가 그것을 확신할 수 없을 때 사용된다. </p>
<p><code>RefCell</code> 도 single-thread 에서만 사용된다. </p>
<h3 id="interior-mutability-a-mutable-borrow-to-an-immutable-value">Interior Mutability: A Mutable Borrow to an Immutable Value<a class="headerlink" href="#interior-mutability-a-mutable-borrow-to-an-immutable-value" title="Permanent link">¶</a></h3>
<p>다음 코드는 Interior mutability 를 시도한다. 당연히 에러가 발생한다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>하지만 <code>RefCell</code> 을 사용하면 Interior mutability 가 가능하다. 그러나 <code>RefCell</code> 이 borrow rule 을 어기면 런타임 상에서 패닉에 빠진다. </p>
<h3 id="a-use-case-for-interior-mutability-mock-objects">A Use Case for Interior Mutability: Mock Objects<a class="headerlink" href="#a-use-case-for-interior-mutability-mock-objects" title="Permanent link">¶</a></h3>
<p>test double 은 testing 상황에서 사용되는 일반적인 프로그래밍 개념이다. Mock object 는 test 중에 일어나는 일을 기록하는데 이로써 올바른 행동이 취해졌는지 확인 가능하다. </p>
<p>가령 어떤 값을 추적하여 메시지를 보내는 object 를 만들어보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Messenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">LimitTracker</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="nc">Messenger</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">messenger</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">max</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LimitTracker</span><span class="o">&lt;'</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nc">Messenger</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">messenger</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">max</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">LimitTracker</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">LimitTracker</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">messenger</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">value</span>: <span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">max</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">set_value</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">percentage_of_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">max</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">percentage_of_max</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">messenger</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"Error: You are over your quota!"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">percentage_of_max</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.9</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">messenger</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"Urgent warning: You've used up over 90% of your quota!"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">percentage_of_max</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.75</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">messenger</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"Warning: You've used up over 75% of your quota!"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>중요한 것은 <code>Messenger</code> trait 가 <code>send</code> 에서 immutable reference 와 메시지를 받는다는 것이다. 이 trait 가 우리가 예로 들 Mock object 가 구현할 대상이다. 이때 <code>set_value</code> 는 아무런 assertion 이 없다. 그러므로 다음과 같은 Mock object 를 만들어서 <code>set_value</code> 를 호출할 때 메시지를 <code>MockMessenger</code> 의 <code>sent_messages</code> 에 저장하도록 한다. </p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">struct</span> <span class="nc">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">sent_messages</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">sent_messages</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[],</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Messenger</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">message</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">sent_messages</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">message</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">it_sends_an_over_75_percent_warning_message</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">mock_messenger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MockMessenger</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">limit_tracker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LimitTracker</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_messenger</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">limit_tracker</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">80</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">mock_messenger</span><span class="p">.</span><span class="n">sent_messages</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>그러나 이는 컴파일 에러가 발생한다. <code>send</code> 메소드가 immutable reference 받기 때문에 <code>MockMessenger</code> 를 수정할 수 없기 때문이다. 그러나 <code>send</code> 의 <code>&amp;self</code> 를 <code>&amp;mut sef</code> 로 고칠 수도 없는게 trait 에서 Method 의 정의가 고정되어있기 때문이다. </p>
<p>따라서 interior mutability 의 도움을 받을 차례이다. </p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sent_messages</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">sent_messages</span>: <span class="nc">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[]),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Messenger</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MockMessenger</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">message</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">sent_messages</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">push</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">message</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위와 같이 <code>RefCell</code> 을 사용하도록 고치면 interior mutability 를 사용할 수 있다. <code>RefCell</code> 의 <code>borrow</code> 는 immutable reference 타입의 <code>Ref&lt;T&gt;</code> 를 반환한다. borrow rule 에 의하여 우리는 immutable reference 여러개 혹은 mutable reference 하나를 가질 수 있다. </p>
<p><code>borrow_mut</code> 은 mutable reference <code>RefMut&lt;T&gt;</code> 을 반환하는데 borrow rule 에 의해 하나밖에 생성할 수 없다. 두번 이상 호출하면 에러가 발생한다. </p>
<h3 id="having-multiple-owners-of-mutable-data-by-combining-rc-and-refcell">Having Multiple Owners of Mutable Data by Combining Rc<t> and RefCell<t><a class="headerlink" href="#having-multiple-owners-of-mutable-data-by-combining-rc-and-refcell" title="Permanent link">¶</a></t></t></h3>
<p>하지만 <code>Rc</code> 와 <code>RefCell</code> 을 결합하면 mutable reference 를 여러개 가질 수 있다. </p>
<p>(skip)</p>
<h2 id="reference-cycles-can-leak-memory">Reference Cycles Can Leak Memory<a class="headerlink" href="#reference-cycles-can-leak-memory" title="Permanent link">¶</a></h2>
<p>Rust 가 memory-safe language 이지만 memory leak 이 불가능한 것이 아니라 memory leak 을 어렵게 만든 것이다. </p>
<p>Memory leak: to accidentally create memory that is never cleaned up (known as a memory leak)</p>
<p>가령 <code>Rc&lt;T&gt;</code> 와 <code>RefCell&lt;T&gt;</code> 를 사용할 때 memory leak 이 발생할 수 있다. </p>
<p>cycle 속에서 서로를 참조하는 reference 들을 만들면 reference count 가 <span class="arithmatex">\(0\)</span> 이 되지 않아서 영원히 drop 되지 않고 결국 memory leak 이 발생한다. </p>
<p>pass</p>
<hr/>
<h2 id="concurrency">Concurrency<a class="headerlink" href="#concurrency" title="Permanent link">¶</a></h2>
<p>Rust 팀은 memory-safety 와 concurrency safety 를 이루고자 했다. 그리고 ownership 과 type system 이 이 두 문제를 해결하기 위한 강력한 해결책이라는 것을 깨달았다. ownership 과 type system 으로 수많은 concurrency 문제들이 런타임 상이 아닌 컴파일 상에서 확인된다.</p>
<p>thread 를 사용하면 한번에 여러 일을 처리할 수 있어서 프로그램 성능이 좋아진다. 그러나 다음과 같은 concurrency 문제들이 발생할 수도 있다.</p>
<ul>
<li>
<p>Race condition</p>
</li>
<li>
<p>Deadlock</p>
</li>
<li>
<p>특수한 상황에서 발생하여 재생산하거나 고치기가 매우 어려운 문제들</p>
</li>
</ul>
<p>프로그래밍 언어는 thread 를 다양한 방식으로 구현한다. 많은 OS 가 thread 를 생성하는 API 를 제공하는데 프로그래밍 언어가 이 OS 의 API 를 호출하는 방식이 하나의 OS thread 당 하나의 프로그래밍 언어 thread 를 뜻하는 1:1 모델이다. </p>
<p>많은 프로그래밍 언어가 그들만의 thread 구현을 갖는데 프로그래밍 언어가 제공하는 thread 를 green thread 라고 한다. green thread 를 사용하는 언어는 OS thread 와는 다른 맥락에서 thread 를 작동시킨다. 따라서 green-thread 는 M 개의 green thread 당 N 개의 OS thread 가 있다는 뜻의 M:N 모델이라고 부른다. </p>
<p>green-thread 의 overhead 로 인하여 Rust 는 기본적으로 1:1 모델을 제공한다. 그러나 Rust 에는 M:N 모델을 제공하는 많은 crate 들이 있다. </p>
<p><code>std::thread::spawn</code> 에 closure 를 전달하여 thread 를 생성할 수 있다. <code>main</code> 함수가 끝나면 thread 가 자동으로 종료된다. 따라서 <code>join</code> 을 사용해야 한다.</p>
<p><code>thread</code> 의 closure 에서 <code>move</code> 를 사용하여 외부 환경을 가져올 수 있다. <code>move</code> 로 외부 환경의 ownership 을 thread 로 가져와야 하는 이유는 reference 를 가져온다면 <code>main</code> 함수에서 lifetime 이 곧바로 끝나버릴 수도 있기 때문이다. </p>
<h3 id="using-message-passing-to-transfer-data-between-threads">Using Message Passing to Transfer Data Between Threads<a class="headerlink" href="#using-message-passing-to-transfer-data-between-threads" title="Permanent link">¶</a></h3>
<p>concurrency 를 안전하게 할 수 있는 방법은 thread 가 데이터가 포함된 메시지를 서로에게 보내는 message passing 이다. Rust 는 channel 로써 이를 구현했다. channel 은 transmitter 와 receiver 로 구성되는데, transmitter 가 데이터를 보내면 receiver 가 그것을 받을 수 있는 구조이다. 둘 중 하나라도 drop 되면 channel 이 닫힌다. </p>
<p><code>std::sync::mpsc</code> 는 multiple producer, single soncumer 라는 뜻인데 여러 transmitter 와 하나의 receiver 가 있는 구조이다. Rust 표준 라이브러리가 channel 을 구현한 방식은 이렇게 다중 sending 과 하나의 receiver 이다. </p>
<h3 id="shared-state-concurrency">Shared-State Concurrency<a class="headerlink" href="#shared-state-concurrency" title="Permanent link">¶</a></h3>
<p>Message passing 말고 concurrency 를 다루는 또다른 방법은 sharing memory 이다. 하지만 Message passing 이 Message passing 에서 데이터를 한번 전송하면 더 이상 사용할 수 없으므로 single ownership 인 반면에 sharing memory 는 multiple ownership 이다. </p>
<p>multiple ownership 은 다중 접근이 가능한 반면 코드가 복잡해지고 쉽게 취약해진다. Mutex 는 데이터에 한번에 하나의 thread 만 접근하게 해준다. thread 가 Mutex 로부터 보호받는 데이터에 접근하기 위해서는 먼저 Mutex 에게 lock 요청을 해야 한다. </p>
<p>Mutex 가 사용하기에 힘든 이유는 다음과 같은 규칙을 기억해야 하기 때문이다. </p>
<ul>
<li>
<p>데이터에 접근하기 전에 반드시 lock 을 요청해야 한다. </p>
</li>
<li>
<p>데이터를 다 사용했으면 다른 thread 가 사용할 수 있도록 unlock 을 해야 한다. </p>
</li>
</ul>
<p>이 두 가지 규칙을 방대한 코드베이스에서 매번 매순간 지키는 것이 쉽지 않아서 Mutex 의 악명이 높아졌다. 그래서 차라리 Shared memory 를 아예 버리고 안전한 Message passing 을 사용하자는 사람들이 있는 것이다. </p>
<p>그러나 Rust 의 Mutex 는 type system 과 ownership rule 로 인하여 이 Mutex 규칙을 잘 지킬 수 있다.</p>
<p><code>std::sync::Mutex</code> 에서 <code>Mutex&lt;T&gt;</code> 를 사용할 수 있는데 사실 이는 <code>T</code> 타입 데이터에 대한 Smart pointer 이다.</p>
<p>Multiple ownership 을 구현하기 위하여 Mutex 를 한 thread 로 보내면 Mutex 의 ownership 이 이동되어 다른 thread 로 보낼 수가 없다. 그래서 <code>Rc</code> 를 사용하여 Mutex 를 클로하여 보내려할 수 있는데 <code>Rc</code> 는 thread-safe 하지 않기 때문에 사용못한다. <code>Arc</code> 는 atomic reference counted 타입 smart pointer 인데 이게 thread-safe 하기 때문에 사용할 수 있다. </p>
<p>모든 데이터 타입이 thread-safe 하지 않은 것은 데이터 타입을 thread-safe 하게 만들려면 성능이 약간 떨어지기 때문이다. 그래서 필요할 때만 atomic 타입 <code>std::sync::atomic</code> 들을 사용하면 된다.</p>
<p>interior mutability 를 구현할 때 <code>RefCell</code> 과 <code>Rc</code> 를 사용한 것이 <code>Mutex</code> 와 <code>Arc</code> 를 사용한 것과 비슷하다. <code>RefCell</code>, <code>Rc</code> 를 사용할 때 reference cycle 이라는 위험이 있었듯이 <code>Mutex</code> 를 사용한다고 해서 Deadlock 에 걸릴 수 있듯이 모든 위험이 제거되는 건 아니다. </p>
<p>Deadlock 에 대한 정보를 <code>Mutex&lt;T&gt;</code> 와 <code>MutexGuard</code> 의 공식 문서에서 더 알아볼 수 있다. </p>
<h2 id="extensible-concurrenty-sync-and-send-trait">Extensible Concurrenty (Sync and Send Trait)<a class="headerlink" href="#extensible-concurrenty-sync-and-send-trait" title="Permanent link">¶</a></h2>
<p>Rust 는 concurrency 에 대한 기능을 매우 적게 제공한다. 지금까지 살펴본 concurrency 기능들도 Rust 가 제공하는 것이 아니라 Rust 의 표준 라이브러리가 제공하는 것이다. concurrency 를 사용하기 위하여 다른 crate 를 찾아보거나 당신이 직접 만들어라. 하지만 Rust 가 제공하는 concurrency 기능이 있는데 그것은 <code>Sync</code> 와 <code>Send</code> trait 이다.</p>
<p><code>Send</code> trait 는 thread 간에 데이터의 ownership 이 전달될 수 있다는 기능이다. 거의 모든 데이터 타입이 <code>Send</code> 이지만 <code>Rc</code> 같은 것들은 <code>Send</code> 가 아니다.</p>
<p><code>Sync</code> trait 는 이 데이터가 다중 thread 에 의하여 안전하게 referenced 될 수 있다는 것이다. 쉽게 말해서 <code>Sync</code> 인 타입 <code>T</code> 는 reference <code>&amp;T</code> 가 <code>Send</code> 라서 다른 thread 로 안전하게 보내질 수 있다. </p>
<p>그러나 <code>Send</code>, <code>Sync</code> 를 직접 구현하는 것은 안전하지 않다. 차라리 <code>Send</code> 와 <code>Sync</code> 를 구현한 타입을 기반으로 concurrency 기능을 만든다면 자연스레 <code>Send</code>, <code>Sync</code> 를 사용할 수 있다. 직접 구현하려면 <code>unsafe</code> 코드들이 필요하다.</p>
<hr/>
<h2 id="oop">OOP<a class="headerlink" href="#oop" title="Permanent link">¶</a></h2>
<p>Rust 는 OOP 뿐만 아니라 함수형 프로그래밍 등 다양한 프로그래밍 패러다임에 영향을 받았다.  프로그래밍 커뮤티니에서 프로그래밍 언어가 어떤 OOP 특징을 가져야 하는지에 대한 consensus 는 없다. 그러나 분명히 OOP 언어는 object, encapsulation, inheritance 를 제공해야 할 것이다.</p>
<h3 id="objects-contain-data-and-behavior">Objects Contain Data and Behavior<a class="headerlink" href="#objects-contain-data-and-behavior" title="Permanent link">¶</a></h3>
<p>OOP 는 object 로 만들어진다. object 는 데이터와 데이터 위의 기능이 정의되어야 한다. 데이터 위의 기능이란 보통 Method 로 불린다. Rust 는 데이터와 데이터 위의 기능을 제공하는 Struct, Enum 이 있기 때문에 OOP 언어이다. Struct 와 Enum 은 <code>impl</code> 블록으로 기능 구현을 제공한다. </p>
<h3 id="encapsulation-that-hides-implementation-details">Encapsulation that Hides Implementation Details<a class="headerlink" href="#encapsulation-that-hides-implementation-details" title="Permanent link">¶</a></h3>
<p>Encapsulation 은 object 의 내부 코드에 접근할 수 없다는 특징이다. 이에 따라 object 와 상호작용할 수 있는 유일한 방법은 public API 가 된다. Rust 는 encapsulation 을 <code>pub</code> 키워드를 적절히 사용함으로써 이루어낼 수 있게 한다. </p>
<p>Struct 에 <code>pub</code> 키워드를 사용할 수 있지만 그 필드는 여전히 private 이다. 이것은 object 의 데이터가 반드시 public API, 즉 Method 를 통하여 수정된다는 것을 보장받을 수 있는 중요한 특징이다. </p>
<h3 id="inheritance-as-a-type-system-and-as-code-sharing">Inheritance as a Type System and as Code Sharing<a class="headerlink" href="#inheritance-as-a-type-system-and-as-code-sharing" title="Permanent link">¶</a></h3>
<p>inheritance 는 object 가 다른 object 의 정의를 상속받아서 상위 object 의 데이터와 Method 를 재정의할 필요가 없게 하는 특징이다. Rust 는 inheritance 를 제공하지는 않는다. 그러나 당신이 상속을 애용하는 프로그래머라면 Rust 에서는 또 다른 방법이 있다. </p>
<p>일단 당신이 상속을 사용하는 이유는 크게 두 가지이다. 하나는 코드 재사용이다. 당신은 상속을 통해 상위 object 의 정의를 재사용하고 싶을 것이다. 이는 Rust 의 default trait 를 통하여 가능하다. </p>
<p>상속을 사용하는 또 다른 이유는 type system 과 관련 있다. 즉, 하위 object 타입을 상위 object 타입이 정의된 곳에서 사용하고 싶기 때문이다. 이것을 같은 특성을 공유하는 여러 object 를 하나의 상위 object 선언으로 사용할 수 있다고 해서 polymorphism 이라 한다.</p>
<p>그러나 상속은 필요 이상의 코드를 공유하게 된다는 위험성 때문에 프로그래밍 설계에서 그 위상이 추락하고 있다. 하위 class 는 그럴 필요가 없을 때에도 상위 class 의 모든 특성을 다 공유받게 되는데, 이는 프로그래밍 설계를 유연하지 못하게 만든다. 또한 상속은 하위 class 가 그 object 에 맞지 않는 Method 를 호출할 수도 있게 만든다.</p>
<p>상속이 이러한 문제점을 가지므로 Rust 는 상속 대신에 trait 라는 개념으로 언어를 설계했다. trait 는 Rust 에 polymorphism 을 구현한다. </p>
<h2 id="using-trait-objects-that-allow-for-values-of-different-typespolymorphism">Using Trait Objects That Allow for Values of Different Types(Polymorphism)<a class="headerlink" href="#using-trait-objects-that-allow-for-values-of-different-typespolymorphism" title="Permanent link">¶</a></h2>
<p>trait 로 Polymorphism 을 구현하는 예시를 들어보자. 먼저 <code>Draw</code> 라는 trait 를 정의하자.</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이제 <code>Screen</code> 이라는 Struct 를 정의할텐데 이는 <code>Box&lt;dyn Draw&gt;</code> 타입 벡터를 가진다. 이 타입은 <code>Draw</code> trait 를 구현하는 trait object 이다. trait object 는 나중에 알아본다. <code>Scree</code> 은 벡터에 들어있는 인스턴스들의 <code>draw</code> 메소드를 다 호출해주는 <code>run</code> 메소드를 가진다. </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Screen</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">components</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Draw</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Screen</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">component</span><span class="p">.</span><span class="n">draw</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 코드는 Generic 과 다르게 동작한다. 다음과 같은 Generic 코드는 하나의 타입에 대해서만 치환되지만 trait object 는 여러 타입을 가질 수 있다. 그래서 다음의 Generic 코드로는 Polymorphism 을 구현할 수 없다. </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Screen</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Draw</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">components</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Screen</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nc">Draw</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">component</span><span class="p">.</span><span class="n">draw</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이제 <code>Draw</code> trait 를 구현하는 여러 타입을 정의하고 그것을 <code>Screen</code> Struct 의 벡터에 포함시켜서 실행시켜보는 것으로 Polymorphism 을 구현해보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Button</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">width</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">label</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Button</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// code to actually draw a button</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">SelectBox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">width</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">options</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SelectBox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// code to actually draw a select box</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이제 <code>main</code> 함수에서 다음과 같이 실행 코드를 짜면 된다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">screen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Screen</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">components</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="w"></span>
<span class="w">            </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">SelectBox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">width</span>: <span class="mi">75</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">height</span>: <span class="mi">10</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">options</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="w"></span>
<span class="w">                    </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"Yes"</span><span class="p">),</span><span class="w"></span>
<span class="w">                    </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"Maybe"</span><span class="p">),</span><span class="w"></span>
<span class="w">                    </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"No"</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">],</span><span class="w"></span>
<span class="w">            </span><span class="p">}),</span><span class="w"></span>
<span class="w">            </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Button</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">width</span>: <span class="mi">50</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">height</span>: <span class="mi">10</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">label</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"OK"</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="p">}),</span><span class="w"></span>
<span class="w">        </span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="n">screen</span><span class="p">.</span><span class="n">run</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch<a class="headerlink" href="#trait-objects-perform-dynamic-dispatch" title="Permanent link">¶</a></h3>
<p>trait object 를 사용하면 Polymorphism 을 구현할 수 있어서 더 유연한 코드를 짤 수 있지만, dynamic dispatch 를 사용할 수밖에 없어서 static dispatch 코드보다 성능이 약간 더 떨어진다. Generic 코드 같은 것들이 static dispatch 를 사용하여 컴파일 최적화를 더 빡세게 할 수 있지만 덜 유연한 코드를 짤 수밖에 없다. trade-off 가 있는 것이니 상황에 따라 선택하면 된다.</p>
<h3 id="object-safety-is-required-for-trait-objects">Object Safety Is Required for Trait Objects<a class="headerlink" href="#object-safety-is-required-for-trait-objects" title="Permanent link">¶</a></h3>
<p>하지만 object-safe trait 만이 trait object 가 될 수 있다. trait 의 모든 Method 가 다음 조건을 만족하면 object safe 이다. </p>
<ul>
<li>
<p>반환형이 <code>Self</code> 가 아니다.</p>
</li>
<li>
<p>Generic 타입 파라미터가 없다.</p>
</li>
</ul>
<p><code>Self</code> 는 해당 Method 가 정의된 타입을 뜻한다.</p>
<h2 id="implementing-an-object-oriented-design-pattern">Implementing an Object-Oriented Design Pattern<a class="headerlink" href="#implementing-an-object-oriented-design-pattern" title="Permanent link">¶</a></h2>
<p>state pattern 은 OOP 디자인 패턴이다. 이 패턴은 state object 들의 상태를 나타내는 내부 변수를 정의하고, 상태 변수에 따라 기능이 달라진다. </p>
<p>가령 블로그 포스트를 게시하는 경우에 응용될 수 있다. </p>
<ol>
<li>
<p>빈 상태의 블로스 포스트가 생성된다. </p>
</li>
<li>
<p>포스트 초안이 완성되면 리뷰가 요청된다. </p>
</li>
<li>
<p>포스트가 허가되면 <code>content</code> 메소드가 내용을 반환한다. </p>
</li>
<li>
<p>허가되지 않은 포스트는 <code>content</code> 가 내용을 반환하지 않는다.</p>
</li>
</ol>
<p>pass</p>
<hr/>
<h2 id="patterns-and-matching">Patterns and Matching<a class="headerlink" href="#patterns-and-matching" title="Permanent link">¶</a></h2>
<p>pass</p>
<h2 id="all-the-places-patterns-can-be-used">All the Places Patterns Can Be Used<a class="headerlink" href="#all-the-places-patterns-can-be-used" title="Permanent link">¶</a></h2>
<p>pass</p>
<h3 id="match-arms">match Arms<a class="headerlink" href="#match-arms" title="Permanent link">¶</a></h3>
<p>pass</p>
<h3 id="conditional-if-let-expressions">Conditional if let Expressions<a class="headerlink" href="#conditional-if-let-expressions" title="Permanent link">¶</a></h3>
<p>pass</p>
<h3 id="while-let-conditional-loops">while let Conditional Loops<a class="headerlink" href="#while-let-conditional-loops" title="Permanent link">¶</a></h3>
<p>pass</p>
<h3 id="for-loops">for Loops<a class="headerlink" href="#for-loops" title="Permanent link">¶</a></h3>
<p>pass</p>
<h3 id="let-statements">let Statements<a class="headerlink" href="#let-statements" title="Permanent link">¶</a></h3>
<p><code>let</code> 을 사용할 때도 패턴이 사용된다. <code>let</code> 은 엄밀하게 다음과 같다. Rust 는 expression 을 pattern 과 비교하여 매칭되는 것에 값을 할당한다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">PATTERN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EXPRESSION</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>따라서 다음 코드의 의미는 이렇다. <code>x</code> 는 "<code>x</code> 라는 변수에 매칭되는 것을 할당하라" 는 의미의 패턴이다. 이 경우 <code>x</code> 자체가 패턴이므로 "변수 <code>x</code> 에 값을 할당하라" 가 된다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>다음 코드의 의미를 살펴보자. Rust 는 값 <code>(1,2,3)</code> 을 패턴 <code>(x,y,z)</code> 와 비교하여 매칭되는 변수에 값을 할당한다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<h3 id="function-parameters">Function Parameters<a class="headerlink" href="#function-parameters" title="Permanent link">¶</a></h3>
<p>함수 파라미터도 사실 패턴이었다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// code goes here</span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">print_coordinates</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Current location: ({}, {})"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">print_coordinates</span><span class="p">(</span><span class="o">&amp;</span><span class="n">point</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드에서 <code>x</code>, <code>&amp;(x, y)</code> 가 패턴이다. <code>print_coordinates</code> 에서 <code>&amp;(3, 5)</code> 가 <code>&amp;(x, y)</code> 에 매칭되어 <code>x</code> 에 <code>3</code> 이 할당되고 <code>y</code> 에 <code>5</code> 가 할당된다. </p>
<h2 id="refutability-whether-a-pattern-might-fail-to-match">Refutability: Whether a Pattern Might Fail to Match<a class="headerlink" href="#refutability-whether-a-pattern-might-fail-to-match" title="Permanent link">¶</a></h2>
<p>가능한 임의의 값에 매칭되는 패턴은 irrefutable 이다. 가령 <code>let x = 5</code> 의 <code>x</code> 는 아무것에나 매칭될 수 있으므로 irrefutable 이다. </p>
<p>그러나 매칭에 실패할 수 있는 패턴은 refutable 이다. 가령 <code>if let Some(x) = a</code> 에서 <code>Some(x)</code> 이라는 패턴은 <code>a</code> 가 <code>Some</code> 이 아니라 <code>None</code> 이면 매칭에 실패하므로 refutable 이다.</p>
<p>함수 파라미터, <code>let</code> 키워드, <code>for</code> 루프는 refutable 패턴이 매칭에 실패할 경우 할 수 있는 유의미한 일이 아무것도 없으므로 오직 irrefutable 패턴만 가진다. </p>
<p>가령 다음 코드의 <code>let</code> 에는 <code>Some(x)</code> 라는 패턴이 쓰였지만 refutable 이므로 에러가 발생한다. 실제로 <code>some_option_value</code> 이 <code>None</code> 이라고 매칭에 실패할 수도 있는 refutable 패턴이다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">some_option_value</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_option_value</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p><code>if let</code> 과 <code>while let</code> 은 refutable 패턴과 irrefutable 패턴을 가진다. 하지만 irrefutable 패턴에 대해서는 매칭 실패를 핸들링 해야 하므로 컴파일러가 경고를 해준다.</p>
<p>위 코드는 다음과 같이 <code>if let</code> 을 사용하면 에러가 해결된다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">some_option_value</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_option_value</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>하지만 다음과 같이 <code>if let</code> 에 irrefutable 패턴을 사용하면 컴파일이 되긴 하지만 경고를 해준다. <code>if let</code> 에 irrefutable 패턴을 사용할 이유가 없기 때문이다. </p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<p>이러한 이유들로 <code>match</code> 의 케이스에는 refutable 패턴들이 사용되고 마지막 케이스에서만 irrefutable 패턴이 사용된다. Rust 가 <code>match</code> 에 irrefutable 케이스를 오직 하나의 케이스에서만 허용하는 것도 같은 이유이다. </p>
<h2 id="pattern-syntax">Pattern Syntax<a class="headerlink" href="#pattern-syntax" title="Permanent link">¶</a></h2>
<h3 id="matching-literals">Matching Literals<a class="headerlink" href="#matching-literals" title="Permanent link">¶</a></h3>
<p>literal 을 패턴으로 사용가능하다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"one"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"two"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="mi">3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"three"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"anything"</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="matching-named-variables">Matching Named Variables<a class="headerlink" href="#matching-named-variables" title="Permanent link">¶</a></h3>
<p>Named variable 은 irrefutable 패턴이라 아무 값이나 매칭된다. 이것을 <code>match</code> 에 사용할 때는 주의해야 한다. 왜냐하면 <code>match</code> 는 새로운 scope 를 열고 <code>match</code> 의 케이스에 선언된 named variable 은 바깥 scope 에 있는 변수를 가리기 때문이다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Got 50"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Matched, y = {:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Default case, x = {:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="fm">println!</span><span class="p">(</span><span class="s">"at the end: x = {:?}, y = {:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>가령 위 코드에서 <code>"Matched, y = {:?}"</code> 라고 코딩을 한 걸로 보아 <code>Some(y)</code> 에 변수 <code>y</code> 가 매칭된다고 생각한 것 같지만, 실제로 <code>Some(y)</code> 의 <code>y</code> 는 바깥 scope 에 있는 <code>let y = 10</code> 으로 인식되는 것이 아니라 irrefutable 패턴으로 인식된다. 그래서 <code>x</code> 가 <code>Some(y)</code> 에 매칭된다. </p>
<h3 id="multiple-patterns">Multiple Patterns<a class="headerlink" href="#multiple-patterns" title="Permanent link">¶</a></h3>
<p><code>|</code> 를 사용하여 다중 패턴을 선언할 수 있다. <code>|</code> 는 or 로 사용된다. </p>
<div class="highlight"><pre><span></span><code><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"one or two"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="mi">3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"three"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"anything"</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="matching-ranges-of-values-with">Matching Ranges of Values with ..=<a class="headerlink" href="#matching-ranges-of-values-with" title="Permanent link">¶</a></h3>
<p><code>..=</code> 는 값의 범위를 패턴으로 사용하게 해준다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="mi">1</span><span class="o">..=</span><span class="mi">5</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"one through five"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"something else"</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드의 <code>1..=5</code> 는 <code>1|2|3|4|5</code> 와 같다. <code>..=</code> 문법은 숫자 변수와 <code>char</code> 변에 만 적용된다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">'c'</span><span class="p">;</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="sc">'a'</span><span class="o">..=</span><span class="sc">'j'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"early ASCII letter"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="sc">'k'</span><span class="o">..=</span><span class="sc">'z'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"late ASCII letter"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"something else"</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위와 같이 <code>char</code> 에 적용가능하다.</p>
<h3 id="destructuring-to-break-apart-values">Destructuring to Break Apart Values<a class="headerlink" href="#destructuring-to-break-apart-values" title="Permanent link">¶</a></h3>
<p>패턴은 struct, enum, tuple, reference 의 성분을 참조할 때에도 사용할 수 있다. </p>
<p>다음과 같이 struct 의 성분을 참조할 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">7</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="nc">a</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">b</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p><code>p</code> 의 성분이 패턴을 통하여 <code>a</code> 와 <code>b</code> 로 할당되었다. 이때 다음과 같이 <code>p</code> 의 성분을 변수 <code>x</code> 와 <code>y</code> 로 할당할 수도 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">7</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="nc">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>Rust 는 이러한 경우를 위하여 syntax-sugar 를 제공한다. 다음 코드가 위 코드와 똑같은 기능을 한다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">7</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>이 문법을 <code>match</code> 에서도 사용할 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">7</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"On the x axis at {}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"On the y axis at {}"</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"On neither axis: ({}, {})"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>첫번째 케이스는 <code>x: x</code> 와도 같기 때문에 <code>x</code> 의 모든 값이 매칭되지만 <code>y: 0</code> 로 인하여 <code>y</code> 값이 <code>0</code> 일 때에만 매칭된다. </p>
<h3 id="destructuring-enums">Destructuring Enums<a class="headerlink" href="#destructuring-enums" title="Permanent link">¶</a></h3>
<p>다음과 같이 enum 도 패턴을 사용하여 성분별로 분해할 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">Message</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Quit</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Move</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span> <span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="n">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">ChangeColor</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Message</span>::<span class="n">Quit</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">"The Quit variant has no data to destructure."</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">Message</span>::<span class="n">Move</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="s">"Move in the x direction {} and in the y direction {}"</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">Message</span>::<span class="n">Write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Text message: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="s">"Change the color to red {}, green {}, and blue {}"</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">        </span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>nested struct, enum 도 분해 가능하다. </p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Rgb</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Hsv</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">enum</span> <span class="nc">Message</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Quit</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Move</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span> <span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="n">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">ChangeColor</span><span class="p">(</span><span class="n">Color</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="n">Color</span>::<span class="n">Hsv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="n">Color</span>::<span class="n">Rgb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="s">"Change the color to red {}, green {}, and blue {}"</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">        </span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="n">Color</span>::<span class="n">Hsv</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="s">"Change the color to hue {}, saturation {}, and value {}"</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="w">        </span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="destructuring-structs-and-tuples">Destructuring Structs and Tuples<a class="headerlink" href="#destructuring-structs-and-tuples" title="Permanent link">¶</a></h3>
<p>Struct, tuple, enum 을 더 복잡한 방식으로 혼합시킬 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="p">((</span><span class="n">feet</span><span class="p">,</span><span class="w"> </span><span class="n">inches</span><span class="p">),</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="o">-</span><span class="mi">10</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
</code></pre></div>
<h3 id="_">_ 패턴<a class="headerlink" href="#_" title="Permanent link">¶</a></h3>
<p>_ 패턴은 아무 값이나 매칭되지만 그 값을 할당하지는 않는 패턴이다. _ 패턴은 특히 <code>match</code> 의 마지막 케이스에서 자주 사용되었다. 하지만 _ 패턴은 다음과 같이 함수 파라미터에서도 사용될 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">_</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"This code only uses the y parameter: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드의 <code>foo</code> 는 첫번째 파라미터 <code>3</code> 를 무시한다. </p>
<p>다음과 같이 변수 값이 아닌 변수의 타입을 확인하기 위하여 사용할 수도 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">setting_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">new_setting_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">setting_value</span><span class="p">,</span><span class="w"> </span><span class="n">new_setting_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Can't overwrite an existing customized value"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">setting_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_setting_value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="ignoring-an-unused-variable-by-starting-its-name-with-_">Ignoring an Unused Variable by Starting Its Name with _<a class="headerlink" href="#ignoring-an-unused-variable-by-starting-its-name-with-_" title="Permanent link">¶</a></h3>
<p>Rust 는 버그를 없애기 위하여 사용하지 않는 변수에 대하여 warning 을 해준다. 하지만 프로토타입 프로젝트인 경우 사용하지 않는 변수들이 정의될 수 있다. 이럴 때 변수 이름 앞에 <code>_</code> 를 붙이면 warning 이 안뜬다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>위 코드에서 <code>y</code> 만 warning 이 뜬다.</p>
<p>패턴에서 <code>_</code> 를 사용하는 것은 중요한 차이점이 있다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"Hello!"</span><span class="p">));</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"found a string"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="fm">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>위 코드의 <code>_s</code> 에는 <code>s</code> 가 할당되어 ownership 이 넘어간다. 그런데도 밑에서 <code>s</code> 를 사용하므로 에러가 발생한다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"Hello!"</span><span class="p">));</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"found a string"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="fm">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>하지만 위 코드에서 <code>_</code> 패턴에는 할당이 이루어지지 않으므로 에러가 발생하지 않는다. </p>
<h3 id="ignoring-remaining-parts-of-a-value-with">Ignoring Remaining Parts of a Value with ..<a class="headerlink" href="#ignoring-remaining-parts-of-a-value-with" title="Permanent link">¶</a></h3>
<p><code>_</code> 패턴으로 값을 무시할 수 있지만 만약 성분이 너무 많을 경우 <code>_</code> 를 계속 쓰기가 귀찮다. 이 경우 <code>..</code> 패턴을 사용하면 된다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">z</span>: <span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"x is {}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드의 경우 <code>..</code> 패턴이 <code>y</code> 와 <code>z</code> 를 무시해준다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Some numbers: {}, {}"</span><span class="p">,</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드에서는 <code>2</code> 와 <code>32</code> 를 제외한 가운데 값들을 <code>..</code> 이 무시해준다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">..</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Some numbers: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>하지만 위 코드의 <code>..</code> 들은 그 범위가 모호하므로 Rust 가 에러를 발생시킨다. </p>
<h3 id="extra-conditionals-with-match-guards">Extra Conditionals with Match Guards<a class="headerlink" href="#extra-conditionals-with-match-guards" title="Permanent link">¶</a></h3>
<p>match guard 는 패턴이 매칭된 이후에 추가적인 조건을 삽입하는 것이다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"less than five: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드는 첫번째 케이스를 실행하게 된다. 만약 <code>num = Some(10)</code> 이면 두번째 케이스가 실행된다. </p>
<p>match guard 는 pattern-shadowing 문제를 해결해준다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Got 50"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Matched, n = {}"</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Default case, x = {:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="fm">println!</span><span class="p">(</span><span class="s">"at the end: x = {:?}, y = {}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>위 코드는 세번째 케이스가 실행된다. 두번째 케이스의 match guard 의 <code>y</code> 는 shadowing 된 것이 아니라 <code>let y = 10</code> 의 <code>y</code> 이다. </p>
<p>match guard 는 <code>|</code> 를 사용한 다중 패턴들에도 모두 적용된다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"yes"</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"no"</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드의 <code>if y</code> 라는 match guard 는 <code>4</code>, <code>5</code>, <code>6</code> 모두에 적용된다. </p>
<p>만약 특정 패턴에만 match guard 를 사용하고 싶다면 다음과 같이 하면 된다. </p>
<div class="highlight"><pre><span></span><code><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<h3 id="bindings">@ Bindings<a class="headerlink" href="#bindings" title="Permanent link">¶</a></h3>
<p><code>@</code> 는 변수를 할당함과 동시에 패턴에 매칭되나 테스트할 수 있게 해준다. </p>
<p>다음 코드는 <code>@</code> 를 통하여 <code>id</code> 필드가 <code>3..=7</code> 범위 안에 있는 것을 확인함과 동시에 <code>id_variable</code> 에 값을 할당하는 예시를 보여준다. </p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">Message</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span>: <span class="kt">i32</span> <span class="p">},</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span>::<span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span>: <span class="mi">5</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Message</span>::<span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">id</span>: <span class="nc">id_variable</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">3</span><span class="o">..=</span><span class="mi">7</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Found an id in range: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">id_variable</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Message</span>::<span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span>: <span class="mi">10</span><span class="o">..=</span><span class="mi">12</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Found an id in another range"</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">Message</span>::<span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Found some other id: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<hr/>
<h2 id="advanced-features">Advanced Features<a class="headerlink" href="#advanced-features" title="Permanent link">¶</a></h2>
<p>이 장에서 배우는 것들은 매우 특수한 상황에서 쓰이는 것들이다. </p>
<h2 id="unsafe-rust">Unsafe Rust<a class="headerlink" href="#unsafe-rust" title="Permanent link">¶</a></h2>
<p>지금까지 논의한 Rust 의 기능들은 Rust 가 memory-safe 하다는 것을 컴파일 시에 보장해준다. 하지만 이러한 memory-safe 리미터를 해제할 수 있다. 이것을 unsafe 코드라 한다. 리미터를 해제하는 대신 우리는 더욱 강력한 코드를 작성할 수 있게 된다. </p>
<p>unsafe 가 존재하는 이유는 Rust 의 static analysis 가 기본적으로 보수적인 정책을 취하기 때문이다. 즉, 안전한지 안전하지 않은지 애매한 상황이라면 안전하지 않다고 판단하고 컴파일하지 않는 게 Rust 의 정책이다. </p>
<p>하지만 unsafe 는 이 컴파일러의 보수적인 정책을 해제하고 더 강력한 최적화 등등 더 강력한 코드를 짤 수 있게 해준다. 대신 memory-leak 이나 dangling pointer 같은 여러 취약점이 발생할 수 있다. </p>
<p>unsafe 의 또 다른 목적은 컴퓨터 하드웨어와 운영체제의 low-level 은 본질적으로 unsafe 하기 때문이다. 그래서 unsafe 가 없다면 이 영역의 코드를 짤 수가 없다. 따라서 우리는 unsafe 를 통해 low-level 프로그래밍을 할 수 있다. </p>
<h3 id="unsafe-superpowers">Unsafe Superpowers<a class="headerlink" href="#unsafe-superpowers" title="Permanent link">¶</a></h3>
<p>unsafe 코드를 작성하기 위하여 <code>unsafe</code> 키워드를 쓰고 블록을 만들면 된다. unsafe 안에서 다음과 같은 5 가지 종류의 코드를 짤 수 있는데 이것을 unsafe superpower 라고 한다.</p>
<ul>
<li>
<p>Dereference a raw pointer</p>
</li>
<li>
<p>Call an unsafe function or method</p>
</li>
<li>
<p>Access or modify a mutable static variable</p>
</li>
<li>
<p>Implement an unsafe trait</p>
</li>
<li>
<p>Access files of <code>union</code>s</p>
</li>
</ul>
<p>그러나 <code>unsafe</code> 내부라고 해서 Rust 의 borrow checker 나 다른 safety checker 들이 비활성화되는 것은 아니다. 가령 <code>unsafe</code> 내부에서 reference 를 사용하면 Rust 가 valid 한지 체크한다. <code>unsafe</code> 가 우리에게 주는 것은 단지 위의 5 가지 기능들에 대하여 컴파일러가 memory-safe 체크를 하지 않게 해주는 것이다. 따라서 당신은 <code>unsafe</code> 내부에서도 어느정도의 memory-safe 를 보장받을 수 있다. </p>
<p>또한 이름이 <code>unsafe</code> 라고 해서 내부에 위험하거나 memory-safety 문제가 있는 코드가 있다는 게 아니다. 단지 프로그래머로써 unsafe 코드들이 memory-safe 가 보장받지 못하므로 메모리를 valid 하게 사용하도록 주의하라는 것이다. </p>
<p>따라서 최대한 unsafe 블록을 작게 만들어라. 만약 메모리 버그가 발생했다면 그것을 unsafe 블록에서 찾을 수 있을 것이다. 그때 unsafe 블록을 최대한 작게 만든 자기 자신에게 감사하게 될 것이다. </p>
<p>또한 unsafe 코드를 최대한 고립시키기 위하여 unsafe 코드를 사용하는 safe abstraction 을 만들고 그것을 기반으로 safe API 를 제공하는 것이 좋다. 실제로 Rust 의 standard library 도 unsafe 코드의 safe abstraction 을 제공하는 것이다. 따라서 내부에 unsafe 코드가 있지만 그것을 사용하는 수많은 Rust 코드베이스에서는 safe abstraction 을 사용할 수 있는 것이다. </p>
<p>이제 5 가지의 unsafe superpower 들을 하나씩 살펴보자. </p>
<h3 id="1-dereferencing-a-raw-pointer">1. Dereferencing a Raw Pointer<a class="headerlink" href="#1-dereferencing-a-raw-pointer" title="Permanent link">¶</a></h3>
<p>Rust 는 reference 가 항상 valid 하다는 것을 보장한다. Unsafe Rust 에서는 새로운 reference 타입인 raw pointer 를 제공한다. reference 처럼 raw pointer 는 immutable 이 될 수도 있고 mutable 이 될 수도 있으며, 각각 <code>*const T</code> 와 <code>*mut T</code> 로 쓰일 수 있다. 여기에서 <code>*</code> 는 dereference pointer 가 아니라 타입의 이름이 된다. </p>
<p>reference 나 smart pointer 에 비하여 raw pointer 가 갖는 차이점은 다음과 같다. </p>
<ul>
<li>
<p>immutable 과 mutable 을 동시에 갖거나 여러개의 mutable pointer 를 같은 데이터에 대하여 가짐으로써 borrowing rule 을 무시할 수 있다. </p>
</li>
<li>
<p>valid 한 메모리를 포인팅하고 있다는 것이 보장되지 않는다. </p>
</li>
<li>
<p>null 값을 갖는 것이 허용된다. </p>
</li>
<li>
<p>자동 할당해제가 구현되어 있지 않다. </p>
</li>
</ul>
<p>Rust 가 보장해주는 안정장치를 포기함으로써 raw pointer 를 통하여 더 나은 성능과 더 나은 기능을 코딩할 수 있다. 더 나은 기능이라 함은 다른 언어와의 인터페이스라든가, 하드웨어와의 인터페이스를 코딩할 수 있다는 것이다. </p>
<p>다음은 각각 immutable 한, mutable 한 raw pointer 를 만드는 예시이다. <code>as</code> 키워드로 immutable, mutable reference 를 각각 immutable, mutable raw pointer 로 형변환했다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>이처럼 <code>unsafe</code> 블록 없이도 raw pointer 를 만들 수 있다. 단지 raw pointer 를 dereference 하는 것을 unsafe 바깥에서 할 수 없을 뿐이다. </p>
<p>위 예시는 raw pointer 를 valid 함이 보장된 reference 를 기반으로 만들었으므로 raw pointer 의 valid 함이 보장된다. 그러나 모든 raw pointer 의 valid 가 항상 보장되는 것은 아니다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x012345</span><span class="k">usize</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>위 예시 또한 unsafe 블록 바깥에서 raw pointer 를 만들었지만 절대로 <code>r</code> 을 dereference 할 수는 없다. <code>0x012345</code> 주소에 무엇이 있을 줄 알고 dereference 를 해서 읽거나 쓴단 말인가. 또한 이 주소가 valid 하다는 것 또한 보장되지 않는다. </p>
<p>dereference 는 다음과 같이 valid 한 raw pointer 에 대하여 unsafe 블록 안에서만 가능하다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"r1 is: {}"</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">r1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"r2 is: {}"</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">r2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>raw pointer 는 위와 같이 immutable, mutable pointer 를 같이 만들 수 있어서 data race 를 주의해야 한다. </p>
<p>그러나 이러한 위험에도 불구하고 raw pointer 를 사용해야 하는 가장 큰 이유 중 하나는 C 언어와의 인터페이스를 만들기 위함이다. </p>
<p>또 다른 이유는 borrow checker 가 이해하지 못하는 unsafe 위의 safe abstraction 을 만들기 위함이다. </p>
<h3 id="2-calling-an-unsafe-function-or-method">2. Calling an Unsafe Function or Method<a class="headerlink" href="#2-calling-an-unsafe-function-or-method" title="Permanent link">¶</a></h3>
<p>unsafe 함수나 메소드를 사용하려면 <code>unsafe</code> 블록 안에서만 가능하다. unsafe 함수나 메소드란 함수 몸체 자체가 unsafe 블록인 함수이다. </p>
<div class="highlight"><pre><span></span><code><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dangerous</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">dangerous</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드는 unsafe 함수를 선언하고 그것을 호출하고 있다. 이처럼 unsafe 함수는 반드시 unsafe 블록 안에서만 사용가능하다. unsafe 함수 내부는 unsafe 블록과 같기 때문에 unsafe 함수 내부에서 또 다시 unsafe 블록을 선언할 필요가 없다. </p>
<p>그러나 함수가 unsafe 코드를 포함한다고 해서 함수 전체를 unsafe 로 규정해야 하는 것은 아니다. unsafe 코드를 사용하는 함수를 safe 함수로 abstract 할 수 있다. </p>
<p>가령 표준라이브러리의 <code>split_at_mut</code> 함수는 다음과 같이 mutable reference 를 split 해준다.</p>
<p></p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="o">..</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]);</span><span class="w"></span>
</code></pre></div>
이것을 직접 구현해보자. 하지만 이 함수를 safe 코드만으로는 구현할 수 없다.
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">split_at_mut</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">mid</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">mid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">slice</span><span class="p">[</span><span class="o">..</span><span class="n">mid</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">slice</span><span class="p">[</span><span class="n">mid</span><span class="o">..</span><span class="p">])</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드는 safe 코드만으로 split_at_mut 함수를 구현해본 건데 에러가 발생한다. mutable reference 를 2개나 만들었기 때문에 borrow rule 에 위배되기 때문이다. </p>
<p>Rust 가 이 에러를 발생시키는 이유는 mutable reference 가 동일한 부분의 데이터를 slice 했을 수도 있기 때문이다. 하지만 우리는 2개의 mutable reference 들이 서로 다른 파트를 slice 했다는 것을 안다. 그러나 Rust 는 이것을 판단할만큼 똑똑하지 못하다. 그러므로 다음과 같이 unsafe 코드를 사용할 때이다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">split_at_mut</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">mid</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">mid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">mid</span><span class="p">),</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mid</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이렇게 구현된 split_at_mut 함수는 unsafe 로 정의할 필요 없다. safe abstraction 이 만들어졌기 때문이다.</p>
<p>unsafe 블록은 다른 프로그래밍 언어에서 정의된 함수를 사용할 때도 쓰인다. 이때 <code>extern</code> 키워드에 <code>"C"</code> 를 붙히면 C 표준 라이브러리를 사용한다는 것이고 함수 선언을 가져오면 unsafe 블록에서 함수를 사용할 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">abs</span><span class="p">(</span><span class="n">input</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Absolute value of -3 according to C: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>extern 블록의 함수들은 반드시 unsafe 블록에서 사용되어야 하는데, 이는 다른 프로그래밍 언어들이 Rust 의 규칙을 따른다는 보장이 없기 때문이다.</p>
<p><code>"C"</code> 란 어떤 ABI(application binary interface) 를 통해 외부 함수를 사용할지 선언하는 부분이다. 즉, ABI 는 어셈블리 레벨에서 어떻게 함수를 호출할지 정의해준다. <code>"C"</code> ABI 가 가장 많이 쓰이고 C 언어 의 ABI 를 따른다.</p>
<p><code>extern</code> 키워드는 외부 인터페이스를 Rust 로 끌어들어오는 것뿐만 아니라 Rust 의 함수를 외부 인터페이스에서 사용할 수 있게 해준다. 이렇게 하려면 <code>extern</code> 블록 대신에 <code>fn</code> 키워드 앞에 <code>extern</code> 을 붙히고, <code>#[no_mangle]</code> annotation 을 단다. Mangling 이란 컴파일러가 우리가 함수에 붙힌 이름을 더 많은 정보를 포함시켜서 바꿔버리는 과정이다. 모든 컴파일러는 Mangling 을 조금씩 다르게 하므로 Rust 의 Mangling 을 비활성화시켜야 하는 것이다. 다음 예시를 보자.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[no_mangle]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">"C"</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_from_c</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Just called a Rust function from C!"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 함수는 shared library 로 컴파일하여 C 에서 링킹되면 <code>C</code> 언어에서 사용할 수 있다. 이런 형태의 <code>extern</code> 은 <code>unsafe</code> 가 필요없다.</p>
<h3 id="3-access-or-modify-a-mutable-static-variable">3. Access or modify a mutable static variable<a class="headerlink" href="#3-access-or-modify-a-mutable-static-variable" title="Permanent link">¶</a></h3>
<p>Rust 는 전역변수를 지원하지 않는다. Rust 의 ownership 에 위배될 가능성이 크기 때문이다. 가령 두 스레드가 하나의 mutable 전역변수에 접근하면 data race 가 생길 것이다.</p>
<p>일단 Rust 는 global variable(전역변수)를 static variable 이라 부른다. 다음 예시는 static variable 을 사용하는 예를 보여준다.</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">HELLO_WORLD</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">"Hello, world!"</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"name is: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">HELLO_WORLD</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 예시의 타입은 <code>&amp;'static str</code> 이다. static variable 은 반드시 <code>'static</code> lifetime 을 갖는다.</p>
<p>static variable 은 <code>const MAX_POINTS: u32 = 100_000;</code> 와 같이 정의되는 상수와 비슷하다. 하지만 다른점은 static variable 은 고정된 주소의 메모리에 저장된다는 것이다. 이는 static variable 을 사용하면 항상 같은 데이터에 접근하게 됨을 뜻한다. 반면 상수는 그것의 데이터를 언제든 복사할 수 있다. </p>
<p>상수와 static variable 의 또 다른 차이점은 static variable 이 mutable 하다는 것이다. 그러나 mutable static variable 에 접근하고 그것을 수정하는 것은 unsafe 하다. 다음 예시를 보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">COUNTER</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">add_to_count</span><span class="p">(</span><span class="n">inc</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">COUNTER</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">inc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">add_to_count</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"COUNTER: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">COUNTER</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>지금은 싱글 스레드가 <code>COUNTER</code> 에 접근하지만 여러 스레드가 접근하면 data race 가 발생할 수도 있다. Rust 가 mutable static variable 을 unsafe 블록 안에 넣는 이유가 data race 때문이다. 따라서 가능하면 thread-safe 한 smart pointer 를 사용해야 한다.</p>
<h3 id="4-implement-an-unsafe-trait">4. Implement an unsafe trait<a class="headerlink" href="#4-implement-an-unsafe-trait" title="Permanent link">¶</a></h3>
<p><code>unsafe</code> 의 또 다른 사용예는 unsafe trait 를 구현할 때이다. unsafe trait 란 하나 이상의 Method 가 컴파일러가 검증할 수 없는 특징을 가지는 trait 이다. unsafe trait 는 다음과 같이 정의할 수 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">unsafe</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// methods go here</span>
<span class="p">}</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// method implementations go here</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>unsafe impl</code> 을 통하여 우리는 컴파일러가 검증할 수 없는 특징을 유지할 것을 약속하게 된다.</p>
<h3 id="5-access-files-of-unions">5. Access files of <code>union</code>s<a class="headerlink" href="#5-access-files-of-unions" title="Permanent link">¶</a></h3>
<p><code>union</code> 의 필드에 접근하는 것은 unsafe 하다. union 은 Rust tutorial 에서 다루지 않으므로 다음의 Rust reference 를 참조하자.</p>
<p><a href="https://doc.rust-lang.org/reference/items/unions.html">https://doc.rust-lang.org/reference/items/unions.html</a></p>
<hr/>
<h2 id="advanced-traits">Advanced Traits<a class="headerlink" href="#advanced-traits" title="Permanent link">¶</a></h2>
<h2 id="specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types<a class="headerlink" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types" title="Permanent link">¶</a></h2>
<p>Associated type 은 trait 과 type placegholer 를 연결한다. </p>
<p>associated type 의 예시는 <code>Iterator</code> 의 <code>Item</code> 이다.</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>Item</code> 은 Placeholder type 이고, <code>next</code> 의 <code>Self::Item</code> 에서 사용된다. Trait 를 구현할 때 다음과 같이 이 Placeholder type 이 구체적인 type 이 된다. </p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Counter</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">count</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// --snip--</span>
</code></pre></div>
<p>그래서 Placeholder type 은 마치 generic 같다. 그러면 왜 generic 대신 associated type 을 사용할까? </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위와 같은 generic 을 정의하면 각각의 구현마다 다른 type 으로 구현이 가능하다. </p>
<p>즉, 우리는 <code>Iterator&lt;String&gt; for Counter</code> 나 여타 다른 type 에 대하여 Counter 를 구현할 수 있다.</p>
<p>하지만 associated type 에서는 type 지정을 한번만 할 수 있다. 따라서 </p>
<h3 id="default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading<a class="headerlink" href="#default-generic-type-parameters-and-operator-overloading" title="Permanent link">¶</a></h3>
<p>Generic type 을 사용할 때 default type 을 지정할 수 있다. 형식은 <code>&lt;PlaceholderType=ConcreteType&gt;</code> 이다. </p>
<p>이것이 유용하게 사용되는 예시는 연산자 오버로딩이다. 연산자 오버로딩은 <code>+</code> 같은 연산자를 커스터마이징한다. Rust 는 <code>std::ops</code> 에 있는 연산자를 커스터마이징 하도록 허용한다. 다음은 <code>+</code> 를 커스터마이징 한 예시이다.</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[derive(Debug, PartialEq)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">3</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">3</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>Add</code> trait 는 다음과 같이 default generic type 을 갖는다.</p>
<div class="highlight"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">=</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>Rhs</code> 가 default generic type 인데 위 구현에서 <code>Rhs</code> 의 특정한 타입을 구체화시키지 않았는데도 구현이 되었었다. <code>Self</code> 로 자동으로 구체화가 되었기 때문이다. <code>Self</code> 는 <code>Add</code> 가 구현될 타입이다. </p>
<p>default generic type 을 구체화시킨 예시는 다음과 같다. </p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Millimeters</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Meters</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Meters</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Millimeters</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Millimeters</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Meters</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Millimeters</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Millimeters</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 예시는 <code>Rhs</code> 의 디폴트인 <code>Self</code> 를 <code>Meters</code> 로 바꿨다. </p>
<h3 id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name<a class="headerlink" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name" title="Permanent link">¶</a></h3>
<p>Rust 는 같은 이름을 가진 Method 를 구현하는 것을 금지하지는 않는다. 다음 코드를 보자. </p>
<div class="highlight"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">Pilot</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Human</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Pilot</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"This is your captain speaking."</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Up!"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"*waving arms furiously*"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>fly</code> 라는 메소드가 3개나 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">person</span><span class="p">.</span><span class="n">fly</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 경우 위와 같이 호출한다면 trait 의 method 가 아닌 본체 메소드를 호출하게 된다. trait 의 메소드를 호출하고 싶다면 다음과 같이 하면 된다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Pilot</span>::<span class="n">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Wizard</span>::<span class="n">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">person</span><span class="p">.</span><span class="n">fly</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이는 <code>fly</code> 메소드들이 <code>self</code> 를 파라미터로 받기에 가능한데, 만약 <code>self</code> 를 파라미터로 받지 않는다면 메소드 구분이 불가능하게 된다.</p>
<div class="highlight"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Dog</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"Spot"</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">baby_name</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"puppy"</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span><span class="w"> </span><span class="n">Dog</span>::<span class="n">baby_name</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 코드의 경우 <code>self</code> 를 파라미터로 받지 않기에 메소드 구분이 불가능하다. 이럴 때 다음과 같이 구분해야 한다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"A baby dog is called a {}"</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Dog</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Animal</span><span class="o">&gt;</span>::<span class="n">baby_name</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이 문법을 fully qualified syntax 라고 하며 문법은 다음과 같다. </p>
<div class="highlight"><pre><span></span><code><span class="o">&lt;</span><span class="n">Type</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span>::<span class="n">function</span><span class="p">(</span><span class="n">receiver_if_method</span><span class="p">,</span><span class="w"> </span><span class="n">next_arg</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.);</span><span class="w"></span>
</code></pre></div>
<p>사실 우리는 이 fully qualified syntax 를 매번 축약하여 사용했던 것인데, Rust 가 알아서 구분해줬던 것이다. </p>
<h3 id="using-supertraits-to-require-one-traits-functionality-within-another-trait">Using Supertraits to Require One Trait’s Functionality Within Another Trait<a class="headerlink" href="#using-supertraits-to-require-one-traits-functionality-within-another-trait" title="Permanent link">¶</a></h3>
<p>특정 trait 를 구현한 struct 만 해당 trait 를 구현해야 할 때 다음 문법을 사용한다. </p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">OutlinePrint</span>: <span class="nc">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">outline_print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="s">"*"</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"*{}*"</span><span class="p">,</span><span class="w"> </span><span class="s">" "</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"* {} *"</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"*{}*"</span><span class="p">,</span><span class="w"> </span><span class="s">" "</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="s">"*"</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>위 예시는 <code>OutlinePrint</code> triat 가 반드시 <code>Display</code> trait 를 구현한 Struct 만 구현해야한다는 문법을 보여준다. <code>trait OutlinePrint: fmt::Display</code> 이렇게 하면된다.</p>
<h3 id="using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types<a class="headerlink" href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types" title="Permanent link">¶</a></h3>
<p>orphan rule 은 trait 를 구현하려면 trait 나 type 이 로컬 crate 내부에 있어야 한다는 규칙이다. 이 규칙을 newtype pattern 으로 우회할 수 있다. 이는 tuple struct 를 type 의 Wrapper 로 사용하는 것이다. Wrapper type 으로 성능이 전혀 떨어지지 않으면 컴파일 시 Wrapper 가 생략된다. </p>
<p>가령 <code>Vec&lt;T&gt;</code> 에 <code>Display</code> 를 정의하고 싶지만 둘 다 외부 crate 에 정의되어 있어서 할 수가 없다. 그래서 다음과 같이 tuple struct 로 Wrapping 을 하면 된다.</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Wrapper</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wrapper</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">"[{}]"</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">join</span><span class="p">(</span><span class="s">", "</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Wrapper</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"world"</span><span class="p">)]);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"w = {}"</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="using-the-newtype-pattern-for-type-safety-and-abstraction">Using the Newtype Pattern for Type Safety and Abstraction<a class="headerlink" href="#using-the-newtype-pattern-for-type-safety-and-abstraction" title="Permanent link">¶</a></h3>
<p>newtype pattern 으로 내부 구현을 숨길 수도 있다. 가령 <code>HashMap&lt;i32, String&gt;</code> 을 <code>People</code> tuple struct 로 wrapping 할 수 있다.</p>
<h3 id="creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases<a class="headerlink" href="#creating-type-synonyms-with-type-aliases" title="Permanent link">¶</a></h3>
<p>다음과 같이 type alias 를 만들 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="nc">Kilometers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="nc">Kilometers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="fm">println!</span><span class="p">(</span><span class="s">"x + y = {}"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p><code>x, y</code> 는 같은 타입이다. 하지만 이 방법은 newtype pattern 이 주는 타입 검사 효능을 얻지 못한다. 이 방법은 다음과 같이 긴 타입을 단축하는데 주로 쓰인다.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="nc">Thunk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">'</span><span class="nb">static</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>이는 가독성을 높일 뿐더러 코딩할 때도 편하다. 따라서 에러가 줄어들고 코드의 의미가 풍부해진다. <code>Result&lt;T, E&gt;</code> 가 너무 길기 때문에 다음과 같이 사용될 때도 있다.</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w"></span>

<span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">write_fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="nc">fmt</span>::<span class="n">Arguments</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="the-never-type-that-never-returns">The Never Type that Never Returns<a class="headerlink" href="#the-never-type-that-never-returns" title="Permanent link">¶</a></h3>
<p>never type 은 다음과 같이 반환하지 않는 타입이다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the Sized Trait<a class="headerlink" href="#dynamically-sized-types-and-the-sized-trait" title="Permanent link">¶</a></h3>
<p>dynamically sized type 은 DST 또는 unsized type 이라고도 하는데 변수의 크기가 런타임에서 결정되는 타입이다. </p>
<p><code>str</code> 이 DST 의 예시이다. 우리는 <code>str</code> 의 크기를 런타임이 될때까지 모르기 때문에 그것을 생성할 수도 없고 파라미터로 쓸 수도 없다. 즉, 다음 코드는 에러이다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">s1</span>: <span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">"Hello there!"</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">s2</span>: <span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">"How's it going?"</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>Rust 는 타입의 사이즈를 알고 할당해야 하며, 타입마다 사이즈는 같아야만 한다. <code>str</code> 변수를 생성할 수 있게 되면 위 변수들의 사이즈가 통일된다. 하지만 <code>s1</code> 은 12바이트가 필요하고 <code>s2</code> 는 15바이트가 필요하다. 그래서 <code>str</code> 을 직접 만드는 것이 허용되지 않는다.</p>
<p>그렇기에 지금까지 <code>&amp;str</code> 을 만들어왔던 것이다. <code>&amp;str</code> 은 데이터의 주소값과 길이를 저장하므로 사이즈가 고정되어있다.</p>
<p>사실 이 방식이 DST 타입이 사용되는 방식이다.</p>
<p><code>str</code> 은 <code>Box&lt;str&gt;</code> 이나 <code>Rc&lt;str&gt;</code> 같은 포인터와 연동될 수도 있다.</p>
<p>triat 로 polymorphism 을 구현한 코드를 기억해보면, trait 도 사실 DST 임을 알 수 있다. 그때 우리는 <code>&amp;dyn Trait</code> 나 <code>Box&lt;dyn Trait&gt;</code> 같은 걸 썼다. trait 구현체가 달라질 때마다 사이즈가 달라지는 DST 이므로 이렇게 쓴 것이다.</p>
<p>DST 를 사용하기 위해서는 <code>Sized</code> 라는 trait 를 알아야 한다. 이것은 특정 타입의 사이즈가 컴파일 상에서 알 수 있는지 없는지 판단한다. 이 trait 는 컴파일 시에 사이즈를 알 수 있는 모든 타입에 자동으로 구현된다. 또한 Rust 는 모든 generic 함수에 이 trait bound 를 자동으로 추가한다. 그래서 사실 다음과 같은 generic 함수는 </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>다음의 축약이었던 것이다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>generic 함수는 일반적으로 <code>Sized</code> 가 있는 타입에서만 정의되지만 다음과 같이 선언할 수도 있다. </p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>?Sized</code> 는 <code>T</code> 의 사이즈를 컴파일 시에 알수도 있고 알수 없을 수도 있다는 것이다. 이때 <code>T</code> 도 <code>&amp;T</code> 로 바꾸었음을 주목하자. 만약 <code>T</code> 가 <code>Sized</code> 가 아니라면 pointer 로 사용해야 하기 때문에 reference 로 바꾸어야 하는 것이다.</p>
<hr/>
<h2 id="advanced-functions-and-closures">Advanced Functions and Closures<a class="headerlink" href="#advanced-functions-and-closures" title="Permanent link">¶</a></h2>
<h2 id="function-pointers">Function Pointers<a class="headerlink" href="#function-pointers" title="Permanent link">¶</a></h2>
<p>함수에 closure 를 전달하는 법을 배웠는데, C언어 처럼 함수 포인터도 전달할 수 있다. 이 방식은 이미 정의된 함수들이 있을 때 굳이 closure 를 전달하는 게 아니라 기존의 함수들을 파라미터로 전달할 때 유용하다. 함수 포인터의 타입은 <code>fn</code> 이다. 다음 예시를 보자.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">f</span>: <span class="nc">fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_twice</span><span class="p">(</span><span class="n">add_one</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"The answer is: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">answer</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>함수 포인터는 closure trait <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code> 가 모두 구현되어 있어서 closure 파라미터에 전달 가능하다.</p>
<p>closure 가 아니라 오직 <code>fn</code> 만 파라미터로 받아야 하는 경우의 한 가지 예시는 closure 를 갖지 않는 외부 코드와의 인터페이스에서 이다. 가령 C 언어 함수와 인터페이스를 할 때 closure 를 파라미터로 넘기면 안되고 함수 포인터를 넘겨야 한다.</p>
<p>closure 나 함수를 사용할 수 있는 예시 중 하나는 <code>map</code> 이다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">list_of_numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">list_of_strings</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">list_of_numbers</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">to_string</span><span class="p">()).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</code></pre></div>
<p>위의 <code>map</code> 에서는 closure 를 사용했고 다음은 함수를 사용했다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">list_of_numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">list_of_strings</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">list_of_numbers</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="nb">ToString</span>::<span class="n">to_string</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</code></pre></div>
<p>다음과 같이 tuple struct 를 사용하는 패턴도 있다. initializer 를 함수 포인터처럼 map 에 전달하여 enum instance 를 반환하게 하는 패턴이다.</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="nc">Status</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Value</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Stop</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">list_of_statuses</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Status</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="k">u32</span><span class="o">..</span><span class="mi">20</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">Status</span>::<span class="n">Value</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</code></pre></div>
<h3 id="returning-closures">Returning Closures<a class="headerlink" href="#returning-closures" title="Permanent link">¶</a></h3>
<p>closure 는 trait 로 표현되므로 closure 를 직접 반환할 수는 없다. 많은 경우 trait 를 반환하기 위하여 trait 를 구현한 특정 타입을 반환해야 한다. </p>
<p>그러나 closure 에서는 이런 방법을 쓸 수 없다. 또한 함수 포인터 <code>fn</code> 를 직접 반환하는 것은 허용되지 않는다. 다음 코드는 에러이다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>어떤 에러냐면 <code>Sized</code> 가 구현되지 않은 DST 를 다루고 있다는 에러다. 그러므로 다음과 같이 코드를 수정하면 된다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<hr/>
<h2 id="macros">Macros<a class="headerlink" href="#macros" title="Permanent link">¶</a></h2>
<p>매크로는 <code>println!</code> 같은 것들이다. 매크로는 <code>macro_rules!</code> 의 declarative 매크로와 다음의 procedural 매크로를 뜻한다.</p>
<ul>
<li>
<p>커스텀 <code>#[derive]</code> 매크로</p>
</li>
<li>
<p>Attribute-like 매크로</p>
</li>
<li>
<p>Function-like 매크로</p>
</li>
</ul>
<p>이 매크로들을 살펴볼 것인데 먼저 왜 매크로가 필요하지 알아보자. </p>
<h3 id="the-difference-between-macros-and-functions">The Difference Between Macros and Functions<a class="headerlink" href="#the-difference-between-macros-and-functions" title="Permanent link">¶</a></h3>
<p>매크로란 근본적으로 어떤 코드를 쓰는 코드를 쓰는 방식이다. 이를 메타프로그래밍이라한다. 메타프로그래밍은 많은 양의 코드를 줄여준다. </p>
<p>그러나 매크로는 이런 특징 외에 함수가 갖지 못하는 중요한 특징을 갖는다. 함수 선언은 특정 수의 파라미터와 타입을 갖는데 비해 매크로는 다양한 파라미터를 가질 수 있다.</p>
<h3 id="declarative-macros-with-macro_rules-for-general-metaprogramming">Declarative Macros with macro_rules! for General Metaprogramming<a class="headerlink" href="#declarative-macros-with-macro_rules-for-general-metaprogramming" title="Permanent link">¶</a></h3>
<p>declarative 매크로는 <code>macro_rules!</code> 를 통해 정의된다. 다음과 같은 매크로로 벡터를 만들 수 있었다. </p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
</code></pre></div>
<p>이 매크로 <code>vec!</code> 는 다음과 같이 정의된다. </p>
<div class="highlight"><pre><span></span><code><span class="cp">#[macro_export]</span><span class="w"></span>
<span class="fm">macro_rules!</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">temp_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="cp">$(</span><span class="w"></span>
<span class="w">                </span><span class="n">temp_vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="cp">$x</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">)</span><span class="o">*</span><span class="w"></span>
<span class="w">            </span><span class="n">temp_vec</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>먼저 <code>#[macro_export]</code> 는 이 매크로가 정의된 crate 가 scope 안으로 들어오면 만드는 게 가능해야 한다는 것을 뜻한다. 이것이 없으면 매크로가 scope 안으로 들어오지 못한다. </p>
<p><code>macro_rules!</code> 는 매크로의 정의의 시작을 뜻한다. </p>
<p>매크로 정의의 몸체는 마치 <code>match</code> 와 비슷하다. 이 경우 <code>( $( $x:expr ),* )</code> 이라는 하나의 arm 밖에 없다. <code>=&gt;</code> 는 이 패턴이 매칭되었을 때 실행될 코드의 시작을 뜻한다. </p>
<p>매크로의 모든 패턴 문법은 레퍼런스 <a href="https://doc.rust-lang.org/reference/macros-by-example.html">https://doc.rust-lang.org/reference/macros-by-example.html</a>  를 확인하자.</p>
<p>이제 패턴 <code>( $( $x:expr ),* )</code> 을 분석해본다. 괄호 <code>( )</code> 는 모든 패턴을 감싸준다. <code>$</code> 와 그 이후에 있는 괄호 즉, <code>$( )</code> 는 괄호 안에 있는 패턴에 매칭되는 값을 캡처하고 코드로 바꿔준다. <code>$x:expr</code> 은 모든 Rust 의 expression 과 매칭되고 그것에 <code>$x</code> 라는 이름을 준다. <code>$( )</code> 이후의 <code>,</code> 는 컴마 <code>,</code> 가 나타날 수도 있음을 뜻한다. <code>*</code> 는 그 앞에 있는 패턴이 0번 이상 반복된다는 것을 뜻한다.</p>
<p>따라서 <code>vec![1, 2, 3]</code> 이라고 쓰면 <code>$x</code> 는 expression <code>1</code>, <code>2</code>, 그리고 <code>3</code> 에 3번 매칭된다. </p>
<p>이후에 코드 본체에 있는 <code>$( )</code> 안에는 <code>temp_vec.push($x)</code> 가 있다. 이 코드는 패턴이 몇 번 매칭되는지에 따라 자동으로 생성된다. 따라서 <code>vec![1, 2, 3]</code> 은 다음과 같아진다.</p>
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">temp_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">temp_vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">temp_vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">temp_vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">temp_vec</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>사실 <code>macro_rules!</code> 에는 몇가지 이상한 부분이 존재하기에, 이후에 Rust 는 declarative 매크로를 대신하는 새로운 매크로를 만들 것이다. 그때가 되면 <code>macro_rules!</code> 은 deprecated 될 것이다. </p>
<h3 id="procedural-macros-for-generating-code-from-attributes">Procedural Macros for Generating Code from Attributes<a class="headerlink" href="#procedural-macros-for-generating-code-from-attributes" title="Permanent link">¶</a></h3>
<p>매크로의 두번째 형태는 procedural 매크로이다. 이 매크로는 함수와 비슷한데, 코드를 입력으로 받고 코드를 출력한다. 이 매크로의 종류에는 custom derive, attribute-like, function-like 이 있다.</p>
<p>procedural 매크로를 정의할 때 반드시 그 정의가 자기 자신의 crate 에 있어야 하고 그 crate 는 특별한 타입이어야 한다. 이는 복잡한 기술적 문제 때문이고, Rust 는 이 문제를 이후에 해결할 예정이다. </p>
<p>procedural 매크로는 다음과 같이 정의한다.</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">proc_macro</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[some_attribute]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">some_name</span><span class="p">(</span><span class="n">input</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>함수가 <code>TokenStream</code> 을 입력받고 동일한 타입을 출력한다. <code>TokenStream</code> 은 <code>proc_macro</code> 에 포함되어 있다. 이 함수는 attribute 도 붙힐 수가 있다.</p>
<p>이제 다음과 같은 procedural 매크로를 알아본다.</p>
<ul>
<li>
<p>커스텀 <code>#[derive]</code> 매크로</p>
</li>
<li>
<p>Attribute-like 매크로</p>
</li>
<li>
<p>Function-like 매크로</p>
</li>
</ul>
<h3 id="how-to-write-a-custom-derive-macro">How to Write a Custom derive Macro<a class="headerlink" href="#how-to-write-a-custom-derive-macro" title="Permanent link">¶</a></h3>
<p><code>hello_macro</code> 라는 crate 를 만들고 <code>HelloMacro</code> 라는 trait 를 만들자. 이 trait 는 <code>hello_macro</code> 라는 asscoicated 함수를 갖는다. 이 crate 의 사용자가 다른 타입을 위하여 <code>HelloMacro</code> trait 를 구현하기 보다는 그들의 타입에 <code>#[derive(HelloMacro)]</code> 라는 주석을 달 수 있는 procedural 매크로를 제공하고 싶다. 이로써 <code>hello_macro</code> 의 디폴트 구현을 제공하는 것이다. 즉, 다음과 같은 기능을 제공하고 싶다.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[derive(HelloMacro)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Pancakes</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Pancakes</span>::<span class="n">hello_macro</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>즉, 다음과 같은 trait 를 </p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">HelloMacro</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>다음과 같이 구현할 필요 없게끔 만들어보자.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Pancakes</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">HelloMacro</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pancakes</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Hello, Macro! My name is Pancakes!"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Pancakes</span>::<span class="n">hello_macro</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이미 언급했듯이, 기술적인 문제 때문에 procedural 매크로는 자기 자신만의 crate 가 필요하다. 이 제한을 해결하려고 Rust 팀이 노력 중이며 나중에는 이 제한이 사라질 것이다. 그래서 위와 같은 <code>main</code> 함수 코드나 라이브러리 코드와는 전혀 다른 새로운 crate 를 만들어야 한다. 일단은, procedural 매크로에 대한 crate 컨벤션은 crate 이름이 <code>foo</code> 라면 procedural 매크로의 crate 는 <code>foo_derive</code> 가 되어야 한다는 것이다. 그러므로 위의 crate <code>hello_macro</code> 와 독립적인 crate 인 <code>hello_macro_derive</code> 를 만들자. </p>
<p>procedural 전용 crate 의 Cargo.toml 에는 다음과 같은 설정이 필요하다. </p>
<div class="highlight"><pre><span></span><code><span class="k">[lib]</span>
<span class="n">proc-macro</span> <span class="o">=</span> <span class="kc">true</span>

<span class="k">[dependencies]</span>
<span class="n">syn</span> <span class="o">=</span> <span class="s">"1.0"</span>
<span class="n">quote</span> <span class="o">=</span> <span class="s">"1.0"</span>
</code></pre></div>
<p>그리고 다음의 코드를 src/lib.rs 에 선언하면 procedural 매크로가 정의된다.</p>
<div class="highlight"><pre><span></span><code><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">proc_macro</span><span class="p">;</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">proc_macro</span>::<span class="n">TokenStream</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">quote</span>::<span class="n">quote</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">syn</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[proc_macro_derive(HelloMacro)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">hello_macro_derive</span><span class="p">(</span><span class="n">input</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Construct a representation of Rust code as a syntax tree</span>
<span class="w">    </span><span class="c1">// that we can manipulate</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syn</span>::<span class="n">parse</span><span class="p">(</span><span class="n">input</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Build the trait implementation</span>
<span class="w">    </span><span class="n">impl_hello_macro</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ast</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이제 반환될 <code>impl_hello_macro</code> 함수를 정의해보자. 위 코드는 <code>TokenStream</code> 을 파싱하는 <code>hello_macro_derive</code> 함수와 syntax tree 을 변환할 <code>impl_hello_macro</code> 함수를 분리하였다. 이 구조가 편하다.</p>
<p><code>proc_macro</code> 는 Rust 자체에서 온 것이며, Rust 코드를 다룰 수 있게 해주는 컴파일러 API 이다. <code>syn</code> 은 string 을 파싱하여 데이터 구조로 바꿔준다. <code>quote</code> 는 <code>syn</code> 의 데이터 구조를 Rust 코드로 분해해준다.</p>
<p><code>hello_macro_derive</code> 함수는 사용자가 타입에 <code>#[derive(HelloMacro)]</code> 주석을 붙히면 호출된다. 이는 우리가 <code>hello_macro_derive</code> 함수에 <code>proc_macro_derive</code> 를 <code>HelloMacro</code> 이름과 함께 붙혔기 때문에 가능하다.</p>
<p><code>syn::parse</code> 함수가 입력된 <code>TokenStream</code> 을 받고 <code>DeriveInput</code> 데이터구조로 변환해준다. 이 데이터구조는 파싱된 Rust 코드이다.</p>
<p>이때 함수의 출력도 <code>TokenStream</code> 이다. 반환된 <code>TokenStream</code> 은 이 crate 사용자의 코드에 추가되므로 <code>TokenStream</code> 을 수정할 기능을 제공해야 한다. </p>
<p><code>unwrap</code> 을 사용하는 이유는 procedural 매크로 API 자체가 반드시 <code>TokenStream</code> 을 반환해야 하고 <code>Reulst&lt;T, E&gt;</code> 를 반환하면 안되기 때문이다. 현실에서는 <code>unwrap</code> 이 아닌 <code>panic!</code> 을 동반한 여러 에러코드 로직을 사용해야 할 것이다. </p>
<p><code>DeriveInput</code> Struct 는 다음과 같이 구성되어 있다.</p>
<div class="highlight"><pre><span></span><code><span class="n">DeriveInput</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// --snip--</span>

<span class="w">    </span><span class="n">ident</span>: <span class="nc">Ident</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ident</span>: <span class="s">"Pancakes"</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">span</span>: #<span class="mi">0</span><span class="w"> </span><span class="n">bytes</span><span class="p">(</span><span class="mi">95</span><span class="o">..</span><span class="mi">103</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span>: <span class="nc">Struct</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">DataStruct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">struct_token</span>: <span class="nc">Struct</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">fields</span>: <span class="nc">Unit</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">semi_token</span>: <span class="nb">Some</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">Semi</span><span class="w"></span>
<span class="w">            </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>이를 기반으로 <code>impl_hello_macro</code> 는 다음과 같이 구현한다.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">impl_hello_macro</span><span class="p">(</span><span class="n">ast</span>: <span class="kp">&amp;</span><span class="nc">syn</span>::<span class="n">DeriveInput</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">.</span><span class="n">ident</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">gen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quote</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="n">HelloMacro</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>#<span class="n">name</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">hello_macro</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Hello, Macro! My name is {}!"</span><span class="p">,</span><span class="w"> </span><span class="fm">stringify!</span><span class="p">(</span>#<span class="n">name</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">gen</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>Ident</code> struct 는 <code>ident</code> 필드에서 이름을 제공해준다. <code>quote!</code> 매크로는 반환할 Rust 코드를 정의하게 해준다. 이것을 <code>TokenStream</code> 으로 변환하기 위하여 <code>into</code> 메소드를 사용한다. <code>quote!</code> 매크로는 <code>#name</code> 을 <code>name</code> 의 값으로 치환해준다. <code>quote</code> crate 의 문서에서 더 많은 기능을 알 수 있다.</p>
<p><code>stringify!</code> 매크로는 Rust expression 을 받아서 string 으로 변환해준다. 가령 <code>1+2</code> 를 <code>"1+2"</code> 로 변환한다.</p>
<p>이제 새로운 crate pancakes 를 만들어서 Cargo.toml 에 다음과 같은 의존성을 추가하자.</p>
<div class="highlight"><pre><span></span><code><span class="k">[dependencies]</span>
<span class="n">hello_macro</span> <span class="o">=</span> <span class="p">{</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"../hello_macro"</span> <span class="p">}</span>
<span class="n">hello_macro_derive</span> <span class="o">=</span> <span class="p">{</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"../hello_macro/hello_macro_derive"</span> <span class="p">}</span>
</code></pre></div>
<p>이렇게 하면 원래의 코드였던 </p>
<div class="highlight"><pre><span></span><code><span class="cp">#[derive(HelloMacro)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Pancakes</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Pancakes</span>::<span class="n">hello_macro</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>가 드디어 실행된다.</p>
<h3 id="attribute-like-macros">Attribute-like macros<a class="headerlink" href="#attribute-like-macros" title="Permanent link">¶</a></h3>
<p>attribute-like 매크로는 커스텀 derive 매크로와 비슷하지만 derive 를 위하여 코드를 생성하는 대신 새로운 attribute 를 생성한다. derive 매크로는 는 struct 와 enum 에서만 기능하지만 attribute 매크로는 함수 등 모든 아이템에서 작동한다. 가령 다음과 같다.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[route(GET, </span><span class="s">"/"</span><span class="cp">)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">index</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</code></pre></div>
<p><code>#[route]</code> attribute 같은 경우 다음과 같이 procedural 매크로로 정의된다.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[proc_macro_attribute]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">route</span><span class="p">(</span><span class="n">attr</span>: <span class="nc">TokenStream</span><span class="p">,</span><span class="w"> </span><span class="n">item</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</code></pre></div>
<p><code>attr</code> 파라미터는 <code>GET, "/"</code> 를 받고 <code>item</code> 파라미터는 함수의 본체를 받는다.</p>
<h3 id="function-like-macros">Function-like macros<a class="headerlink" href="#function-like-macros" title="Permanent link">¶</a></h3>
<p>함수형 매크로는 함수처럼 작동한다. <code>println!</code> 같은 게 함수형 매크로였고 다음과 같이 사용할 수도 있다.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">sql</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sql</span><span class="o">!</span><span class="p">(</span><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">posts</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>이 매크로는 다음과 같이 정의될 것이다.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[proc_macro]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">sql</span><span class="p">(</span><span class="n">input</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</code></pre></div>
</article>
</div>
</div>
<a class="md-top md-icon" data-md-component="top" data-md-state="hidden" href="#">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path></svg>
            Back to top
          </a>
</main>
<!-- 
<footer class="md-footer">
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        
      </div>
      
    </div>
  </div>
</footer> -->
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.top", "header.autohide"], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../assets/javascripts/workers/search.409db549.min.js", "version": null}</script>
<script src="../../assets/javascripts/bundle.756773cc.min.js"></script>
<script src="../../javascripts/highlight.min.js"></script>
<script src="../../javascripts/config.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script>
<script src="../../javascripts/b27b3e6448.js"></script>
</body>
</html>