<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="ccsss" name="author"/>
<link href="https://ccss17.github.io/Math/Logic/FormalSystem/" rel="canonical"/>
<link href="../../../assets/images/bolt-solid.svg" rel="icon"/>
<meta content="mkdocs-1.2.2, mkdocs-material-7.2.6" name="generator"/>
<title>Formal System - ccss17</title>
<link href="../../../assets/stylesheets/main.802231af.min.css" rel="stylesheet"/>
<link href="../../../assets/stylesheets/palette.3f5d1f46.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Nanum+Gothic:300,400,400i,700%7C&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font-family:"Nanum Gothic";--md-code-font-family:""}</style>
<link href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" rel="stylesheet"/>
<link href="../../../stylesheets/config.css" rel="stylesheet"/>
</head>
<body data-md-color-accent="" data-md-color-primary="white" data-md-color-scheme="default" dir="ltr">
<script>function __prefix(e){return new URL("../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
<script>var palette=__get("__palette");if(null!==palette&&"object"==typeof palette.color)for(var key in palette.color)document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#_1">
          Skip to content
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="Header" class="md-header__inner md-grid">
<a aria-label="ccss17" class="md-header__button md-logo" data-md-component="logo" href="../../.." title="ccss17">
<img alt="logo" src="../../../assets/images/bolt-solid.svg"/>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            ccss17
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Formal System
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Switch to dark mode" class="md-option" data-md-color-accent="" data-md-color-media="" data-md-color-primary="white" data-md-color-scheme="default" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_2" hidden="" title="Switch to dark mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5z"></path></svg>
</label>
<input aria-label="Switch to light mode" class="md-option" data-md-color-accent="" data-md-color-media="" data-md-color-primary="deep-purple" data-md-color-scheme="slate" id="__palette_2" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Switch to light mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1z"></path></svg>
</label>
</form>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="Tabs" class="md-tabs" data-md-component="tabs">
<div class="md-tabs__inner md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../..">
      ccss17
    </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link md-tabs__link--active" href="../../MathHistory/">
        Math
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../paper/1404.6388/">
        Paper
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../Computer/nand2tetris/">
        Computer
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../ProgrammerBase/">
        ProgrammerBase
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../security-tutorial/">
        security tutorial
      </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navigation" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="ccss17" class="md-nav__button md-logo" data-md-component="logo" href="../../.." title="ccss17">
<img alt="logo" src="../../../assets/images/bolt-solid.svg"/>
</a>
    ccss17
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../..">
        ccss17
      </a>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" id="__nav_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2">
        Math
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Math" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
          Math
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_1" id="__nav_2_1" type="checkbox"/>
<label class="md-nav__link" for="__nav_2_1">
        Foundation of Math
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Foundation of Math" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_1">
<span class="md-nav__icon md-icon"></span>
          Foundation of Math
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../MathHistory/">
        History of Math
      </a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" data-md-toggle="toc" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
          Formal System
          <span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
        Formal System
      </a>
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<!-- <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label> -->
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#_1">
    형식체계
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
    명제논리
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#1">
    1차 논리
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_3">
    형식 언어, 이론, 모델
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
    완전성 정리
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2">
    2차 논리
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../incompleteness/">
        Incompleteness theorem
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../turing/">
        Turing's proof
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../gentzen/">
        Consistency proof of Peano arithmetic
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_2" id="__nav_2_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2_2">
        Set Theory
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Set Theory" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_2">
<span class="md-nav__icon md-icon"></span>
          Set Theory
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Set/Set/">
        Set
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Set/numbers/">
        Number Theory
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Set/InfiniteSet/">
        Infinite Set
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Set/ZFC/">
        ZFC axiom system
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ArithmeticOperations/">
        Arithmetic Operations
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Polynomials/">
        Polynomials
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../HyperrealNumbers/">
        Hyperreal Numbers
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../SurrealNumbers/">
        Surreal Numbers
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_7" id="__nav_2_7" type="checkbox"/>
<label class="md-nav__link" for="__nav_2_7">
        Linear Algebra
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Linear Algebra" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_7">
<span class="md-nav__icon md-icon"></span>
          Linear Algebra
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/VectorSpace/">
        Vector Space
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/LinearTransformation/">
        Linear Transformation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/MatrixOperation/">
        Matrix Operation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/Determinants/">
        Determinants
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/Diagonalization/">
        Diagonalization
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/InnerProductSpaces/">
        Inner Product Spaces
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/CanonicalForms/">
        Canonical Forms
      </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" id="__nav_3" type="checkbox"/>
<label class="md-nav__link" for="__nav_3">
        Paper
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Paper" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
          Paper
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/1404.6388/">
        Performance of Python runtimes on a non-numeric scientific code
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/1102.1523/">
        The NumPy array: a structure for efficient numerical computation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/facenet/">
        Facenet (2015)
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/quadruplet/">
        Quadruplet (2017)
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/blueborne/">
        BlueBorne
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" id="__nav_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_4">
        Computer
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Computer" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
          Computer
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Computer/nand2tetris/">
        Nand to Tetris
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Computer/future/">
        Why the future doesn't need us
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Computer/Rust/">
        Rust Memo
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" id="__nav_5" type="checkbox"/>
<label class="md-nav__link" for="__nav_5">
        ProgrammerBase
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="ProgrammerBase" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
          ProgrammerBase
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/">
        README
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_2" id="__nav_5_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_5_2">
        Contents
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Contents" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_5_2">
<span class="md-nav__icon md-icon"></span>
          Contents
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/01-Day1/readme/">
        Day 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/02-Day2/readme/">
        Day 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/03-Day3/readme/">
        Day 3
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/04-Day4/readme/">
        Day 4
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/05-Day5/readme/">
        Day 5
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/docker/">
        Docker
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/codingconvention/">
        Coding Convention
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/build/">
        Build System
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/information/">
        Information
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/git/">
        Git
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/vscode/">
        VSCode
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/markdown/">
        Markdown
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/tmux/">
        Tmux
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/vim/">
        Vim
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/cli/">
        CLI
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" id="__nav_6" type="checkbox"/>
<label class="md-nav__link" for="__nav_6">
        security tutorial
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="security tutorial" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
          security tutorial
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/">
        README
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/01-Base/">
        Day1 Base
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/02-Computer1/">
        Day2 Computer Principle 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/03-Computer2/">
        Day3 Computer Principle 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/04-Reversing1/">
        Day4 Reversing 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/05-Reversing2/">
        Day5 Reversing 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/06-Exploit1/">
        Day6 Exploit 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/07-Exploit2/">
        Day7 Exploit 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/08-Exploit3/">
        Day8 Exploit 3
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/09-Exploit4/">
        Day9 Exploit 4
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/10-Pentesting/">
        Day10 Pentesting
      </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<!-- <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label> -->
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#_1">
    형식체계
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
    명제논리
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#1">
    1차 논리
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_3">
    형식 언어, 이론, 모델
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
    완전성 정리
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2">
    2차 논리
  </a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1>Formal System</h1>
<h2 id="_1">형식체계<a class="headerlink" href="#_1" title="Permanent link">¶</a></h2>
<a href="#9ed6871c2"><div class="admonition def" id="9ed6871c2">
<p>형식 체계(formal system) : 공리로부터 추론규칙을 통해 정리를 이끌어낼 수 있는 논리적 체계이다.</p>
</div></a>
<ul>
<li>
<p>그러한 추론 규칙을 형식체계의 명제논리(logical calculus) 라고 한다.</p>
</li>
<li>
<p>힐베르트가 수학의 기초를 형식체계로 건설하자고 제안했다. 형식 체계는 추상적 생각의 체계를 잘 다듬은 것이다.</p>
</li>
<li>
<p>형식체계는 공리로부터 유한한 형식 언어를 구성하기 위하여 유한개의 원시 기호(primitive symbol) 를 사용한다. 좀 더 구체적으로 형식체계는 다음과 같이 구성된다. </p>
<ol>
<li>
<p>유한개의 원시 기호를 택한다.</p>
</li>
<li>
<p>원시 기호로 명제을 구성할 문법을 택한다. 어떤 명제이 잘 구성되었다(well-formed)고 하는 것은 원시 기호에 구성 문법을 가하여 그 명제을 얻을 수 있다는 것이다.</p>
</li>
<li>
<p>잘 구성된 명제인 공리를 택한다.</p>
</li>
<li>
<p>추론 규칙을 택한다. 공리로부터 추론(증명)되는 잘 구성된 명제을 정리(theorem) 이라고 한다. </p>
</li>
</ol>
</li>
<li>
<p>어떤 형식체계가 recursive 하다는 것은 그 공리들과 추론규칙들이 결정 가능한 집합(decidable sets, recursive set), 혹은 semidecidable sets 이라는 것이다.</p>
</li>
<li>
<p>어떤 형식체계가 다른 형식체계를 포함하거나 서로 동형일 수 있다. 이 경우 포함된 형식체계의 무모순성이 다른 형식체계에 의하여 상대적으로 증명가능하다.</p>
</li>
<li>
<p>연역 체계란 공리와 추론규칙으로 구성되어 정리를 이끌어낼 수 있는 체계이다. 연역 체계의 한 예시로 1차 논리를 들 수 있다.</p>
</li>
<li>
<p>논리 체계 혹은 language 란 비논리적 공리와 문법이 있는 (보통 1차 논리를 사용하는) 연역 체계이다. 모델 이론의 해석(interpretation) 에 의하여 논리 체계의 문법은 어떤 잘 구성된 명제이 주어진 구조(structure) 를 만족하는지 확인해준다.</p>
<p>이때 형식 체계의 공리를 모두 만족하는 구조(structure) 를 논리 체계의 모델(model) 이라고 한다.</p>
<ul>
<li>
<p>어떤 논리 체계가 건전하다(sound)는 것은 공리로 연역된 모든 명제이 논리 체계의 모든 모델(model) 을 만족한다는 것이다. 즉 건전성(soundness)은 증명가능한 명제(정리)가 의미론 상으로도 참이된다는 성질이다. </p>
<p>역으로 논리 체계가 완전하다(complete) 는 것은 모든 모델을 만족하는 명제가 공리로 연역될 수 있다(증명될 수 있다)는 것이다. 즉, 건전성은 완전성과 역관계이다.</p>
<p>그러나 괴델의 불완전성 정리로 산술을 표현할만큼 강력한 모든 형식체계는 건전하면서 완전하지 못하다. 왜냐하면 참이면서 증명할 수 없는 명제가 반드시 존재하기 때문이다. </p>
</li>
</ul>
</li>
</ul>
<a href="#284396ed5"><div class="admonition def" id="284396ed5">
<p>공리 체계(axiomatic system) : 명제논리로 공리로부터 정리를 이끌어낼 수 있는 임의의 공리 집합이다.</p>
</div></a>
<ul>
<li>
<p>무모순(consistent)적인 어떤 이론(theory)은 공리체계를 포함하며 그것들로부터 도출된 정리들을 포함한다.</p>
</li>
<li>
<p>공리체계는 형식체계의 특수자이다. 즉, 공리체계의 일반화가 형식체계이다.</p>
</li>
<li>
<p>형식적 이론이란 공리체계(주로 모델 이론model theory 으로 형식화된)로 설명되는 명제의 집합이다. 이렇게 공리체계에서 도출된 이론에 포함된 정리들은 형식적 증명이라고 한다.</p>
</li>
<li>
<p>공리체계가 무모순(consistent)이라는 것은 모순을 포함하지 않는다는 것이다. 즉, 공리체계로부터 어떤 명제과 그 부정문이 도출되지 않는다는 것이다.</p>
<p>무모순은 모든 공리체계에 있어야 하는 필수적인 속성인데, 왜냐하면 모순이 존재하면 폭발 원리(principle of explosion) 에 의하여 모든 명제이 증명되기 때문이다.</p>
</li>
<li>
<p>공리가 다른 공리로부터 도출될 수 없다면 독립성이 있다고 한다. 그러나 무모순성이 공리체계에 반드시 있어야 하는 조건인 것과 달리 독립성은 반드시 있어야 하는 조건은 아니다.</p>
</li>
<li>
<p>공리체계가 완전하다(complete)는 것은 모든 명제이 공리로부터 도출된다는 것이다. 즉, 그 공리체계로 표현가능한 모든 명제이 참이든 거짓으로든 증명 가능하다는 것이다.</p>
</li>
<li>
<p>상대적 무모순성이란 어떤 공리 체계의 무정의 술어의 정의가 다른 공리 체계로부터 주어져서, 전자의 공리체계가 후자의 공리체계의 정리가 되는 상황을 뜻한다. </p>
<ul>
<li>
<p>예시 </p>
<p>유클리드 기하학의 무모순성은 실수 체계의 무모순성이 증명되면 곧바로 증명된다. 왜냐하면 기하학은 실수 체계에 대하여 상대적으로 무모순적이기 때문이다. </p>
<p>가령 기하학에서의 무정의 술어인 점과 선은 실수 체계에서 의미와 정의를 부여받는다.</p>
</li>
</ul>
</li>
<li>
<p>공리체계에서 모델은 무정의 술어에 의미를 부여하는, 잘 정의된 집합이다. </p>
<ul>
<li>concrete model 의 존재는 공리체계의 무모순성을 증명해준다.(<em>하지만 이 부분은 논쟁이 있음</em>)</li>
</ul>
<p>어떤 모델이 concrete 하다는 것은 추상적 모델과는 달리 의미가 부여된 대상과 관계가 현실 세계로부터 왔다는 것이다.</p>
<p>모델은 어떤 공리의 독립성을 보이는데도 사용된다. 가령 어떤 공리체계의 특정 공리를 제외하여 생성된 부분체계가 올바른(valid) 모델을 구성했을 때 제외된 그 공리가 다른 공리로부터 독립적이라고 말할 수 있고, 부분체계에서 필요없다고 할 수 있다.</p>
<p>두 모델이 서로간의 성분의 관계를 보존하는 전사함수(one-to-one correspondence)를 가지면, 서로 동형(isomorphic)이라고 한다.</p>
<p>만약 어떤 공리체계의 모든 모델이 서로 동형이면 그 공리체계를 categorial 하다고 한다. 공리체계가 categoriality 를 가지면 공리체계의 완전성이 보장된다. 그러나 그 역은 성립하지 않는다. 즉, 완전성은 categoriality 를 보장해주지 못한다. </p>
<ul>
<li>
<p>예시 </p>
<p>1차 논리를 기반으로 다음과 같은 가산 무한의 공리를 갖는 공리체계를 생각하자. </p>
<div class="arithmatex">\[ \exists x_1: \exists x_2: x_1 \neq x_2 \]</div>
<div class="arithmatex">\[ \exists x_1: \exists x_2: \exists x_3 : x_1 \neq x_2 \neq x_3 \]</div>
<div class="arithmatex">\[ \vdots \]</div>
<p>이 공리체계의 가산 무한개의 공리들은 공리꼴(axiom schema) 로 생성된 것이다. 이 무한한 공리는 무한히 많은 대상이 존재함을 말하고 있다. 이 공리체계는 최소한 2개의 모델을 갖는다. 하나는 가산 무한 집합의 기수를 갖는 집합과 동형인 자연수이고, 다른 하나는 연속체의 기수와 동형인 실수이다. 사실 이 공리체계는 무한한 모델을 갖는다. 그러나 그러한 모델들을 구분하는 것은 기수(cardinality) 이다. 기수는 아직 이 공리체계에 정의되지 않았으므로, 이 공리체계는 categorial 하지 못하다. 그러나 이 공리체계가 완전하다는 것은 보일 수 있다.</p>
</li>
</ul>
</li>
<li>
<p>무정의 술어를 두는 이유는 어떤 개념을 무한히 거슬러서 정의할 수 없기 때문이다. 이것을 공리적 방법(axiomatic method) 라고 한다. 공리적 방법에 대한 개념은 논리주의 학파에서 나왔다. 논리주의는 모든 것을 논리적으로 설명하려는 시도인데, 러셀은 "수학 원리" 에서 모든 수학의 정리를 공리를 기반으로 논리적으로 설명하려 했다. 이것은 현대의 수학에서 호몰로지 대수(homological algebra) 로 발전했다.</p>
<p>공리적 방법은 수학의 추상적 위계를 명확하게 설정하는데 큰 도움을 준다. 가령 에미 뇌터의 첫 제안과는 달리 수학자들은 환(ring)에 commutative 가 성립하지 않아도 된다고 정의했고, 하우스도르프의 첫 정의와는 달리 위상 공간(topological space)이 separation axiom 없이 더 일반적으로 정의된다. ZFC 체계에서는 공리적 방법으로 러셀의 역설 등을 제거할 수 있었다. </p>
<ul>
<li>
<p>모든 무모순적인 명제가 공리적 방법으로 설명될 수 있는 것은 아니다. 어떤 프로그램이 주어진 명제가 정리인지 확인할 수 있다면 그 공리체계를 재귀 집합(recursive, 계산 가능한) 이라고 한다. 그러나 괴델의 불완전성 정리에 의하여 무모순적이지만 재귀 집합에 속하지 않은 명제가 있다는 것이 밝혀졌다. 즉, 컴퓨터는 어떤 증명이 올바른지 확인할 수 있지만, 어떤 명제의 증명이 존재한다는 것을 밝힐 수 있다는 보장은 해줄 수 없다. </p>
<p>그러나 상위 체계 혹은 또 다른 체계에 해당 명제의 증명이 존재하는 경우가 있다. </p>
<p>가령 어떤 산술에서의 명제을 산술의 공리로 표현할 수 있지만, 그것에 대한 증명이 위상수학이나 복소해석학의 공리체계에 의존하게 될 수도 있다. 즉, 산술의 명제이라 할지라도 그것의 증명을 페아노 공리체계(Peano axioms)에서 찾을 수 있다는 보장은 없다. </p>
</li>
</ul>
</li>
</ul>
<h2 id="_2">명제논리<a class="headerlink" href="#_2" title="Permanent link">¶</a></h2>
<a href="#e9b1cf95e"><div class="admonition def" id="e9b1cf95e">
<p>명제논리(Propositional logic, zeroth-order logic, Propositional calculus) : 내부 구조가 없는 명제들에 논리 연산을 가하여 구성한 명제들을 다루는 형식 체계이다. </p>
</div></a>
<ul>
<li>
<p>1차 논리와는 달리 명제 논리는 비논리적 대상, 그것에 대한 술어(속성, 조건), 양화사(<span class="arithmatex">\(\exists , \forall\)</span>)를 다루지 않는다. 그러나 명제논리는 1차 논리와 고차 논리의 기반이 된다.</p>
</li>
<li>
<p>논리는 자연어를 연결한다. 가령 and, or, not, if 를 들 수 있다.</p>
<ul>
<li>
<p>예시 </p>
<p>다음은 명제논리 추론의 간단한 예시이다. </p>
<p>Premise 1: If it's raining then it's cloudy.</p>
<p>Premise 2: It's raining.</p>
<p>Conclusion: It's cloudy.</p>
</li>
</ul>
<p>위의 예시는 전건 긍정(modus ponens) 를 적용한 추론이다.</p>
</li>
<li>
<p>명제 논리는 논리적 접속사(and, or, not, if)로 연결된 명제를 더 이상 분해하지 않는다. 위의 예시에서의 명제는 변수로 나타낼 수 있다.</p>
<ul>
<li>
<p>예시 </p>
<p>Premise 1: <span class="arithmatex">\(P \to Q\)</span></p>
<p>Premise 2: <span class="arithmatex">\(P\)</span></p>
<p>Conclusion: <span class="arithmatex">\(Q\)</span></p>
</li>
</ul>
<p>위 예시의 추론을 간결하게</p>
<div class="arithmatex">\[ P \to Q, P \vdash Q \]</div>
<p>와 같이 표현할 수 있다. </p>
</li>
<li>
<p>공리와 추론 규칙으로 명제로부터 또 다른 명제가 도출되는데 이를 정리(theorem) 라고 하며, 참인 명제로 여겨진다. 이 도출과정을 정리에 대한 증명이라고 부른다.</p>
</li>
<li>
<p>명제논리는 다음과 같이 구성된다. </p>
<ul>
<li>
<p>language (원시기호의 모음과 다른 기호들)</p>
</li>
<li>
<p>공리 집합 </p>
</li>
<li>
<p>추론 규칙의 집합</p>
</li>
</ul>
</li>
<li>
<p>명제 논리는 진리값 참과 거짓을 가지며, 다음과 같은 연산을 갖는다. </p>
<ul>
<li>
<p>부정 <span class="arithmatex">\(\lnot P\)</span>, 그리고 <span class="arithmatex">\(P \land Q\)</span>, Material conditional <span class="arithmatex">\(P \to  Q\)</span>, IFF <span class="arithmatex">\(P \leftrightarrow  Q\)</span></p>
</li>
<li>
<p>명제 논리는 이러한 연산에 대하여 닫혀있다. 즉, 이 연산을 적용한 대상 또한 명제이다.</p>
</li>
</ul>
</li>
<li>
<p>명제 논리는 다음과 같은 추론 규칙을 가진다. </p>
<p>먼저 다음은 명제 <span class="arithmatex">\(P, Q\)</span> 에 대한 전건 긍정(modus ponens)이다.</p>
<div class="arithmatex">\[ \begin{array}{rl}1.&amp;P\to Q\\2.&amp;P\\\hline \therefore &amp;Q\end{array} \]</div>
<p>다른 추론 규칙도 있으면 편리하지만, 필요하지는 않다. 전건 긍정만 있으면 다른 추론 규칙을 구성할 수 있기 때문이다. 그러나 이것이 1차 논리에서도 적용되지는 않는다. 1차 논리는 완전성(completeness) 를 위한 추론 규칙이 최소한 하나 더 필요하다.</p>
<ul>
<li>
<p>추론 규칙의 중요한 특징은 이미 알고 있는 진실로부터 또 다른 진실을 발견하게 해준다는 것이다. 우리는 이로써 어떤 명제 집합에 추론 규칙을 적용하여 다른 명제를 연역해낼 수 있다.</p>
<p>가령 명제 집합 <span class="arithmatex">\(A = \{P \lor Q, \lnot Q \land R, (P \lor Q) \to R\}\)</span> 이 존재할 때, 우리는 이 명제 집합에서 연역되는 모든 명제의 집합인 연역 체계 <span class="arithmatex">\(\Gamma\)</span> 를 정의할 수 있다. <span class="arithmatex">\(\Gamma\)</span> 는 먼저 <span class="arithmatex">\(A\)</span> 의 원소를 포함할 것이고 전건 긍정에 의하여 <span class="arithmatex">\(R\)</span> 도 포함하여 </p>
<div class="arithmatex">\[ P \lor Q, \lnot Q \land R, (P \lor Q) \to R \in \Gamma , R \in \Gamma \]</div>
<p>를 만족한다. </p>
</li>
</ul>
</li>
<li>
<p>명제논리는 다음과 같이 일반적으로 표현된다. </p>
<p>명제논리는 다음 조건을 만족하는 형식체계 <span class="arithmatex">\(\mathcal{L} = \mathcal{L}(\Alpha , \Omega , \Zeta, \Iota)\)</span> 이다. 이를 language <span class="arithmatex">\(\mathcal{L}\)</span> 라고도 한다.</p>
<ul>
<li>
<p><span class="arithmatex">\(\Alpha\)</span> 는 명제 기호 또는 명제 변수로 이루어진 가산 무한집합이다. 이는 language <span class="arithmatex">\(\mathcal{L}\)</span> 의 기본 구성을 이룬다. 관례적으로 <span class="arithmatex">\(\Alpha\)</span> 의 원소를 <span class="arithmatex">\(p,q,r, \dots\)</span> 로 표기한다. </p>
</li>
<li>
<p><span class="arithmatex">\(\Omega\)</span> 는 연산 기호 또는 논리 접속사로 이루어진다. 집합 <span class="arithmatex">\(\Omega\)</span> 는 서로소 집합의 합 </p>
<div class="arithmatex">\[ \Omega = \Omega _0 \sqcup \Omega _1 \sqcup \Omega _2 \sqcup \dots \sqcup  \Omega _m \]</div>
<p>으로 이루어진다. <span class="arithmatex">\(\Omega _j\)</span> 는 연산 기호 항수(artiy) j 의 집합이다. 가령 </p>
<div class="arithmatex">\[ \Omega _1 = \{\lnot \}, \Omega _2 \subseteq = \{\land , \lor , \to , \leftrightarrow  \} \]</div>
<p>이다. 보통 항수(artiy) zero 는 논리값 (False, True) 을 나타내는 <span class="arithmatex">\(\Omega _0 = \{\top , \bot \}\)</span>  이 된다.</p>
</li>
<li>
<p><span class="arithmatex">\(\Zeta\)</span> 는 추론 규칙(변환 규칙) 의 유한 집합이다. </p>
</li>
<li>
<p><span class="arithmatex">\(\Iota\)</span> 는 공리로 이루어진 가산 집합이다. language <span class="arithmatex">\(\mathcal{L}\)</span> 이 다음 조건을 만족할 때 잘 정의된 명제의 집합이라고 한다. </p>
<ol>
<li>
<p>Base: <span class="arithmatex">\(\Alpha\)</span> 의 원소가 <span class="arithmatex">\(\mathcal{L}\)</span> 의 명제이다. </p>
</li>
<li>
<p><span class="arithmatex">\(p_1, p_2, \dots, p_j\)</span> 가 <span class="arithmatex">\(\mathcal{L}\)</span> 의 명제이고 <span class="arithmatex">\(f\)</span> 가 <span class="arithmatex">\(\Omega_j\)</span> 에 속했다면, <span class="arithmatex">\(f(p_1, p_2, \dots, p_j)\)</span> 도 <span class="arithmatex">\(\mathcal{L}\)</span> 의 명제이다. </p>
</li>
<li>
<p>닫혀있음: 그 외에 것들은 <span class="arithmatex">\(\mathcal{L}\)</span> 의 명제이 아니다.</p>
</li>
</ol>
<p>위와 같은 규칙을 반복함으로써 더 복잡한 명제를 생성할 수 있다. 가령 <span class="arithmatex">\(p\)</span> 가 명제이면 <span class="arithmatex">\(\lnot p\)</span> 도 명제이고, <span class="arithmatex">\((\lnot p \lor q)\)</span> 도 명제가 된다.</p>
</li>
<li>
<p>예시 (고전 명제 논리, 또는 힐베르트 연역 체계)</p>
<p>다음과 같이 정의된 간단한 공리 체계 <span class="arithmatex">\(\mathcal{L}_1 = \mathcal{L}(\Alpha ,\Omega ,\Zeta ,\Iota )\)</span> 를 생각하자.</p>
<p><span class="arithmatex">\(\Alpha\)</span> 는 가산 무한집합 <span class="arithmatex">\(A = \{p,q,r,s,t,u,p_2, \dots\}\)</span> 이다.</p>
<p><span class="arithmatex">\(\Omega\)</span> 는 <span class="arithmatex">\(\Omega _0 = \{\top ,\bot \}, \Omega _1 = \{\lnot \}, \Omega _2 = \{\to \}\)</span> 에 대한 </p>
<div class="arithmatex">\[ \Omega = \Omega _0 \sqcup \Omega _1 \sqcup \Omega _2 \]</div>
<p>이다. <span class="arithmatex">\(\lnot , \to\)</span> 로 <span class="arithmatex">\(\land , \lor\)</span> 을 만들 수 있고, <span class="arithmatex">\((a \to b) \land (b \to a)\)</span> 와 같이 <span class="arithmatex">\(a \leftrightarrow  b\)</span> 를 만들 수 있다.</p>
<p><span class="arithmatex">\(\Iota\)</span> 에 해당하는 공리는 다음과 같은 치환 실례(substitution instance) 로 구성된다.</p>
<ol>
<li>
<p><span class="arithmatex">\((p \to (q \to p))\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(((p \to (q \to r)) \to ((p \to q) \to (p \to r)))\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(((\lnot p \to \lnot q) \to (q \to p))\)</span></p>
</li>
</ol>
<p><span class="arithmatex">\(\Zeta\)</span> 에 해당하는 추론 규칙은 전건긍정(modus ponens) 이다.</p>
<p>이 체계가 <a href="http://us.metamath.org/mpegif/mmset.html#scaxioms">Metamath</a> 의 형식적 증명 데이터베이스에 사용된다.</p>
</li>
<li>
<p>예시 (자연 연역 체계)</p>
<p>다음 조건을 만족하는 체계 <span class="arithmatex">\(\mathcal{L}_2 = \mathcal{L}(\Alpha ,\Omega ,\Zeta ,\Iota )\)</span> 를 자연 연역 체계라고 한다. </p>
<p><span class="arithmatex">\(\Alpha = \{p,q,r,s,t,u,p_2, \dots\}\)</span> 는 가산 무한집합이다.</p>
<p><span class="arithmatex">\(\Omega\)</span> 는 <span class="arithmatex">\(\Omega _0 = \{\top ,\bot \}, \Omega _1 = \{\lnot \}, \Omega _2 = \{\land ,\lor ,\to ,\leftrightarrow  \}\)</span> 에 대한 </p>
<div class="arithmatex">\[ \Omega = \Omega _0 \sqcup \Omega _1 \sqcup \Omega _2 \]</div>
<p>이다. 공리 집합 <span class="arithmatex">\(\Iota = \varnothing\)</span> 는 공집합이다. 즉, 공리가 없다. 추론 규칙 집합 <span class="arithmatex">\(\Zeta\)</span> 는 다음 11개의 규칙으로 이루어진다. 첫 10개는 잘 구성된 명제에서 잘 구성된 명제를 도출할 수 있다는 것이고, 마지막 규칙은 어떤 명제를 가정했을 때 다른 명제를 도출할 수 있다는 가상의 추론(hypothetical rule)을 뜻한다. 첫 10 개의 규칙은 non-hypothetical rule 이라고 한다.</p>
<p>추론 규칙을 효과적으로 표현하기 위하여 <span class="arithmatex">\(\vdash\)</span> 를 사용한다. 가령 <span class="arithmatex">\(\Gamma \vdash \psi\)</span> 는 가정 <span class="arithmatex">\(\Gamma\)</span> 에서 결론 <span class="arithmatex">\(\psi\)</span> 가 도출된다는 것이다. 이때 <span class="arithmatex">\(\Gamma = \varnothing\)</span> 일 수도 있다. 또 다른 뜻은 <span class="arithmatex">\(\Gamma\)</span> 가 정리이라면(즉, 공리와 같은 진리값을 가진다면) <span class="arithmatex">\(\psi\)</span> 도 정리라는 것이다. 아래의 연언 도입(Conjunction introduction) 은 <span class="arithmatex">\(\Gamma\)</span> 가 2개 이상의 명제를 가지면 그것을 하나의 명제로 줄일 수 있음을 뜻한다.</p>
<ol>
<li>
<p>Negation introduction: <span class="arithmatex">\(\{(p \to q), (p \to \lnot q)\} \vdash \lnot p\)</span></p>
</li>
<li>
<p>Negation elimination: <span class="arithmatex">\(\{\lnot p\} \vdash (p \to r)\)</span></p>
</li>
<li>
<p>Double negation elimination: <span class="arithmatex">\(\lnot \lnot p \vdash p\)</span></p>
</li>
<li>
<p>Conjunction introduction: <span class="arithmatex">\(\{p,q\} \vdash (p \land q)\)</span></p>
</li>
<li>
<p>Conjunction elimination: <span class="arithmatex">\((p \land q) \vdash p\)</span> and <span class="arithmatex">\((p \land q) \vdash q\)</span></p>
</li>
<li>
<p>Disjunction introduction: <span class="arithmatex">\(p \vdash (p \lor q)\)</span> and <span class="arithmatex">\(q \vdash (p \lor q)\)</span></p>
</li>
<li>
<p>Disjunction elimination: <span class="arithmatex">\(\{p \lor q, p \to r, q \to r\} \vdash r\)</span></p>
</li>
<li>
<p>Biconditional introduction: <span class="arithmatex">\(\{p \to  q, p \to p\} \vdash (p \leftrightarrow  q)\)</span></p>
</li>
<li>
<p>Biconditional elimination: <span class="arithmatex">\((p \leftrightarrow  q) \vdash (p \to q)\)</span> and <span class="arithmatex">\((p \leftrightarrow  q) \vdash (q \to p\)</span></p>
</li>
<li>
<p>Modus ponens(conditional elimination): <span class="arithmatex">\(\{p, p \to q\} \vdash q\)</span></p>
</li>
<li>
<p>Conditional proof(conditional introduction): <span class="arithmatex">\((p \vdash q) \vdash (p \to q)\)</span> </p>
<p>(<span class="arithmatex">\(p\)</span> 가 <span class="arithmatex">\(q\)</span> 를 증명한다고 가정하면, <span class="arithmatex">\(p \to q\)</span> 이다)</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>명제 논리는 일반적으로 다음과 같은 기본적인 추론 규칙들을 가질 수 있다.</p>
<table>
<thead>
<tr>
<th align="center">Name</th>
<th align="center">Sequent</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Modus Ponens</td>
<td align="center"><span class="arithmatex">\(((p \to q) \land p) \vdash q\)</span></td>
</tr>
<tr>
<td align="center">Modus Tollens</td>
<td align="center"><span class="arithmatex">\(((p \to q) \land \lnot q) \vdash \lnot p\)</span></td>
</tr>
<tr>
<td align="center">Hypothetical Syllogism</td>
<td align="center"><span class="arithmatex">\(((p \to q) \land (q \to r)) \vdash (p \to r)\)</span></td>
</tr>
<tr>
<td align="center">Disjunctive Syllogism</td>
<td align="center"><span class="arithmatex">\(((p \lor  q) \land \lnot  p) \vdash q\)</span></td>
</tr>
<tr>
<td align="center">Constructive Dilemma</td>
<td align="center"><span class="arithmatex">\(((p \to q) \land (r \to s) \land (p \lor r)) \vdash (q \lor s)\)</span></td>
</tr>
<tr>
<td align="center">Destructive Dilemma</td>
<td align="center"><span class="arithmatex">\(((p \to q) \land (r \to s) \land (\lnot q \lor \lnot s)) \vdash (\lnot p \lor \lnot r)\)</span></td>
</tr>
<tr>
<td align="center">Bidirectional Dilemma</td>
<td align="center"><span class="arithmatex">\(((p \to q) \land (r \to s) \land (p \lor \lnot s)) \vdash (q \lor \lnot r)\)</span></td>
</tr>
<tr>
<td align="center">Simplification</td>
<td align="center"><span class="arithmatex">\((p \land  q) \vdash p\)</span></td>
</tr>
<tr>
<td align="center">Conjunction</td>
<td align="center"><span class="arithmatex">\(p,q \vdash (p \land q)\)</span></td>
</tr>
<tr>
<td align="center">Addition</td>
<td align="center"><span class="arithmatex">\(p \vdash (p \lor q)\)</span></td>
</tr>
<tr>
<td align="center">Composition</td>
<td align="center"><span class="arithmatex">\(((p \to q) \land (p \to r)) \vdash (p \to (q \land r))\)</span></td>
</tr>
<tr>
<td align="center">De Morgan's Theorem 1</td>
<td align="center"><span class="arithmatex">\(\lnot (p \land q) \vdash (\lnot p \lor \lnot q)\)</span></td>
</tr>
<tr>
<td align="center">De Morgan's Theorem 2</td>
<td align="center"><span class="arithmatex">\(\lnot (p \lor q) \vdash (\lnot p \land \lnot q)\)</span></td>
</tr>
<tr>
<td align="center">Commutation 1</td>
<td align="center"><span class="arithmatex">\((p \lor q) \vdash (q \lor p)\)</span></td>
</tr>
<tr>
<td align="center">Commutation 2</td>
<td align="center"><span class="arithmatex">\((p \land q) \vdash (q \land p)\)</span></td>
</tr>
<tr>
<td align="center">Commutation 3</td>
<td align="center"><span class="arithmatex">\((p \leftrightarrow  q) \vdash (q \leftrightarrow  p)\)</span></td>
</tr>
<tr>
<td align="center">Association 1</td>
<td align="center"><span class="arithmatex">\((p \lor (q \lor r)) \vdash ((p \lor q) \lor r)\)</span></td>
</tr>
<tr>
<td align="center">Association 2</td>
<td align="center"><span class="arithmatex">\((p \land (q \land r)) \vdash ((p \land q) \land r)\)</span></td>
</tr>
<tr>
<td align="center">Distribution 1</td>
<td align="center"><span class="arithmatex">\((p \land (q \lor r)) \vdash ((p \land q) \lor (p \land r))\)</span></td>
</tr>
<tr>
<td align="center">Distribution 2</td>
<td align="center"><span class="arithmatex">\((p \lor (q \land r)) \vdash ((p \lor q) \land (p \lor r))\)</span></td>
</tr>
<tr>
<td align="center">Double Negation</td>
<td align="center"><span class="arithmatex">\(p \vdash \lnot \lnot p\)</span>, <span class="arithmatex">\(\lnot \lnot p \vdash p\)</span></td>
</tr>
<tr>
<td align="center">Transposition</td>
<td align="center"><span class="arithmatex">\((p \to q) \vdash (\lnot q \to \lnot p)\)</span></td>
</tr>
<tr>
<td align="center">Material Implication</td>
<td align="center"><span class="arithmatex">\((p \to q) \vdash (\lnot p \lor q)\)</span></td>
</tr>
<tr>
<td align="center">Material Equivalence 1</td>
<td align="center"><span class="arithmatex">\((p \leftrightarrow   q) \vdash ((p \to q) \land (q \to p))\)</span></td>
</tr>
<tr>
<td align="center">Material Equivalence 2</td>
<td align="center"><span class="arithmatex">\((p \leftrightarrow   q) \vdash ((p \land  q) \lor (\land p \land \lnot q))\)</span></td>
</tr>
<tr>
<td align="center">Material Equivalence 3</td>
<td align="center"><span class="arithmatex">\((p \leftrightarrow   q) \vdash ((p \lor \lnot  q) \land (\lnot p \lor q))\)</span></td>
</tr>
<tr>
<td align="center">Exportation</td>
<td align="center"><span class="arithmatex">\(((p \land q) \to r) \vdash (p \to (q \to r))\)</span></td>
</tr>
<tr>
<td align="center">Importation</td>
<td align="center"><span class="arithmatex">\((p \to (q \to r)) \vdash ((p \land q) \to r)\)</span></td>
</tr>
<tr>
<td align="center">Tautology 1</td>
<td align="center"><span class="arithmatex">\(p \vdash (p \lor p)\)</span></td>
</tr>
<tr>
<td align="center">Tautology 2</td>
<td align="center"><span class="arithmatex">\(p \vdash (p \land p)\)</span></td>
</tr>
<tr>
<td align="center">Tertium non datur(배중률)</td>
<td align="center"><span class="arithmatex">\(\vdash (p \lor \lnot p)\)</span></td>
</tr>
<tr>
<td align="center">Law of Non Contradiction(무모순성)</td>
<td align="center"><span class="arithmatex">\(\vdash \lnot (p \land \lnot p)\)</span></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Conjunction : <span class="arithmatex">\(p\)</span>, <span class="arithmatex">\(q\)</span> 가 독립적으로 참이면 <span class="arithmatex">\(p \land q\)</span> 가 참이다.</p>
</li>
<li>
<p>Exportation : <span class="arithmatex">\(p\)</span> 와 <span class="arithmatex">\(q\)</span> 가 참이면 <span class="arithmatex">\(r\)</span> 이 참이라는 것으로부터 (<span class="arithmatex">\(p\)</span> 가 참이면 (<span class="arithmatex">\(q\)</span> 가 참일 때 <span class="arithmatex">\(r\)</span> 이 참)이라는 것)을 증명할 수 있다.</p>
</li>
</ul>
</li>
<li>
<p>명제 논리가 실제로 사용되는 용도는 어떤 명제와 다른 명제의 동등 관계를 확인하려 함이다. 가령 참임을 알고 있는, 혹은 참이라고 가정한 어떤 명제에 추론 규칙을 적용하여 다른 명제를 도출할 수 있는지 확인하는 것이다. 이때 도출되는 명제로까지의 과정(명제의 나열)을 증명(proof) 이라고 한다.</p>
<ul>
<li>
<p>예시 (자연 연역에서의 증명)</p>
<div class="arithmatex">\[ \begin{array}{rl} 1.&amp; A \\ 2.&amp; A \lor A  \\ 3.&amp; (A \lor A) \land A \\ 4.&amp; A \quad (\text{conjunction elimination)}\\ 5.&amp; A \vdash  A \quad(\text{Summary of 1 through 4}) \\ 6.&amp; \vdash  A \to  A \quad(\text{conditional proof}) \\ \end{array} \]</div>
<p>위의 증명에서 <span class="arithmatex">\(A \vdash A\)</span> 를 "<span class="arithmatex">\(A\)</span> 를 가정하면 <span class="arithmatex">\(A\)</span> 가 증명된다." 로 해석하면 된다. <span class="arithmatex">\(\vdash A \to A\)</span> 를 "아무것도 가정하지 않아도, <span class="arithmatex">\(A\)</span> 가 <span class="arithmatex">\(A\)</span> 를 도출한다는 것이 증명된다." 로 해석하면 된다. 즉, "<span class="arithmatex">\(A\)</span> 가 <span class="arithmatex">\(A\)</span> 를 도출하는 것은 진리이다" 라고 해석하면 된다.</p>
</li>
<li>
<p>예시 (고전 명제논리에서의 증명)</p>
<p>이제 <span class="arithmatex">\(A \to A\)</span> 를 고전 명제논리에서도 증명해보자. 먼저 고전 명제 논리가 다음의 공리를 갖는다는 것을 기억하자.</p>
<ol>
<li>
<p><span class="arithmatex">\((p \to (q \to p))\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(((p \to (q \to r)) \to ((p \to q) \to (p \to r)))\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(((\lnot p \to \lnot q) \to (q \to p))\)</span></p>
</li>
</ol>
<p>먼저 <span class="arithmatex">\(A\)</span> 를 가정하면 공리 1 에 의하여 <span class="arithmatex">\(A \to ((B \to A) \to A)\)</span> 이다. 그러므로 다음과 같이 증명이 끝난다.</p>
<div class="arithmatex">\[ \begin{array}{rl} 1.&amp; A \to ((B \to A) \to A) \\ 2.&amp; (A \to ((B \to A) \to A)) \to ((A \to (B \to A)) \to (A \to A)) \quad (\text{axiom 2})\\ 3.&amp; (A \to (B \to A)) \to (A \to A) \quad (\text{modus ponens from 1 and 2})\\ 4.&amp; A \to (B \to A) \quad (\text{axiom 1})\\ 5.&amp; A \to A\quad (\text{modus ponens from 3 and 4})\\ \end{array} \]</div>
</li>
</ul>
</li>
<li>
<p>어떤 형식 체계 <span class="arithmatex">\(\mathcal{P}\)</span> 에 대한 진리 함수적인 해석은 명제에 대한 진리표를 작성하는 것이다. <span class="arithmatex">\(n\)</span> 개의 명제들에 대한 진리값은 <span class="arithmatex">\(2 ^{n}\)</span> 의 가능성을 갖는다. </p>
<p>가령 어떤 명제 <span class="arithmatex">\(a\)</span> 는 참, 거짓 두 가지 경우 뿐이므로 <span class="arithmatex">\(2 ^{1} = 2\)</span> 의 가능성을 갖고, 어떤 명제 <span class="arithmatex">\(a, b\)</span> 는 <span class="arithmatex">\(2 ^{2} = 4\)</span> 가지 가능성을 갖는다.</p>
<p><span class="arithmatex">\(\mathcal{P}\)</span> 가 가산 집합만큼의 명제를 갖는다면, 즉 <span class="arithmatex">\(\mathcal{P}\)</span> 가 <span class="arithmatex">\(\aleph _0\)</span> 이라면 <span class="arithmatex">\(2 ^{\aleph _0} = \mathfrak{c}\)</span> 의 가능성을 갖는다. 즉, <span class="arithmatex">\(\mathcal{P}\)</span> 을 해석할 수 있는 가능성이 비가산 무한 집합만큼(실수의 개수만큼) 있는 것이다.</p>
</li>
<li>
<p>명제 논리에서 어떤 명제의 증명을 찾는 것은 NP 문제이다. 그러나 대부분의 유용한 명제를 자동으로 증명해 수 있는 현실적인 알고리즘들이 존재한다. 가령 <a href="https://en.wikipedia.org/wiki/DPLL_algorithm">DPLL algorithm (1962)</a> 이나 <a href="https://en.wikipedia.org/wiki/Chaff_algorithm">Chaff algorithm (2001)</a> 이 있다. 최근에는 <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Algorithms_for_solving_SAT">SAT solver</a> 알고리즘을 산술 연산을 포함하는 명제를 해결할 수 있도록 확장한 <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT solver</a> 가 제안되었다.</p>
</li>
</ul>
<a href="#70ce85dfb"><div class="admonition def" id="70ce85dfb">
<p>건전성(soundness) : 형식 체계의 성질 "임의의 명제가 증명가능하면 참이다" 이다.</p>
</div></a>
<ul>
<li>
<p>건전성은 형식체계의 임의의 명제가 거짓이라면 증명할 수 없다는 성질이다.</p>
<p>가설 명제 집합 <span class="arithmatex">\(\Sigma\)</span> 와 증명하고자 하는 명제 <span class="arithmatex">\(\Phi\)</span> 를 생각하자. <span class="arithmatex">\(\Sigma \vDash \Phi\)</span> 는 <span class="arithmatex">\(\Sigma\)</span> 가 의미적으로 <span class="arithmatex">\(\Phi\)</span> 를 함의한다는 뜻이다. 즉, <span class="arithmatex">\(\Sigma\)</span> 가 참이면 <span class="arithmatex">\(\Phi\)</span> 도 참이라는 것이다. 반면 <span class="arithmatex">\(\Sigma \vdash \Phi\)</span> 는 <span class="arithmatex">\(\Sigma\)</span> 에 추론규칙을 적용하여 <span class="arithmatex">\(\Phi\)</span> 를 도출할 수 있다는 것이다. 즉 <span class="arithmatex">\(\Phi\)</span> 가 <span class="arithmatex">\(\Sigma\)</span> 로부터 증명가능하다는 것이다.</p>
<p>건전성이란 <span class="arithmatex">\(\Sigma \vdash \Phi \implies \Sigma \vDash \Phi\)</span> 이다. 즉, <span class="arithmatex">\(\Phi\)</span> 를 <span class="arithmatex">\(\Sigma\)</span> 로부터 증명할 수 있다면, <span class="arithmatex">\(\Sigma\)</span> 가 주어졌을 때 <span class="arithmatex">\(\Phi\)</span> 가 참이라는 것이다. 이는 <span class="arithmatex">\(\Sigma\)</span> 가 주어졌을 때 <span class="arithmatex">\(\Phi\)</span> 가 거짓이라면 <span class="arithmatex">\(\Sigma\)</span> 로부터 <span class="arithmatex">\(\Phi\)</span> 를 증명할 수 없음을 뜻한다. 그래서 건전성은 "거짓이라면 무엇이든지 증명할 수 없다" 혹은 "증명할 수 있다면 그것은 참이다" 는 성질이다. </p>
</li>
<li>
<p>건전성 증명은 일반적으로 다음과 같이 이루어진다.</p>
<p><span class="arithmatex">\(G\)</span> 가 명제 집합이라고 하고 <span class="arithmatex">\(A,B,C\)</span> 를 명제라고 하자. 우리가 보이려 하는 것은 </p>
<div class="arithmatex">\[G \vdash A \implies G \vDash A\]</div>
<p>이다. 그런데 <span class="arithmatex">\(G \vdash A\)</span>(어떤 명제가 다른 명제를 증명한다) 는 귀납적으로 정의할 수 있다. 그러므로 우리는 다음을 증명하면 된다.</p>
<ol>
<li>
<p><span class="arithmatex">\(A \in G \implies G \vDash A\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(A\)</span> 가 공리이면 <span class="arithmatex">\(G \vDash A\)</span> 이다.</p>
</li>
<li>
<p>증명의 길이 <span class="arithmatex">\(n\)</span> 에 대하여 다음이 성립한다.</p>
<ol>
<li>
<p>임의의 <span class="arithmatex">\(G\)</span> 와 <span class="arithmatex">\(G\)</span> 가 <span class="arithmatex">\(n\)</span> 이나 <span class="arithmatex">\(n\)</span> 보다 적은 단계로 증명할 수 있는 <span class="arithmatex">\(A\)</span> 에 대하여 <span class="arithmatex">\(G \vDash A\)</span> 이다.</p>
</li>
<li>
<p>추론규칙을 <span class="arithmatex">\(n+1\)</span> 단계에 적용하여 <span class="arithmatex">\(G\)</span> 가 <span class="arithmatex">\(B\)</span> 를 도출했다면 <span class="arithmatex">\(G \vDash B\)</span> 이다.</p>
</li>
</ol>
</li>
</ol>
<p>a), b) 는 <span class="arithmatex">\(G\)</span> 의 원소인 명제가 <span class="arithmatex">\(G\)</span> 에 함의된다는 것을 말해준다. c) 는 <span class="arithmatex">\(A\)</span> 가 증명가능하면 추론규칙이 적용된 정리, 가령 <span class="arithmatex">\(A \lor B\)</span> 도 증명가능하다는 것을 말해준다. 그러면 <span class="arithmatex">\(G\)</span> 를 참으로 만드는 임의의 평가는 <span class="arithmatex">\(A\)</span> 도 참으로 만든다. 이렇게 증명은 귀납적으로 분석 가능하므로, 일반적으로 모든 추론 규칙이 의미적 함의를 보존한다는 것을 검증함으로써 건전성을 증명할 수 있다. </p>
</li>
</ul>
<a href="#0a849448c"><div class="admonition def" id="0a849448c">
<p>극대 집합(Maximal Set) : 어떤 조건을 만족하는 가장 큰 집합이다.</p>
</div></a>
<a href="#27f0fcb49"><div class="admonition def" id="27f0fcb49">
<p>Order type : 순서 집합 <span class="arithmatex">\(X, Y\)</span> 이 다음 동치명제를 만족하면 같은 order type 을 갖는다고 한다. </p>
<ol>
<li>
<p><span class="arithmatex">\(X, Y\)</span> 가 순서동형이다. </p>
</li>
<li>
<p><span class="arithmatex">\(X\)</span> 와 <span class="arithmatex">\(Y\)</span> 사이에 전단사 사상이 존재한다.</p>
</li>
</ol>
</div></a>
<ul>
<li>
<p>모든 정렬집합은 하나의 서수와 대응된다. </p>
<ul>
<li>
<p>예시</p>
<p><span class="arithmatex">\(\N\)</span> 의 order type 은 <span class="arithmatex">\(\omega\)</span> 이다.</p>
</li>
</ul>
</li>
<li>
<p>정렬 집합 <span class="arithmatex">\(V\)</span> 의 order type 은 <span class="arithmatex">\(\text{ord}(V)\)</span> 로 표현된다. 즉 <span class="arithmatex">\(\text{ord}(\N) = \omega\)</span> 이다.</p>
</li>
<li>
<p>예시</p>
<p><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/OrderTypeExamples_svg.svg/1143px-OrderTypeExamples_svg.svg.png"/></p>
</li>
<li>
<p>예시 </p>
<p><span class="arithmatex">\(\mathbb{Z}\)</span> 집합은 짝수 집합과 같은 order type 을 갖는다. 두 집합 사이에 <span class="arithmatex">\(n \mapsto 2n\)</span> 이라는 전단사 사상이 존재하기 때문이다.</p>
<p>반면 <span class="arithmatex">\(\mathbb{Z}\)</span> 는 <span class="arithmatex">\(\mathbb{Q}\)</span> 에 대하여 <span class="arithmatex">\(\mathbb{Z} \approx \mathbb{Q}\)</span> 이지만, 같은 order type 을 갖지는 않는다. 왜냐하면 두 집합 모두 가산 무한 집합이지만, 두 집합 사이에 순서를 보존하는 전단사 사상은 존재하지 않기 때문이다.</p>
</li>
<li>
<p>예시 </p>
<p><span class="arithmatex">\(\omega \cdot 2 + 7\)</span> 보다 작은 짝수 서수는 </p>
<div class="arithmatex">\[ V = \{0,2,4, \dots; \omega , \omega +2, \omega +4, \dots; \omega 2, \omega 2 + 2, \omega 2 + 4, \omega 2 + 6\} \]</div>
<p>인데, 이것의 order type 은 </p>
<div class="arithmatex">\[ \text{ord}(V) = \omega 2 + 4 = \{0,1,2, \dots; \omega , \omega +1, \omega +2, \dots; \omega 2, \omega 2 + 1, \omega 2 + 2, \omega 2 + 3\} \]</div>
<p>이다. 왜냐하면 가산 무한 집합이 <span class="arithmatex">\(2\)</span>개 있고, 그 이후에 <span class="arithmatex">\(4\)</span>개의 원소가 있기 때문이다.</p>
</li>
<li>
<p>임의의 가산 전순서 집합은 <span class="arithmatex">\(\mathbb{Q}\)</span> 에 순서를 보존하면서 단사될 수 있다. 임의의 조밀한(dense) 가산 전순서 집합은 극대 원소나 극소 원소가 순서를 보존하면서 <span class="arithmatex">\(\mathbb{Q}\)</span> 로 전단사 될 수 없기 때문이다.</p>
<p>일반적으로 <span class="arithmatex">\(\mathbb{Q}\)</span> 의 order type 을 <span class="arithmatex">\(\eta\)</span> 로 표기한다.</p>
</li>
</ul>
<a href="#6d62c4f10"><div class="admonition def" id="6d62c4f10">
<p>완전성(completeness) : 형식 체계의 성질 "임의의 명제가 참이면 증명가능하다" 이다.</p>
</div></a>
<ul>
<li>
<p>추론 규칙의 핵심적인 성질은 건전성(sound) 과 완전성(complete) 이다. 쉽게 말해 이 성질은 추론 규칙이 올바르고, 다른 추론규칙이 필요하지 않다는 뜻이다. 건전성과 완전성에 대한 증명은 명제 논리 안에서의 증명이 아니라 명제 논리의 속성을 증명하기 위하여 메타이론(metatheory) 로써 사용되는 ZFC 에서의 증명이다.</p>
</li>
<li>
<p>완전성은 형식체계의 임의의 명제가 참이라면 증명할 수 있다는 성질이다.</p>
<p>완전성이란 <span class="arithmatex">\(\Sigma \vDash \Phi \implies \Sigma \vdash \Phi\)</span> 이다. 만약 <span class="arithmatex">\(\Sigma\)</span> 가 주어졌을 때 <span class="arithmatex">\(\Phi\)</span> 가 참이면 <span class="arithmatex">\(\Sigma\)</span> 로부터 <span class="arithmatex">\(\Phi\)</span> 를 증명할 수 있다는 것이다. 즉, "임의의 명제가 참이라면 증명 가능하다" 는 것이 완전성이다.</p>
</li>
<li>
<p>건전성이 "증명할 수 있다면 그것은 참이다" 이고, 완전성이 "참이면 증명할 수 있다" 이므로 이 둘은 서로 역관계이다.</p>
</li>
<li>
<p>우리가 바라는 이상적인 형식 체계는 완전성과 건전성이 성립하는 체계일 것이다.</p>
</li>
<li>
<p>완전성 증명은 일반적으로 다음과 같이 이루어진다.</p>
<p>완전성 증명은 <span class="arithmatex">\(G \vDash A \implies G \vdash A\)</span> 을 보이는 것이다. 이때 대우명제 <span class="arithmatex">\(G \not \vdash A \implies G \not \vDash A\)</span> 를 보이자. 만약 <span class="arithmatex">\(A\)</span> 는 거짓이 되고 <span class="arithmatex">\(G\)</span> 는 참이 되는 모델이 존재하면, <span class="arithmatex">\(G \not \vDash A\)</span> 이다. 그러므로 <span class="arithmatex">\(G \not \vdash A\)</span> 라는 가정으로부터 그러한 모델이 존재한다는 것을 보이면, 완전성 증명이 끝난다.</p>
<ol>
<li>
<p><span class="arithmatex">\(G \not \vdash A\)</span> (가정)</p>
</li>
<li>
<p><span class="arithmatex">\(G \not \vdash A\)</span> 이므로 <span class="arithmatex">\(G ^{*} \not \vdash A, G \subset G ^{*}\)</span> 인  극대집합 <span class="arithmatex">\(G ^{*}\)</span> 를 정의할 수 있다. <span class="arithmatex">\(G ^{*}\)</span> 는 무한집합일 수도 있다.</p>
<ol>
<li>
<p>order type <span class="arithmatex">\(\omega\)</span> 로 language 의 모든 명제에 명제의 길이에 의한 순서 관계를 부여하자. 그러면 가장 짧은 명제가 맨앞에 있을 것이다. 길이가 같은 것들은 사전순서로 순서를 결정하면 된다. 그러면 모든 명제에 순서가 부여되는데 이 명제들에 숫자를 부여하여 <span class="arithmatex">\(E_1, E_2, \dots\)</span> 와 같이 나타내자. </p>
</li>
<li>
<p>집합 <span class="arithmatex">\(G_0, G_1, \dots\)</span> 의 집합 <span class="arithmatex">\(G_n\)</span> 을 다음과 같이 귀납적으로 정의하자.</p>
<ul>
<li>
<p><span class="arithmatex">\(G_0 = G\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(G_k \cup \{E _{k+1}\} \vdash A \implies G _{k+1} = G_k\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(G_k \cup \{E _{k+1}\} \not \vdash A \implies G _{k+1} = G_k \cup \{E _{k+1}\}\)</span></p>
</li>
</ul>
</li>
<li>
<p><span class="arithmatex">\(G ^{*}\)</span> 를 <span class="arithmatex">\(\displaystyle  G ^{*} = \bigcup_{i \in \N}^{}G_i\)</span> 와 같이 정의하자.</p>
</li>
<li>
<p>그러면 우선 <span class="arithmatex">\(G ^{*}\)</span> 는 <span class="arithmatex">\(G\)</span> 를 포함하게 된다. ▲ 또한 <span class="arithmatex">\(G ^{*}\)</span> 는 <span class="arithmatex">\(A\)</span> 를 증명하지 않는다. 왜냐하면 증명은 유한한 명제의 집합이고, 그 증명의 마지막 명제가 어떤 <span class="arithmatex">\(G_n\)</span> 에 포함된다고 하면 <span class="arithmatex">\(G_n\)</span> 이 <span class="arithmatex">\(A\)</span> 를 증명하게 되는데 이는 <span class="arithmatex">\(G_n\)</span> 의 정의에 위배되기 때문이다. ▲ 또한 <span class="arithmatex">\(G ^{*}\)</span> 는 <span class="arithmatex">\(A\)</span> 에 대한 극대 집합이다. 만약 <span class="arithmatex">\(G ^{*}\)</span> 에 어떤 명제가 추가되면 <span class="arithmatex">\(G ^{*}\)</span> 는 <span class="arithmatex">\(A\)</span> 를 증명하게 된다. 왜냐하면 <span class="arithmatex">\(G ^{*}\)</span> 에 어떤 명제가 추가될 수 있었다면 <span class="arithmatex">\(G_n\)</span> 의 정의에 의하여 그것은 이미 반드시 추가되었을 것이기 때문이다.</p>
</li>
</ol>
</li>
<li>
<p>만약 <span class="arithmatex">\(G ^{*}\)</span> 가 <span class="arithmatex">\(A\)</span> 에 대하여 극대 집합이면 이것은 무모순성을 갖는다. 즉, 임의의 명제 <span class="arithmatex">\(C\)</span> 에 대하여 <span class="arithmatex">\(C \in G ^{*} \iff \lnot C \not\in G ^{*}\)</span> 이다. 이것을 보이기 위하여 이 공리 체계가 다음을 만족할 수 있도록 강력하다는 것을 보여야 한다. </p>
<ul>
<li>
<p>임의의 명제 <span class="arithmatex">\(C, D\)</span> 에 대하여 공리 체계가 <span class="arithmatex">\(C\)</span> 와 <span class="arithmatex">\(\lnot C\)</span> 를 증명한다면 <span class="arithmatex">\(D\)</span> 도 증명한다. 이로써 <span class="arithmatex">\(A\)</span> 에 대한 극대집합 <span class="arithmatex">\(G ^{*}\)</span> 는 <span class="arithmatex">\(C\)</span> 와 <span class="arithmatex">\(\lnot C\)</span> 를 동시에 증명할 수 없어야 한다.</p>
</li>
<li>
<p>임의의 명제 <span class="arithmatex">\(C, D\)</span> 에 대하여 공리 체계가 <span class="arithmatex">\(C \to D\)</span> 와 <span class="arithmatex">\(\lnot C \to D\)</span> 를 증명한다면 <span class="arithmatex">\(D\)</span> 도 증명한다. 이로써 <span class="arithmatex">\(G ^{*}\)</span> 는 <span class="arithmatex">\(C \to D\)</span> 와 <span class="arithmatex">\(\lnot C \to D\)</span> 를 동시에 증명할 수 없어야 한다.</p>
<p>이것은 연역 정리(deduction theorem) 와 함께 임의의 명제가 그것의 부정문과 함께 <span class="arithmatex">\(G ^{*}\)</span> 에 포함됨을 보이기 위하여 사용된다. 가령 <span class="arithmatex">\(B\)</span> 가 <span class="arithmatex">\(G ^{*}\)</span> 에 속하지 않았다면 <span class="arithmatex">\(B \cup G ^{*}\)</span> 는 <span class="arithmatex">\(A\)</span> 를 증명한다. 이때 연역 정리에 의하여 <span class="arithmatex">\(G ^{*}\)</span> 는 <span class="arithmatex">\(B \to A\)</span> 를 증명한다. 그러나 <span class="arithmatex">\(\lnot B\)</span> 도 <span class="arithmatex">\(G ^{*}\)</span> 에 속하지 않는다고 가정하면 동일한 논리로 <span class="arithmatex">\(\lnot B \to A\)</span> 도 증명 가능하다. 그러나 이로써 우리가 거짓이라고 증명했던 <span class="arithmatex">\(G ^{*}\)</span> 가 <span class="arithmatex">\(A\)</span> 를 증명한다는 것이 참이 된다.</p>
</li>
<li>
<p>임의의 명제 <span class="arithmatex">\(C, D\)</span> 에 대하여 공리 체계가 <span class="arithmatex">\(C, D\)</span> 를 증명한다면 <span class="arithmatex">\(C \to D\)</span> 도 증명한다.</p>
</li>
<li>
<p>임의의 명제 <span class="arithmatex">\(C, D\)</span> 에 대하여 공리 체계가 <span class="arithmatex">\(C, \lnot  D\)</span> 를 증명한다면 <span class="arithmatex">\(\lnot (C \to D)\)</span> 도 증명한다.</p>
</li>
<li>
<p>임의의 명제 <span class="arithmatex">\(C, D\)</span> 에 대하여 공리 체계가 <span class="arithmatex">\(\lnot C\)</span> 를 증명한다면 <span class="arithmatex">\(C \to D\)</span> 도 증명한다.</p>
</li>
</ul>
<p>만약 <span class="arithmatex">\(\land, \lor\)</span> 같은 추가적인 논리 연산이 존재한다면, "공리 체계가 <span class="arithmatex">\(C, D\)</span> 를 증명한다면 <span class="arithmatex">\(C \land D\)</span> 도 증명한다" 같은 추가적인 조건이 요구된다.</p>
</li>
<li>
<p>만약 <span class="arithmatex">\(G ^{*}\)</span> 가 무모순성을 갖는다면, <span class="arithmatex">\(G ^{*}\)</span> 에 속한 모든 명제가 참이고 그 이외의 명제는 거짓이라는 <span class="arithmatex">\(G ^{*}\)</span> 에 대한 평가(Canonical valuation of the language)가 존재한다.</p>
</li>
<li>
<p>그러면 그 <span class="arithmatex">\(G ^{*}\)</span> 에 대한 평가는 원래의 집합 <span class="arithmatex">\(G\)</span> 를 참으로 만들고 <span class="arithmatex">\(A\)</span> 를 거짓으로 만든다. </p>
</li>
<li>
<p><span class="arithmatex">\(G\)</span> 가 참이고 <span class="arithmatex">\(A\)</span> 가 거짓이라는 평가(valutation)가 존재하면 <span class="arithmatex">\(G \not \vDash A\)</span> 이다.</p>
</li>
</ol>
<p>이로써 <span class="arithmatex">\(G \not \vdash A \implies G \not \vDash A\)</span> 가 증명되었고, 그 대우명제 <span class="arithmatex">\(G \vDash A \implies G \vdash A\)</span> 도 증명되었다. </p>
<p>위에서 본 것과 같이 전건 긍정을 추론 규칙으로 가지고 다음 정리를 증명할 수 있는 모든 체계는 완전성을 갖는다. 처음 5개 정리는 c) 단계에서 필요한 작업이고, 나머지 3개는 deduction theorem 을 증명하기 위한 정리이다.</p>
<ul>
<li>
<p><span class="arithmatex">\(p \to (\lnot p \to q)\)</span></p>
</li>
<li>
<p><span class="arithmatex">\((p \to q) \to ((\lnot p \to q) \to q)\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(p \to (q \to (p \to q))\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(p \to (\lnot q \to \lnot (p \to q))\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(\lnot p \to (p \to q)\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(p \to p\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(p \to (q \to p)\)</span></p>
</li>
<li>
<p><span class="arithmatex">\((p \to (q \to r)) \to ((p \to q) \to (p \to r))\)</span></p>
</li>
</ul>
</li>
<li>
<p>완전성 증명에 대한 또 다른 증명법은 다음과 같다. </p>
<p>어떤 명제가 tautology 라면 그 명제를 참이라고 평가하는 진리표가 존재한다. 그 평가를 생각하자. 명제의 길이에 대한 수학적 귀납법으로 명제 변수에 따르는 명제들이 참인지 거짓인지 평가할 수 있다. "(참인 <span class="arithmatex">\(P\)</span> 에 대하여 <span class="arithmatex">\(P \vDash S\)</span> 이다) <span class="arithmatex">\(\vDash\)</span> ((거짓인 <span class="arithmatex">\(P\)</span> 에 대하여 <span class="arithmatex">\(P \vDash S\)</span>) <span class="arithmatex">\(\vDash S\)</span>) 이다." 를 모든 명제 변수의 의존성이 해결될 때까지 반복한다면 주어진 tautology 는 증명가능하고 해당 논리 체계는 완전하다.</p>
<p>(<em>이게 뭔 소릴까 대체. 영문 위키도 그렇게 매번 속 시원한 설명을 주지는 않네.</em>)</p>
</li>
</ul>
<h2 id="1">1차 논리<a class="headerlink" href="#1" title="Permanent link">¶</a></h2>
<a href="#5ad54ef60"><div class="admonition def" id="5ad54ef60">
<p>논의 영역(domain of discourse, universe of discourse, universal set, universe) : 형식적 논의의 대상이 되는 객체의 집합이다.</p>
</div></a>
<ul>
<li>
<p>set of domain of discourse 를 보통 기호 <span class="arithmatex">\(\mathbb{D}\)</span> 로 표현한다.</p>
</li>
<li>
<p>논의 영역은 1차 논리에서의 양화사의 범위로 표현된다. 가령 <span class="arithmatex">\(\forall x, (x ^{2} \neq 2)\)</span> 는 논의 영역이 명시되지 않아서 모호하다. 논의 영역은 <span class="arithmatex">\(\R\)</span> 이 될 수도 있고 <span class="arithmatex">\(\N\)</span> 이 될 수도 있다.</p>
</li>
</ul>
<a href="#4c48754f1"><div class="admonition def" id="4c48754f1">
<p>1차 논리(first-order logic, predicate logic) : 원소에 한정기호를 사용할 수 있고, 술어에 한정기호를 사용할 수 없는 형식 체계이다.</p>
</div></a>
<ul>
<li>
<p>명제 논리와 달리 변수에 한정기호를 사용할 수 있지만, 2차 논리와는 달리 변수들의 집합에 한정기호를 사용할 수 없다. 명제 논리는 1차 논리의 기반이 된다. 명제 논리와 달리 1차 논리는 술어와 양화사를 다룰 수 있다.</p>
</li>
<li>
<p>1차 논리에서는 완전성 정리, 콤팩트성 정리, 스콜렘 정리같은 메타 논리에서의 중요한 정리들이 성립한다.</p>
</li>
<li>
<p>1차 논리는 수학, 철학, 언어학, 컴퓨터 공학 등에서 사용된다.</p>
</li>
<li>
<p>1차 논리에서는 건전하면서 완전한 연역 체계들이 많이 존재한다.</p>
</li>
<li>
<p>논리 체계가 준결정가능성(semidecidable) 을 가져도, 상당히 많은 진전이 1차 논리 속에서의 자동 정리 증명(Automated theorem proving)을 통해서 이루어질 수 있다.</p>
</li>
<li>
<p>1차 논리는 수학의 기초로 여겨진다. 가령 페아노 공리계와 ZF 가 1차 논리에서 공리화되었다. 그러나 1차 논리는 자연수나 실수같은 무한한 정의역을 가진 구조를 설명할 수 있는 능력은 없다. 이들 두 구조는 2차 논리 같은 더 강력한 논리 체계로 설명가능하다.</p>
</li>
<li>
<p>술어는 논의 영역을 입력으로 받아서 참이나 거짓을 출력한다. </p>
<ul>
<li>
<p>예시 </p>
<p>"소크라테스는 철학자이다" 와 "플라톤은 철학자이다" 는 명제 논리에서 단지 <span class="arithmatex">\(p, q\)</span> 로 표현되어 서로 관계가 없어 보인다. 하지만 술어 "는(은) 철학자이다" 가 두 문장에 등장하므로 두 명제가 같은 구조로 되어 있음을 알 수 있고, 변수 "소크라테스" 와 "플라톤" 을 가짐을 알 수 있다. 1차 논리에서는 이와 같은 술어로 명제를 표현할 수 있다.</p>
</li>
</ul>
<p>술어간의 관계를 논리적 접속사로 표현할 수 있다. 가령 1차 논리의 명제 "A 가 철학자이면, A 는 학자이다." 의 진리값은 변수 A 에 의하여 결정된다.</p>
<p>이때 변수 A 에 양화사를 가하여 범위를 지정할 수 있다. 가령 "모든 A 에 대하여" 라는 식으로. </p>
<p>1차 논리에서의 부정을 살펴보면 "모든 A 에 대하여, A 가 철학자이면 A 는 학자이다." 의 부정은 "A 가 존재하는데, A 는 철학자이고 A 는 학자가 아니다." 이다.</p>
</li>
<li>
<p>1차 논리는 문법과 의미라는 두 개의 핵심 구성요소를 가진다. 문법은 어떤 기호로 구성된 명제가 잘 구성되었는지 결정하고, 의미는 어떤 명제의 의미를 결정한다.</p>
<p>자연어와 달리 1차 논리의 명제는 완벽하게 형식적이어서 어떤 명제가 잘 구성되었는지 기계적으로 결정할 수 있다. 잘 구성된 명제는 용어와 술어로 구성된다. 용어와 술어는 기호의 나열이다. 기호는 항상 같은 의미를 갖는 논리적 기호와 해석에 따라 의미가 달라지는 비논리적 기호로 구분된다. </p>
<p>가령 논리적 기호 <span class="arithmatex">\(\land\)</span> 는 항상 "그리고" 라는 의미를 가지는데, 비논리적 기호인 <span class="arithmatex">\(\text{Phil}(x)\)</span> 같은 술어는 해석에 따라서 "x 가 철학자(philosopher) 이다" 라거나 "x 가 Philip 이다" 라는 의미를 가진다.</p>
</li>
<li>
<p>1차 논리에서 사용되는 논리적 기호는 다음과 같다. </p>
<ul>
<li>
<p>양화사 기호 <span class="arithmatex">\(\forall\)</span> 는 보편 양화사이고, <span class="arithmatex">\(\exists\)</span> 는 존재 양화사로 사용된다. </p>
</li>
<li>
<p>논리 접속사 <span class="arithmatex">\(\land , \lor , \to , \leftrightarrow, \lnot\)</span> 가 사용된다.</p>
</li>
<li>
<p>괄호 <span class="arithmatex">\((, )\)</span> 와 대괄호 <span class="arithmatex">\(\{, \}, [, ]\)</span> 와 기타 구두점 <span class="arithmatex">\(.,"'\)</span> 등이 사용된다.</p>
</li>
<li>
<p>변수의 무한 집합을 표현하기 위하여 보통 <span class="arithmatex">\(x, y, z, \dots\)</span> 을 사용한다. </p>
</li>
<li>
<p>동등함을 표현하기 위하여 <span class="arithmatex">\(=\)</span> 를 사용한다. </p>
</li>
<li>
<p>참을 표현하기 위하여 <span class="arithmatex">\(\bot\)</span> 을, 거짓을 표현하기 위하여 <span class="arithmatex">\(\top\)</span> 을 사용한다. </p>
</li>
</ul>
</li>
<li>
<p><span class="arithmatex">\(0\)</span> 보다 큰 항수를 갖는 술어(관계) 기호: <span class="arithmatex">\(n\)</span> 항수를 갖는 술어는 <span class="arithmatex">\(n\)</span> 개의 객체의 관계를 표현한다. 가령 <span class="arithmatex">\(Q(x, y)\)</span> 는 "<span class="arithmatex">\(x\)</span> 가 <span class="arithmatex">\(y\)</span> 보다 크다" 는 관계를 표현한다. </p>
</li>
<li>
<p><span class="arithmatex">\(0\)</span> 보다 큰 항수를 갖는 함수 기호: 함수 기호는 일반적으로 <span class="arithmatex">\(f, g, h, \dots\)</span> 로 표현한다. 가령 <span class="arithmatex">\(f(x)\)</span> 는 "<span class="arithmatex">\(x\)</span> 의 가족" 을 뜻할 수도 있고 "<span class="arithmatex">\(-x\)</span>" 를 뜻할 수도 있다. <span class="arithmatex">\(g(x, y)\)</span> 는 "<span class="arithmatex">\(x+y\)</span>" 를 뜻할 수도 있다. 항수 <span class="arithmatex">\(0\)</span> 을 갖는 함수는 상수로써 보통 <span class="arithmatex">\(a,b,c\)</span> 로 표현된다. </p>
</li>
<li>
<p>Formation rule 은 1차 논리에서의 용어와 명제를 정의한다. </p>
<ul>
<li>
<p>용어 집합은 다음과 같이 귀납적으로 정의된다.</p>
<ol>
<li>
<p>변수들. 모든 변수는 용어이다. </p>
</li>
<li>
<p>함수들. <span class="arithmatex">\(n\)</span> 개의 파라미터를 갖는 임의의 함수 <span class="arithmatex">\(f(t_1, \dots,t_n)\)</span> 는 용어이다. </p>
</li>
</ol>
</li>
<li>
<p>식(formula) 집합은 다음과 같이 귀납적으로 정의된다.</p>
<ol>
<li>
<p>술어 기호들. <span class="arithmatex">\(n\)</span> 항수를 갖는 <span class="arithmatex">\(P(t_1, \dots, t_n)\)</span> 는 식이다.</p>
</li>
<li>
<p>동등성. <span class="arithmatex">\(t_1, t_2\)</span> 가 용어이면 <span class="arithmatex">\(t_1 = t_2\)</span> 는 식이다. </p>
</li>
<li>
<p>부정. <span class="arithmatex">\(\phi\)</span> 가 식이면 <span class="arithmatex">\(\lnot \phi\)</span> 도 식이다.</p>
</li>
<li>
<p>이항 연결사. <span class="arithmatex">\(\phi , \psi\)</span> 가 식이면 이항관계 <span class="arithmatex">\(R\)</span> 에 대하여 <span class="arithmatex">\(\phi R \psi\)</span> 도 식이다. 가령 <span class="arithmatex">\(\phi , \psi\)</span> 가 식이면 <span class="arithmatex">\(\phi \to \psi\)</span> 은 식이다.</p>
</li>
<li>
<p>양화사. <span class="arithmatex">\(\phi\)</span> 가 식이고, <span class="arithmatex">\(x\)</span> 가 변수이면 <span class="arithmatex">\(\forall x \phi\)</span> 이나 <span class="arithmatex">\(\exists x \phi\)</span> 는 식이다.</p>
</li>
</ol>
<p>1차 논리에서는 오직 위의 5가지 규칙을 유한하게 구성하여 얻어진 표현만 식이다. 가령 <span class="arithmatex">\(\forall xx \to\)</span> 는 식이 아니다.</p>
<p>참고로 첫번째와 두번쨰 규칙만 적용하여 얻은 식을 <a href="https://en.wikipedia.org/wiki/Atomic_formula">원자적 식(atomic formulas)</a> 라고 한다.</p>
<p>괄호는 모든 식이 유일한 귀납적 방법으로 생성되었음을 알려준다. 이는 모든 식이 유일한 <a href="https://en.wikipedia.org/wiki/Parse_tree">parse tree</a> 를 갖는 것을 말해준다.</p>
<p>위와 같은 1차 논리에서의 식은 다음과 같은 <a href="https://en.wikipedia.org/wiki/Backus-Naur_form">BNF 형식</a>으로도 표현할 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span>             <span class="o">::=</span> "" 
                    | <span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span> "'"
<span class="p">&lt;</span><span class="nc">variable</span><span class="p">&gt;</span>          <span class="o">::=</span> "x" <span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">constant</span><span class="p">&gt;</span>          <span class="o">::=</span> "c" <span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">unary function</span><span class="p">&gt;</span>    <span class="o">::=</span> "f1" <span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">binary function</span><span class="p">&gt;</span>   <span class="o">::=</span> "f2" <span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">ternary function</span><span class="p">&gt;</span>  <span class="o">::=</span> "f3" <span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">unary predicate</span><span class="p">&gt;</span>   <span class="o">::=</span> "p1" <span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">binary predicate</span><span class="p">&gt;</span>  <span class="o">::=</span> "p2" <span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">ternary predicate</span><span class="p">&gt;</span> <span class="o">::=</span> "p3" <span class="p">&lt;</span><span class="nc">index</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span>              <span class="o">::=</span> <span class="p">&lt;</span><span class="nc">variable</span><span class="p">&gt;</span> 
                    | <span class="p">&lt;</span><span class="nc">constant</span><span class="p">&gt;</span> 
                    | <span class="p">&lt;</span><span class="nc">unary function</span><span class="p">&gt;</span> "(" <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> ")" 
                    | <span class="p">&lt;</span><span class="nc">binary function</span><span class="p">&gt;</span> "(" <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> "," <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> ")" 
                    | <span class="p">&lt;</span><span class="nc">ternary function</span><span class="p">&gt;</span> "(" <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> "," <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> "," <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> ")"
<span class="p">&lt;</span><span class="nc">atomic formula</span><span class="p">&gt;</span>    <span class="o">::=</span> "TRUE" 
                    | "FALSE"
                    | <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> "=" <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span>
                    | <span class="p">&lt;</span><span class="nc">unary predicate</span><span class="p">&gt;</span> "(" <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> ")" 
                    | <span class="p">&lt;</span><span class="nc">binary predicate</span><span class="p">&gt;</span> "(" <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> "," <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> ")" 
                    | <span class="p">&lt;</span><span class="nc">ternary predicate</span><span class="p">&gt;</span> "(" <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> "," <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> "," <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> ")"
<span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span>           <span class="o">::=</span> <span class="p">&lt;</span><span class="nc">atomic formula</span><span class="p">&gt;</span> 
                    | "¬" <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span>
                    | <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span> "∧" <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span>
                    | <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span> "∨" <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span>
                    | <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span> "⇒" <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span>
                    | <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span> "⇔" <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span>
                    | "(" <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span> ")"
                    | "∀" <span class="p">&lt;</span><span class="nc">variable</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span>
                    | "∃" <span class="p">&lt;</span><span class="nc">variable</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nc">formula</span><span class="p">&gt;</span>
</code></pre></div>
</li>
</ul>
</li>
<li>
<p>1차 논리에서의 논리 연산자들은 먼저 계산되어야 할 우선순위를 갖는다.</p>
<ol>
<li>
<p><span class="arithmatex">\(\lnot\)</span> 이 가장 먼저 계산된다.</p>
</li>
<li>
<p><span class="arithmatex">\(\land, \lor\)</span> 이 다음으로 계산된다.</p>
</li>
<li>
<p>양화사가 다음으로 계산된다.</p>
</li>
<li>
<p><span class="arithmatex">\(\to\)</span> 가 마지막으로 계산된다.</p>
</li>
</ol>
<p>그러므로 <span class="arithmatex">\(\lnot \forall xP(x) \to \exists x \lnot P(x)\)</span> 를 </p>
<div class="arithmatex">\[ (\lnot [\forall xP(x)]) \to \exists x[\lnot P(x)] \]</div>
<p>로 표현하면 더 읽기 쉽다.</p>
</li>
<li>
<p>1차 논리에서의 식에 포함된 변수는 free 이거나 bound 이다. 쉽게 말하면 양화사에 속박된 변수를 bound 라고 생각하고, 그 이외의 변수를 free 로 생각하면 된다. 가령 <span class="arithmatex">\(\forall y P(x, y)\)</span> 에서 <span class="arithmatex">\(y\)</span> 는 bound 이고 <span class="arithmatex">\(x\)</span> 는 free 이다. free 와 bound 변수는 다음과 같이 귀납적으로 정의된다. </p>
<ol>
<li>
<p>원자적 식(atomic formulas): <span class="arithmatex">\(\phi\)</span> 가 원자적 식이면 <span class="arithmatex">\(\phi\)</span> 에 등장하는 변수는 free 이다. 원자적 식에 bound 변수는 존재하지 않는다. </p>
</li>
<li>
<p>부정: <span class="arithmatex">\(\lnot \phi\)</span> 에 나타나는 변수 <span class="arithmatex">\(x\)</span> 가 free 이면 <span class="arithmatex">\(\phi\)</span> 에 나타나는 변수 <span class="arithmatex">\(x\)</span> 도 free 이다. 마찬가지로 <span class="arithmatex">\(\phi\)</span> 의 변수가 bound 이면 <span class="arithmatex">\(\lnot \phi\)</span> 의 변수도 bound 이다.</p>
</li>
<li>
<p>이항 연결사: <span class="arithmatex">\(\phi\)</span> 나 <span class="arithmatex">\(\psi\)</span> 에서 <span class="arithmatex">\(x\)</span> 가 free 이면 이항 연결사 <span class="arithmatex">\(R\)</span> 에 대하여 <span class="arithmatex">\(\phi R \psi\)</span> 의 <span class="arithmatex">\(x\)</span> 도 free 이다. 가령 <span class="arithmatex">\(\phi\)</span> 에서 <span class="arithmatex">\(x\)</span> 가 free 이면 <span class="arithmatex">\(\phi \to \psi\)</span> 의 <span class="arithmatex">\(x\)</span> 도 free 이다. bound 의 경우도 마찬가지이다.</p>
</li>
<li>
<p>양화사: <span class="arithmatex">\(\forall y \phi\)</span> 의 변수 <span class="arithmatex">\(x\)</span> 가 free 이면 <span class="arithmatex">\(\phi\)</span> 에서도 free 이다. <span class="arithmatex">\(\forall y \phi\)</span> 의 <span class="arithmatex">\(x\)</span> 가 bound 이려면, <span class="arithmatex">\(x\)</span> 가 <span class="arithmatex">\(y\)</span> 이거나 <span class="arithmatex">\(\phi\)</span> 에서도 <span class="arithmatex">\(x\)</span> 가 bound 이어야 한다. <span class="arithmatex">\(\exists\)</span> 에서도 마찬가지이다.</p>
</li>
</ol>
</li>
<li>
<p>free 변수가 없는 식을 sentence 라고 한다.</p>
</li>
<li>
<p>예시 </p>
<p>아벨리안 순서군(ordered abelian groups) 은 상수 <span class="arithmatex">\(0\)</span>, 영항 함수 <span class="arithmatex">\(-\)</span>, 이항 함수 <span class="arithmatex">\(+\)</span>, 이항 관계 <span class="arithmatex">\(\leq\)</span> 를 갖는다. 아벨리안 순서군에서 <span class="arithmatex">\(x+y, x+y-z\)</span> 들은 용어이다. <span class="arithmatex">\(x+y=0, x+y-z \leq x+y\)</span> 들은 원자적 식이다. <span class="arithmatex">\(\forall x \forall y(x+y \leq z) \to \forall x \forall y(x+y=0)\)</span> 는 free 변수 <span class="arithmatex">\(z\)</span> 를 갖는 식이다.</p>
<p>아벨리안 순서군의 공리는 language 의 sentence 집합이다. 가령 군의 공리인 commutative 는 <span class="arithmatex">\((\forall x)(\forall y)[x+y=y+x]\)</span> 이다.</p>
</li>
<li>
<p>1차 논리의 해석은 language 의 비논리적 기호에 명시적 의미를 부여한다. 각각의 용어는 그것을 대표하는 객체를 부여받고, 술어는 객체의 속성을 부여받고, sentence 는 진리값을 부여받는다. 형식 언어의 해석에 대한 연구를 <a href="https://en.wikipedia.org/wiki/Semantics_of_logic">formal semantics</a> 라 한다. 이로써 1차 논리는 표준적인 또는 <a href="https://en.wikipedia.org/wiki/Semantic_theory_of_truth#Tarski.27s_Theory">Tarskian 의미</a> 를 부여받는다. 혹은 1차 논리에 <a href="https://en.wikipedia.org/wiki/Game_semantics#Classical_logic">게임 의미</a> 를 부여할 수도 있다.</p>
<p>논의 영역 <span class="arithmatex">\(\mathbb{D}\)</span> 는 객체들의 집합이다. 식은 이러한 객체들에 대한 문장이다. 가령 <span class="arithmatex">\(\exists xP(x)\)</span> 는 술어 <span class="arithmatex">\(P\)</span> 를 만족하는 객체 <span class="arithmatex">\(x\)</span> 의 존재성을 뜻한다. </p>
<p>함수 기호에 대한 해석은 함수이다. 가령 항수 <span class="arithmatex">\(2\)</span> 를 갖는 함수 기호 <span class="arithmatex">\(f\)</span> 는 두 정수의 합을 계산하는 함수로 해석 가능하다. 상수 기호는 항수 <span class="arithmatex">\(0\)</span> 을 갖는 함수로 해석한다. 가령 상수 기호 <span class="arithmatex">\(c\)</span> 를 <span class="arithmatex">\(I(c) = 10\)</span> 으로 해석할 수 있다. <span class="arithmatex">\(I\)</span> 는 해석을 뜻하는 메타 기호이다.</p>
<p>항수 <span class="arithmatex">\(n\)</span> 에 대한 술어는 논의 영역 <span class="arithmatex">\(\mathbb{D}\)</span> 에서 술어를 참이 되게 하는 <span class="arithmatex">\(n\)</span>-순서쌍으로 해석할 수 있다.</p>
<ul>
<li>
<p>1차 논리의 해석을 규정하는 가장 일반적인 방법은 구조(structure) 를 정의하는 것이다. 구조를 모델(model) 로도 부른다. 구조는 공집합이 아닌 <span class="arithmatex">\(\mathbb{D}\)</span> 와 비논리 기호의 해석 <span class="arithmatex">\(I\)</span> 를 갖는다. 해석은 그 자체로 다음과 같은 함수가 된다.</p>
<ul>
<li>
<p>항수 <span class="arithmatex">\(n\)</span> 인 함수 기호 <span class="arithmatex">\(f\)</span> 는 함수 <span class="arithmatex">\(I(f): \mathbb{D} ^{n} \to \mathbb{D}\)</span> 로 할당된다. 각가의 부호수기호들은 논의 영역의 객체로 할당된다. </p>
</li>
<li>
<p>항수 <span class="arithmatex">\(n\)</span> 인 술어 기호 <span class="arithmatex">\(P\)</span> 는 관계 <span class="arithmatex">\(I(P): \mathbb{D} ^{n} \to \{\bot , \top \}\)</span> 으로 할당된다.</p>
</li>
</ul>
</li>
</ul>
<p>식은 주어진 해석에 의하여 참이나 거짓을 부여받고, 논의 영역의 변수에 따르는 값 <span class="arithmatex">\(\mu\)</span> 를 할당받는다. 값의 할당이 필요한 이유는 <span class="arithmatex">\(y = x\)</span> 에서의 free 변수에 할당하기 위해서이다. 이 식의 진리값은 <span class="arithmatex">\(x, y\)</span> 에 따라 달라진다.</p>
<p>값 할당 <span class="arithmatex">\(\mu\)</span> 는 각각의 용어가 논의 영역 <span class="arithmatex">\(\mathbb{D}\)</span> 의 원소에 대응되는 결과에 의하여 language 의 모든 용어로 확장된다. 할당 규칙은 다음과 같다. </p>
<ol>
<li>
<p>변수들: 각각의 변수 <span class="arithmatex">\(x\)</span> 는 <span class="arithmatex">\(\mu (x)\)</span> 로 할당된다. </p>
</li>
<li>
<p>함수들: 논의 영역의 원소 <span class="arithmatex">\(d_1, \dots, d_n\)</span> 로 할당된 주어진 용어 <span class="arithmatex">\(t_1, \dots, t_n\)</span> 에 대하여 함수 기호 <span class="arithmatex">\(f\)</span> 의 용어 <span class="arithmatex">\(f(t_1, \dots, t_n)\)</span> 는 <span class="arithmatex">\((I(f))(d_1, \dots, d_n)\)</span> 으로 할당된다.</p>
</li>
</ol>
<p>이렇게 값이 할당된 이후에 각각의 식의 진리값이 할당된다. 다음과 같이 진리값을 귀납적으로 할당하는 귀납적 정의를 <a href="https://en.wikipedia.org/wiki/T-schema">T-schema</a> 라고 한다.</p>
<ol>
<li>
<p>원자적 식 1: <span class="arithmatex">\(\big &lt;v_1, \dots, v_n\big &gt; \in I(P)\)</span> 로 할당된 용어 <span class="arithmatex">\(t_1, \dots, t_n\)</span> 에 대한 식 <span class="arithmatex">\(P(t_1, \dots, t_n)\)</span> 의 진리값은 <span class="arithmatex">\(\big &lt;v_1, \dots, v_n\big &gt;\)</span> 의 값에 의존한다.</p>
</li>
<li>
<p>원자적 식 2: 식 <span class="arithmatex">\(t_1 = t_2\)</span> 는 <span class="arithmatex">\(t_1\)</span> 와 <span class="arithmatex">\(t_2\)</span> 에 할당된 <span class="arithmatex">\(\mathbb{D}\)</span> 의 객체가 같을 때 진리값 참을 부여받는다.</p>
</li>
<li>
<p>논리적 연결사: <span class="arithmatex">\(\lnot \phi , \phi \to \psi\)</span> 같은 식의 진리값은 명제 논리에서와 같이 논리 연산자의 진리표에 따라 부여된다. </p>
</li>
<li>
<p>존재 양화사: 식 <span class="arithmatex">\(\exists x \phi (x)\)</span> 는 <span class="arithmatex">\(x\)</span> 의 해석 값 <span class="arithmatex">\(\mu\)</span> 와 <span class="arithmatex">\(\phi\)</span> 의 해석 <span class="arithmatex">\(M\)</span> 에 대하여 <span class="arithmatex">\(M\)</span> 에서 술어 <span class="arithmatex">\(\phi\)</span> 를 참이 되게 하는 <span class="arithmatex">\(\mu\)</span> 와 다른  <span class="arithmatex">\(\mu '\)</span> 가 존재하면 참을 부여받는다. </p>
</li>
<li>
<p>보편 양화사: 식 <span class="arithmatex">\(\forall x \phi (x)\)</span> 는 <span class="arithmatex">\(x\)</span> 의 해석 값 <span class="arithmatex">\(\mu\)</span> 와 <span class="arithmatex">\(\phi\)</span> 의 해석 <span class="arithmatex">\(M\)</span> 에 따른 모든 페어가 식 <span class="arithmatex">\(\phi (x)\)</span> 을 참이 되게 할 때 참을 부여 받는다. </p>
</li>
</ol>
<p>주어진 해석 <span class="arithmatex">\(M\)</span> 에 대하여 sentence <span class="arithmatex">\(\phi\)</span> 가 참을 부여받으면 이를 <span class="arithmatex">\(M \vDash \phi\)</span> 라고 표기하며, sentence 가 어떤 해석 아래에서 참이면 statisfiable 하다고 한다.</p>
<p>식이 valid 하다는 것은 모든 해석에 대하여 참이라는 것이다. 이러한 식은 명제 논리의 tautology 와 비슷한 역할을 한다. </p>
<p>식 <span class="arithmatex">\(\phi\)</span> 가 식 <span class="arithmatex">\(\psi\)</span> 의 논리적 결과(logical consequence)라는 것은 <span class="arithmatex">\(\psi\)</span> 를 참으로 만드는 모든 해석이 <span class="arithmatex">\(\phi\)</span> 도 참으로 만든다는 것이다. 이것을 <span class="arithmatex">\(\phi \vDash \psi\)</span> 로 표기한다.</p>
</li>
<li>
<p>1차 논리에 의미를 부여하는 또 다른 방법은 추상 대수학을 통해서이다. 이 접근은 명제 논리에 대한 <a href="https://en.wikipedia.org/wiki/Lindenbaum%E2%80%93Tarski_algebra">Lindenbaum-Tarski algebra</a> 을 일반화한 것이다. 1차 논리의 양화사를 제거하는 방법이 다음과 같이 3 가지 있다. </p>
<ul>
<li>Cylindric 대수학, Polyadic 대수학, Predicate functor 논리 </li>
</ul>
<p>이 대수학들은 <a href="https://en.wikipedia.org/wiki/Two-element_Boolean_algebra">two-element Boolean 대수학</a> 을 적절히 확장한 lattice(격자)이다. Tarski 와 Givant 는 원자적 식을 갖지 않는 1차 논리의 파편이 relation algebra 와 같은 표현력을 갖는다는 것을 보였다. 이 파편은 사람들의 흥미를 끌었는데, 이것이 페아노 공리계와 ZFC 를 포함한 공리적 집합론들을 만족시켰기 때문이다.</p>
</li>
<li>
<p>한편 논의 영역 <span class="arithmatex">\(\mathbb{D}\)</span> 가 공집합인 경우도 존재한다.</p>
</li>
<li>
<p>1차 논리에서 동등함을 나타내기 위하여 기호 <span class="arithmatex">\(=\)</span> 를 사용하는데, 이것을 해석했을 때 실제로 동등함을 뜻하도록 하기 위하여 다음과 같은 공리를 추가한다. </p>
<ol>
<li>
<p>Reflexivity: 변수 <span class="arithmatex">\(x\)</span> 에 대하여 <span class="arithmatex">\(x=x\)</span> 이다.</p>
</li>
<li>
<p>Substitution for functions: 변수 <span class="arithmatex">\(x, y\)</span> 와 함수 기호 <span class="arithmatex">\(f\)</span> 에 대하여 <span class="arithmatex">\(x = y \to f(x) = f(y)\)</span> 이다. </p>
</li>
<li>
<p>Substitution for formulas: 변수 <span class="arithmatex">\(x, y\)</span> 와 식 기호 <span class="arithmatex">\(\phi (x)\)</span> 에 대하여 <span class="arithmatex">\(\phi '\)</span> 가 <span class="arithmatex">\(x\)</span> 를 <span class="arithmatex">\(y\)</span> 로 치환해서 얻은 식이라면, <span class="arithmatex">\(x = y \to (\phi \to \phi ')\)</span> 이다.</p>
</li>
</ol>
<p>이들은 공리꼴이므로 무한한 공리집합을 형성한다. 동등함에 관한 다른 성질들은 위 공리의 논리적 귀결이다. 가령 다음과 같은 성질들은 위 공리의 귀결에 불과하다. </p>
<ol>
<li>
<p>Symmetry: <span class="arithmatex">\(x = y \implies y = x\)</span></p>
</li>
<li>
<p>Transitivity: <span class="arithmatex">\(x = y \land y = z \implies x = z\)</span></p>
</li>
</ol>
</li>
<li>
<p>고차 논리가 아닌 1차 논리를 사용하는 주된 이유는 중요한 메타논리적 성질들이 성립하기 때문이다. 이 성질들은 1차 이론들에 개별적으로 적용되는 것이 아니라 1차 논리 전체에 적용된다. 이 성질들은 1차 이론의 모델을 구성할 수 있는 근본적인 도구를 제공해준다. 그 메타논리적 성질들은 다음과 같다. </p>
<ul>
<li>
<p>완전성과 결정불가능성: 괴델의 완전성 정리는 건전하고, 완전하고, effective 한 연역 체계가 1차 논리에 존재함을 말해준다. <span class="arithmatex">\(\phi\)</span> 가 <span class="arithmatex">\(\psi\)</span> 를 함의할 때 <span class="arithmatex">\(\phi\)</span> 가 임의의 기수를 가질 수 있으므로 논리적 도출 과정을 검증하는 것이 효율적으로 이루어질 수 없다. 그러나 <span class="arithmatex">\(\phi\)</span> 에서 도출된 <span class="arithmatex">\(\psi\)</span> 들을 유한하게 나열할 수 있어서 검증이 가능해진다. 즉, 1차 논리는 준결정가능성을 갖는다.</p>
<p>명제논리와 달리 1차 논리는 결정불가능성을 갖는다. 이는 어떤 식이 논리적으로 올바른지 검증하는 결정 절차가 존재하지 않는다는 것이다. 이는 알론조 처치와 앨런 튜링이 힐베르트가 제안한 <a href="https://en.wikipedia.org/wiki/Entscheidungsproblem">Entscheidungsproblem</a> 에 대답하려는 연구에 의하여 밝혀졌다. 이들의 증명은 1차 논리의 결정 문제의 해결불가능성과 정지 문제의 해결 불가능성에 대한 대응을 보이는 것이었다.</p>
<p>그러나 1차 논리보다는 약하지만 결정 절차가 존재하는 논리가 있는데, 명제 논리와 monadic predicate logic 등이 있다. monadic predicate logic 은 1차 논리에서 함수 기호를 제외하고 술어가 항수 <span class="arithmatex">\(0\)</span> 만을 가지도록 제한한 것이다. 1차 논리의 <a href="https://en.wikipedia.org/wiki/Guarded_logic">guarded fragment</a> 도 결정가능성을 갖고 Bernays-Schonfinkel class 도 결정 가능성을 갖는다.</p>
<p>1차 논리의 결정가능성을 갖는 부분집합을 연구하는 분야를 <a href="https://en.wikipedia.org/wiki/Description_logic">Description logic</a> 이라 한다.</p>
</li>
<li>
<p>뢰벤하임-스콜렘 정리: 이 정리는 기수 <span class="arithmatex">\(\lambda\)</span> 를 갖는 1차 이론이 무한한 모델을 가진다면, 1차 이론이 <span class="arithmatex">\(\lambda\)</span> 보다 같거나 큰 모든 무한 기수의 모델을 가진다는 것을 말해준다.</p>
<p>모델 이론의 초기 성과는 가산 집합인 부호수를 기반으로 하는 1차 논리의 언어로 가산성과 비가산성을 나타내는 것이 불가능하다는 것을 보인 것이다. 즉, 1차 논리 식 <span class="arithmatex">\(\phi (x)\)</span> 과 <span class="arithmatex">\(\phi\)</span> 를 만족하는 임의의 모델 <span class="arithmatex">\(M\)</span> 에 대하여, <span class="arithmatex">\(M\)</span> 이 가산이거나 비가산이면 식 <span class="arithmatex">\(\phi\)</span> 는 존재할 수 없다는 것이다.</p>
<p>이 정리는 무한한 구조가 1차 논리에서 categorical 하게 공리화될 수 없음을 말한다. 가령 오직 실수의 직선을 모델로 갖는 1차 논리는 존재하지 않는다. 이는 무한한 모델을 갖는 1차 논리는 반드시 연속체보다 큰 기수를 가지는 모델을 갖는다는 것이다. 그렇다면, 실수의 직선을 만족하는 모든 이론은 비표준 모델에 의하여 만족된다.</p>
<p>이 정리가 1차 집합 이론에 적용되면 스콜렘의 역설 같은 비직관적인 결과가 도출된다. </p>
</li>
<li>
<p>콤팩트성 정리: 1차 논리의 sentence 집합이 모델을 가지고, 그것의 모든 유한 부분집합이 모델을 갖는다는 것이다. 이는 식(formula)이 1차 논리의 무한 공리 집합에서 도출되었다면 그것은 유한 공리 집합의 논리적 도출이라는 것이다. 이 정리는 괴델이 그의 완전성 정리에서 도출한 정리이다. 이 정리는 모델 이론에서 모델을 구성하는 기본적인 도구가 된다. </p>
<p>콤팩트성 정리를 함의한 1차 논리에는 여러 제한이 있다. 가령 컴퓨터 공학에서 많은 상황이 그래프로 모델링되는데, 그러한 체계를 증명하는 것은 좋은 상태가 나쁜 상태로 도달하지 않는다는 것을 보이는 것이다. 하지만 콤팩트성 정리는 그래프가 1차 논리에서 elementary class 가 아님을 보여주고 식 <span class="arithmatex">\(x\)</span> 에서 <span class="arithmatex">\(y\)</span> 로 가는 경로를 뜻하는 식 <span class="arithmatex">\(\phi (x,y)\)</span> 가 존재하지 않음을 보여준다.</p>
</li>
<li>
<p>린드스트롬 정리(Lindstrom's theorem): 이 정리는 지금까지 논의한 메타논리적 성질이 1차 논리보다 강력한 논리 체계에서는 만족되지 못한다는 것을 말한다. 이 정리를 만족하는 논리 체계는 1차 논리를 포함하며 뢰벤하임-스콜렘 정리와 콤팩트성 정리를 만족하는 논리체계가 1차 논리와 동등하다는 것을 말해준다. </p>
</li>
</ul>
</li>
<li>
<p>1차 논리가 수학과 컴퓨터 공학을 형식화하기에 충분하지만, 그 표현력에 제한이 있다. 가령 1차 논리는 결정불가능성을 갖는다. 이는 증명가능성에 대한 건전하고 완전한 결정 과정이 존재하지 않음을 뜻한다. 이는 오직 두개의 변수를 갖는 1차 논리인 <span class="arithmatex">\(C_2\)</span> 같은 결정가능한 1차 논리의 부분집합에 대한 연구를 시작시켰다. </p>
<p>뢰벤하임-스콜렘 정리는 무한한 모델을 갖는 1차 이론이 모든 기수에 대한 무한 모델을 갖는다는 것을 말해준다. 즉, categorical 한 무한 모델을 갖는 1차 이론은 존재하지 않는다. 더 자세히 말해서 오로지 <span class="arithmatex">\(\N\)</span> 이나 <span class="arithmatex">\(\R\)</span> 을 논의 영역으로 갖는 1차 이론은 존재하지 않는다. 1차 논리의 확장인 무한 논리나 고차 논리는 무한 집합을 논의 영역으로 가져도 categorial 하게 공리화할 수 있다. 하지만 린드스트롬 정리에 의하여 1차 논리보다 강력한 논리 체계는 콤팩트성 정리나 뢰벤하임-스콜램 정리가 성립하지 않는다는 단점이 있다. </p>
<p>또한 1차 논리는 "모든 사람은 숨을 쉰다." 같은 간단한 자연어를 형식화할 수 있지만, 더 복잡한 자연어를 표현하기 어렵다. 자연어를 분석하려면 1차 논리보다 강력한 논리 체계가 필요하다.</p>
</li>
<li>
<p>1차 논리를 제한하거나 확장함으로써 얻어진 여러 변형이 있다. 가령 무한 논리는 무한한 크기의 식을 허용하고, 양화 논리는 가능성이나 필요성을 표현하는 기호를 도입했다.</p>
<ul>
<li>
<p>1차 논리는 다음과 같이 제한될 수 있다. <span class="arithmatex">\(\exists x \phi (x)\)</span> 는 <span class="arithmatex">\(\lnot \forall x \lnot \phi (x)\)</span> 로 표현될 수 있고, 그 역도 가능하다. 그러므로 <span class="arithmatex">\(\exists\)</span> 나 <span class="arithmatex">\(\forall\)</span> 중 하나를 제외할 수 있다. 마찬가지의 이유로 <span class="arithmatex">\(\land\)</span> 나 <span class="arithmatex">\(\lor\)</span> 중 하나를 제외시킬 수 있다. <span class="arithmatex">\(\land , \lor\)</span> 이나 <span class="arithmatex">\(\land , \land\)</span> 이나 <span class="arithmatex">\(\lnot , \to\)</span> 이나 NAND 나 NOR 만으로 다른 논리 연산자를 다 표현할 수 있다. 함수 기호도 제외시킬 수 있는데  상수 <span class="arithmatex">\(0\)</span> 을 술어 <span class="arithmatex">\(0(x)\)</span> 으로 표현하거나 함수 <span class="arithmatex">\(f(x)\)</span> 를 술어 <span class="arithmatex">\(F(x, y)\)</span> 로 표현하는 것이다.</p>
<p>1차 논리를 제한하면 추론 규칙이나 공리 꼴의 수를 줄일 수 있어서 메타 논리 증명이 짧아져서 편하다. </p>
</li>
<li>
<p>추가적인 양화사를 도입할 수도 있다. 가령 유일하게 존재한다는 것을 표현하기 위하여 <span class="arithmatex">\(\exists !xP(x)\)</span> 와 같이 <span class="arithmatex">\(\exists !\)</span> 를 도입하는 경우가 있다. 이는 <span class="arithmatex">\(\exists x (P(x) \land \forall y(P(y) \to (x=y)))\)</span> 의 축약이다. 이를 uniqeuenss quantification 이라 하고, branching quantifier 나 bounded quantifier 같은 양화사도 있다. </p>
</li>
<li>
<p>무한논리는 sentence 의 무한한 길이를 허용하는 것이다. 가령 <span class="arithmatex">\(\lor\)</span> 이나 <span class="arithmatex">\(\land\)</span> 를 무한히 이어붙이게 할 수도 있고, 무한한 변수에 양화사를 붙힐수도 있고, 무한한 항수를 가지는 함수나 관계를 허용할 수도 있다. 무한 논리는 위상수학와 모델 이론에서 자주 사용된다. 무한논리를 유한한 글자로 표현할 수 없기에 트리를 사용하기도 한다. 이때 사용하는 게 parse tree 이다. </p>
<p>무한논리에서 <span class="arithmatex">\(L _{\alpha \beta }\)</span> 와 같은 표현을 사용하는데 <span class="arithmatex">\(\alpha\)</span> 와 <span class="arithmatex">\(\beta\)</span> 는 기수이거나 <span class="arithmatex">\(\infty\)</span> 이다. 이로써 1차 논리의 서수를 <span class="arithmatex">\(L _{\omega \omega }\)</span> 로 표현할 수 있고, <span class="arithmatex">\(L _{\infty \omega }\)</span> 논리는 무한한 <span class="arithmatex">\(\lor , \land\)</span> 나 무한한 변수를 사용할 수 있게 한다. 요점은 논리 체계 <span class="arithmatex">\(L _{\kappa \omega }\)</span> 가 <span class="arithmatex">\(\kappa\)</span> 개 이하의 논리 연산자(<span class="arithmatex">\(\lor ,\land\)</span>) 의 사용을 허용한다는 것이다. </p>
<p><span class="arithmatex">\(L _{\kappa \infty }\)</span> 논리체계의 경우 무한한 변수에 양화사를 가할 수 있다. 즉, <span class="arithmatex">\(L _{\kappa \lambda }\)</span> 는 <span class="arithmatex">\(\lambda\)</span> 보다 작은 변수에 양화사를 가할 수 있고, <span class="arithmatex">\(\kappa\)</span> 보다 작은 길이의 논리 연산자(<span class="arithmatex">\(\land ,\lor\)</span>) 를 허용한다.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Intuitionistic_logic">직관 1차 논리(직관 논리, Intuitionistic first-order logic)</a> 는 고전적인 명제 논리가 아닌 직관을 사용한다. 가령 직관논리에서는 <span class="arithmatex">\(\lnot \lnot \phi \neq \phi\)</span> 이다.</p>
</li>
<li>
<p>1차 양화 논리는 좀 더 현실 세계의 논리를 표현해준다. 즉, "<span class="arithmatex">\(\phi\)</span> 가 필요하다" 나 "<span class="arithmatex">\(\phi\)</span> 가 가능하다" 같은 명제를 표현할 수 있다.</p>
</li>
<li>
<p>1차 퍼지 논리는 고전 명제 논리가 아닌 명제 퍼지 논리를 사용한다.</p>
</li>
</ul>
</li>
<li>
<p>1차 논리는 객체에 양화사를 사용할 수 있지만 술어에는 사용할 수 없다. 가령 <span class="arithmatex">\(\exists a(P(a))\)</span> 는 1차 논리에서 올바르지만 <span class="arithmatex">\(\exists P(P(a))\)</span> 는 올바르지 않다. 2차 논리는 1차 논리를 확장하여 후자의 명제도 올바르게 만든다.</p>
<p>1차 논리가 오직 하나의 의미(semantic)를 연구하는 것과 달리 2차 논리에는 가능한 몇몇의 의미가 존재한다. 2차 논리와 고차 논리에서의 의미는 full semantic 을 뜻한다. </p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Automated_theorem_proving">자동 정리 증명</a> 은 수학 정리의 증명을 찾는 컴퓨터 프로그램을 뜻한다. 증명을 찾는 것은 search space 가 매우 크기 때문에 정말 어렵고 사실은 NP 문제라서 컴퓨터로 해결하기에 불가능하다. 따라서 휴리스틱 알고리즘들이 많이 개발되었다. </p>
<p>비슷한 영역으로 <a href="https://en.wikipedia.org/wiki/Proof_verification">증명 검증</a> 이 있는데 자동 정리 증명보다 훨씬 적은 비용으로 인간이 만든 증명을 검증해줄 수 있다. 이런 프로그램들은 타입 이론같은 1차 논리보다 강력한 형식 체계를 사용한다. </p>
<p>자동 정리 증명은 어떤 알고리즘의 타당성을 검증하는 <a href="https://en.wikipedia.org/wiki/Formal_verification">형식 검증</a> 에도 사용될 수 있다. </p>
</li>
</ul>
<a href="#da0e2379c"><div class="admonition def" id="da0e2379c">
<p>부호수(signature) : 집합 <span class="arithmatex">\(S _{\text{func}}, S _{\text{rel}}\)</span> 과 함수 <span class="arithmatex">\(\text{ar}\)</span> 대하여 </p>
<div class="arithmatex">\[ \sigma = (S _{\text{func}}, S _{\text{rel}}, \text{ar}) \]</div>
<p>이다.</p>
</div></a>
<ul>
<li>
<p><span class="arithmatex">\(S _{\text{func}}\)</span> 은 함수 기호로써 가령 <span class="arithmatex">\(+, \times , 0, 1\)</span> 로 구성된다. <span class="arithmatex">\(S _{\text{rel}}\)</span> 은 관계 기호 혹은 술어로써 가령 <span class="arithmatex">\(\leq , \in\)</span> 로 구성된다. <span class="arithmatex">\(\text{ar}: S _{\text{func}} \cup S _{\text{rel}} \to \N\)</span> 은 모든 함수와 관계에 자연수를 부여하는 항수(arity)라고 부른다.</p>
<ul>
<li>영항수(0-ary) 함수기호를 상수라고 한다.</li>
</ul>
</li>
<li>
<p>부호수는 형식 언어에서 사용하는 비논리 기호의 집합이다. 1차 논리에서 사용되는 비논리적 기호는 술어(관계), 함수, 논의 영역을 지칭하는 집합 등을 표현한다. </p>
<ul>
<li>
<p>예시 </p>
<p>군에서는 부호수가 <span class="arithmatex">\(\{1, \times \}\)</span> 이고, 순서체에서는 <span class="arithmatex">\(\{0,1,+,\times , &lt;\}\)</span> 이다. </p>
</li>
</ul>
<p>하지만 비논리 기호에 제한은 없다. 부호수는 공집합일 수 있고, 유한할 수도 있고, 무한할 수도 있고, 비가산 집합일 수도 있다. 비가산 부호수는 뢰벤하임-스콜렘 정리의 증명에서 등장한다. </p>
<ul>
<li>
<p>예시 </p>
<p>무한 부호수는 무한 스칼라 체 <span class="arithmatex">\(F\)</span> 에 대하여 <span class="arithmatex">\(S _{\text{func}} = \{+\} \cup \{f_a:a \in F\}\)</span> 와 <span class="arithmatex">\(S _{\text{rel}} = \{=\}\)</span> 를 사용하여 벡터 공간을 형식화하는데 사용된다. <span class="arithmatex">\(f_a\)</span> 는 <span class="arithmatex">\(a\)</span> 에 의한 스칼라곱 단항 연산을 표현하는데 사용된다.</p>
</li>
</ul>
</li>
<li>
<p>부호수에서 함수기호 <span class="arithmatex">\(S _{\text{func}}\)</span> 가 없는 것을 관계 부호수(relational signature) 라고 하고, 부호수에서 관계기호 <span class="arithmatex">\(S _{\text{rel}}\)</span> 가 없는 것을 대수적 부호수라고 한다. 집합 <span class="arithmatex">\(S _{\text{func}}\)</span> 과 <span class="arithmatex">\(S _{\text{rel}}\)</span> 유한하면 유한 부호수(finite signature) 라고 한다.</p>
</li>
<li>
<p>부호수 <span class="arithmatex">\(\sigma = (S _{\text{func}}, S _{\text{rel}}, \text{ar})\)</span> 의 기수는 </p>
<div class="arithmatex">\[ |\sigma | = | S _{\text{func}} | + | S _{\text{rel}} | \]</div>
<p>와 같이 정의된다. 한편 부호수 <span class="arithmatex">\(\sigma\)</span> 를 갖는 language <span class="arithmatex">\(L\)</span> 의 기수는 거의 언제나 무한이다. 만약 <span class="arithmatex">\(\sigma\)</span> 가 유한하면 <span class="arithmatex">\(L\)</span> 의 기수는 <span class="arithmatex">\(\aleph _0\)</span> 이다.</p>
</li>
<li>
<p>language of signature 는 해당 부호수의 기호로 구성된 모든 잘 구성된 sentence 의 집합이다.</p>
</li>
<li>
<p>보편 대수학에서 부호수는 대수 구조를 특징짓는 연산의 리스트이다. 모델이론에서 부호수는 비논리 기호를 표현하는데에도 사용되고, 연산 기호의 집합을 표현하는데에도 사용된다.</p>
<p>보편 대수학에서 부호수는 타입(type) 으로도 불리고, 모델이론에서 부호수를 단어(vocabulary) 라고도 부른다.</p>
</li>
<li>
<p>부호수의 정확한 정의를 매번 내리는 것이 불편하므로 부호수는 종종 비형식적인 방식으로 편하게 정의된다. </p>
<ul>
<li>
<p>예시 </p>
<p>가환군의 부호수는 종종 <span class="arithmatex">\(\sigma = (+,-,0)\)</span> 으로 정의된다.</p>
</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>우리에게 필요한 것은 자동 정리 증명에 딥러닝이나 머신러닝을 적용하여 그것의 성능을 최대한 올리는 것이고, GEB 나 TS is near 에서 말했듯 다루고 있는 체계보다 상위 체계에서 하위 체계를 다룰 수 있는 능력이다. 이것으로 기계적인 수준의 정리들에 의미를 부여하거나 결정불가능한 정리도 "결정불가능하다" 는 결론을 내려줄 수 있다. </p>
<p>상위 체계로 도약할 수 있는 능력을 부여한다면, 하위 체계에서 상위체계로 도약하는 행위 자체를 추상화시킬 수 있다는 것을 학습시킬 수 있다.</p>
</div>
<a href="#fa3b336f2"><div class="admonition def" id="fa3b336f2">
<p>1차 이론(first-order theory) : 1차 논리에서 1차 이론이란 부호수의 기호로 구성된 sentence 인 공리들의 집합이다.</p>
</div></a>
<ul>
<li>
<p>공리들의 집합은 유한하거나 <a href="https://en.wikipedia.org/wiki/Recursively_enumerable">재귀적으로 열거가능</a>해야 한다. 이 경우 이론이 effective 하다고 한다. 종종 이론은 공리의 모든 논리적 귀결 또한 포함해야 한다고 여겨진다.</p>
</li>
<li>
<p>주어진 이론의 모든 sentence 를 만족하는 1차 구조(structure) 를 이론의 모델(model) 이라고 한다. elementary class 는 주어진 이론을 만족하는 모든 구조의 집합이다. 이러한 class 는 모델 이론의 주요 연구 대상이다.</p>
</li>
<li>
<p>대부분의 이론은 의도된 해석을 가진다. 가령 페아노 공리계의 의도된 해석은 우리가 일상에서 사용하던 자연수이다. 그러나 뢰벤하임-스콜렘 정리는 거의 모든 1차 이론이 비표준 모델을 갖는다는 것을 보여준다. 비표준 모델이란 표준 모델에 대한 동형사상을 갖는 이론의 또 다른 모델이다.</p>
</li>
<li>
<p>1차 이론이 일관적이라는 것(무모순성, consistent)은 주어진 이론의 공리가 모순을 도출하지 않는다는 것이고, 1차 이론이 완전하다는 것은 부호수의 모든 식이 공리로부터 도출된다는 것이다.</p>
<p>그러나 괴델의 불완전성 정리는 자연수 이론을 만족하는 effective 한 이론은 일관성과 완전성을 동시에 만족할 수 없음을 보여준다.</p>
</li>
<li>
<p>예시 </p>
<p>순서, 격자, 군, 환, 체, 기하학, 미분 대수, 자연수, 산술, 집합론 등이 1차 이론이다.</p>
</li>
</ul>
<a href="#03c9f76ab"><div class="admonition def" id="03c9f76ab">
<p>연역 체계 : 1차 논리에서 연역 체계란 순수하게 추론 규칙만으로 어떤 식이 다른 식의 논리적 귀결임을 보이려하는 형식 체계이다.</p>
</div></a>
<ul>
<li>
<p>1차 논리에서 힐베르트 연역 체계, 자연 연역, 시퀸트 계산, tableaux method, resolution 등이 연역 체계이다. 이들은 연역이 유한적으로 구성되어야 한다는 속성을 갖는다. 이러한 유한한 연역을 증명 이론에서는 derivation 이라고 한다. 이 유한한 연역을 증명이라고 부르지만, 이는 자연어에 의한 증명과는 달리 완벽하게 형식화되었다.</p>
</li>
<li>
<p>연역 체계가 건전하다(sound)는 것은 증명된 식이 의미적으로 올바르다는 것이고, 완전하다(complete)는 것은 모든 올바른 식이 증명가능하다는 것이다. </p>
</li>
<li>
<p>연역 체계의 핵심 성질이 명제가 순수하게 변형 규칙에 의하여 도출되므로, 연역 체계에서는 명제의 의미를 해석할 필요 없이 명제의 참과 거짓을 검증할 수 있다.</p>
</li>
<li>
<p>일반적으로 1차 논리의 논리적 결론들은 <a href="https://en.wikipedia.org/wiki/Decidability_(logic)#Semidecidability">준결정적</a>이다. </p>
</li>
<li>
<p>추론 규칙(연역 규칙) 은 가정이 되는 명제 집합에서 결론을 이끌어낸다. 이때 추론 규칙이 건전하다(sound, truth-preserving)는 것은 참인 가정에 이 규칙을 적용하여 도출한 결론도 참이라는 것이다.</p>
<ul>
<li>
<p>예시 </p>
<p>추론 규칙의 한 예시는 치환이다. 용어 <span class="arithmatex">\(t\)</span> 와 변수 <span class="arithmatex">\(x\)</span> 를 갖는 식 <span class="arithmatex">\(\phi\)</span> 에 대하여 <span class="arithmatex">\(\phi [t/x]\)</span> 는 <span class="arithmatex">\(x\)</span> 를 <span class="arithmatex">\(t\)</span> 로 치환한 명제이다. </p>
</li>
</ul>
<p>치환 규칙에서는 <span class="arithmatex">\(t\)</span> 의 free 변수가 치환 도중에 bound 될 수 없다. 가령 산술 부호수<span class="arithmatex">\((0,1,+,\times,=)\)</span> 위에서 정의된 식 <span class="arithmatex">\(\phi\)</span> 가 <span class="arithmatex">\(\exists x(x=y)\)</span> 라고 하자. 이때 용어 <span class="arithmatex">\(t\)</span> 를 <span class="arithmatex">\(x+1\)</span> 라고 하면 식 <span class="arithmatex">\(\phi [t/y]\)</span> 는 <span class="arithmatex">\(\exists x(x=x+1)\)</span> 이 된다. 하지만 이것은 대다수의 해석이 거짓을 부여할 것이다. 이 문제는 <span class="arithmatex">\(t\)</span> 의 자유 변수 <span class="arithmatex">\(x\)</span> 가 치환 도중에 bound 되었기 때문이다. 이 상황에 대한 해결책은 식 <span class="arithmatex">\(\phi\)</span> 의 bound 변수 <span class="arithmatex">\(x\)</span> 를 <span class="arithmatex">\(z\)</span> 로 바꾸는 것이다. 그러면 <span class="arithmatex">\(\exists z(z=x+1)\)</span> 이 되어 참인 명제가 된다.</p>
<p>위와 같은 제한을 기반으로 추론 규칙을 적용해야 무의미한 기호들을 계속 연역해나가도 그것들이 해석했을 때 참인 명제라는 보장을 얻을 수 있다. 요점은 명제가 진리임을 보존하는 연역 규칙을 적용해야 한다.</p>
</li>
<li>
<p>예시 </p>
<p>힐베르트 스타일 체계는 논리적 공리를 갖는다. 논리적 공리는 공리꼴로 구성된다. 추론 규칙은 양화사를 조작할 수 있게 해준다. 힐베르트 스타일 체계의 특징은 매우 적은 추론 규칙과 무한한 논리적 공리의 공리꼴을 갖는다는 것이다. 보통 전건 긍정과 일반화(universal generalization) 만을 추론규칙으로 갖는다.</p>
<p>자연연역은 힐베르트 스타일 체계를 닮았다. 자연 연역은 논리 꼴은 갖지 않고 그 대신 추론 규칙을 좀 더 추가한다.</p>
</li>
<li>
<p>예시 </p>
<p>시퀸트 계산(Sequent calculus)은 자연 연역 체계의 성질을 연구하기 위하여 개발되었다. 시퀸트 계산은 한번에 하나의 식을 다루는 다음과 같은 형태의 대신 시퀸트를 다룬다.</p>
<div class="arithmatex">\[ A_1, \dots,A_n \vdash B_1, \dots, B_k \]</div>
<p>이 식은 <span class="arithmatex">\((A_1 \land \dots \land A_n) \implies (B_1 \lor \dots \lor B_k)\)</span> 라는 뜻이다.</p>
</li>
<li>
<p>예시 </p>
<p>Tableaux method 는 식의 나열을 다루지 않고, 트리 형태로 식을 다룬다. Tableaux 는 식 <span class="arithmatex">\(A\)</span> 가 증명가능하다는 것을 보이기 위하여 그 부정문 <span class="arithmatex">\(\lnot  A\)</span> 가 증명될 수 없음을 보인다.</p>
<p><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Prop-tableau-4.svg/225px-Prop-tableau-4.svg.png"/></p>
</li>
<li>
<p>예시 </p>
<p><a href="https://en.wikipedia.org/wiki/Resolution_(logic)">분해 증명(resolution)</a> 은 <a href="https://en.wikipedia.org/wiki/Unification_(computer_science)#Definition_of_unification_for_first-order_logic">unification</a> 과 함께 하나의 추론 규칙인데, 1차 논리에서 건전하고 완전하다.</p>
<p>tableaux 와 같이 어떤 식을 증명하기 위하여 그 부정문이 성립하지 않음을 보인다. 분해 증명은 자동 정리 증명에서 사용된다. </p>
</li>
</ul>
<h2 id="_3">형식 언어, 이론, 모델<a class="headerlink" href="#_3" title="Permanent link">¶</a></h2>
<a href="#b8a7f18a4"><div class="admonition def" id="b8a7f18a4">
<p>형식 언어(formal language) : 알파벳 <span class="arithmatex">\(\Sigma\)</span> 위의 형식 언어 <span class="arithmatex">\(L\)</span> 은 <span class="arithmatex">\(\Sigma ^{*}\)</span> 의 부분집합이다.</p>
</div></a>
<ul>
<li>
<p>형식 언어는 alphabet 을 기호로 한다. alphabet 은 특정 문자들의 집합을 뜻한다. alphabet 은 무한 집합일 수도 있지만, 형식 언어의 대부분의 정의는 유한 집합의 alphabet 을 정의한다. </p>
<p>word 는 alphabet 으로 이루어진 유한열(string)이다. alphabet 집합 <span class="arithmatex">\(\Sigma\)</span> 위의 모든 word 집합을 <span class="arithmatex">\(\Sigma ^{*}\)</span> 로 표기한다.</p>
</li>
<li>
<p>예시 </p>
<p>알파벳 <span class="arithmatex">\(\Sigma = \{0,1,2,3,4,5,6,7,8,9,+,=\}\)</span> 위의 형식 언어 <span class="arithmatex">\(L\)</span> 이 다음 규칙을 따른다고 하자. </p>
<ol>
<li>
<p>공집합이 아닌 string 은 <span class="arithmatex">\(+, =\)</span> 를 포함하지 않으며 <span class="arithmatex">\(0\)</span> 으로 시작하지 않는다. </p>
</li>
<li>
<p>string "<span class="arithmatex">\(0\)</span>" 은 <span class="arithmatex">\(L\)</span> 의 원소이다. </p>
</li>
<li>
<p>"<span class="arithmatex">\(=\)</span>" 를 포함한 string 이 있다면 <span class="arithmatex">\(=\)</span> 는 반드시 하나만 존재하고, 이는 두 <span class="arithmatex">\(L\)</span> 의 string 을 구분한다.</p>
</li>
<li>
<p>string 에 <span class="arithmatex">\(+\)</span> 가 있고 <span class="arithmatex">\(=\)</span> 가 없다면 <span class="arithmatex">\(+\)</span> 가 두 <span class="arithmatex">\(L\)</span> 의 string 을 구분하는 경우이다.</p>
</li>
<li>
<p>위 규칙 이외의 string 은 <span class="arithmatex">\(L\)</span> 에 존재하지 않는다. </p>
</li>
</ol>
<p>이 규칙에 따르면 string "<span class="arithmatex">\(23+4=555\)</span>" 은 <span class="arithmatex">\(L\)</span> 에 속했지만, string "<span class="arithmatex">\(=234=+\)</span>" 은 속하지 못한다.</p>
</li>
<li>
<p>위의 예시에서 <span class="arithmatex">\(0\)</span> 을 zero 라고 부르고 싶고, <span class="arithmatex">\(+\)</span> 를 덧셈이라고 부르고 싶겠지만, 형식 언어에서 각각의 기호들은 전적으로 무의미한 기호에 불과하다. 그러나 이것을 모델에 의한 해석을 하면 일상에서의 의미이 zero 나 덧셈으로 부를 수 있다.</p>
</li>
<li>
<p><span class="arithmatex">\(L\)</span> 이 공집합일 수도 있고, 유한 집합일 수도 있지만 보통 <span class="arithmatex">\(L\)</span> 은 무한집합이다. </p>
<ul>
<li>
<p>예시 </p>
<p>유한 알파벳 <span class="arithmatex">\(\Sigma = \{a,b\}\)</span> 은 무한 집합 <span class="arithmatex">\(L = \{a, aaa, abb, abba, \dots\}\)</span> 을 생성한다.</p>
</li>
<li>
<p>예시</p>
</li>
</ul>
<p>주어진 프로그래밍 언어(alphabet) 에 대하여 문법적으로 올바른 프로그램 집합은 형식 언어 <span class="arithmatex">\(L\)</span> 이다.</p>
<p>입력 집합에 대한 특정한 튜링 머신은 형식 언어 <span class="arithmatex">\(L\)</span> 이다.</p>
</li>
<li>
<p>컴퓨터 공학에서 형식 언어는 프로그래밍 언어의 문법을 정의하는 기반을 형성하는데 사용된다. 계산 이론에서 결정 문제를 보통 형식 언어를 사용하여 정의하고 <a href="https://en.wikipedia.org/wiki/Complexity_class">복잡도 집합</a> 을 정의할 때 사용된다.</p>
</li>
<li>
<p>논리학과 수학기초론에서는 공리 체계의 문법을 표현할 때 사용된다. 형식주의가 이런 형식 언어로 모든 수학을 표현할 수 있다는 철학이다.</p>
</li>
<li>
<p>프레게가 형식 언어를 사용하였다.</p>
</li>
<li>
<p>형식 언어 간의 연산도 정의할 수 있다. 이러한 연산들은 형식 언어의 폐포(closure) 의 성질을 연구할 때 사용된다. 대표적으로 다음과 같은 연산들이 있다.</p>
<table>
<thead>
<tr>
<th align="center">Operation</th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Union</td>
<td align="center"><span class="arithmatex">\(L_1 \cup L_2 = \{w : w \in L_1 \lor w \in L_2\}\)</span></td>
</tr>
<tr>
<td align="center">Intersacetion</td>
<td align="center"><span class="arithmatex">\(L_1 \cap L_2 = \{w : w \in L_1 \land w \in L_2\}\)</span></td>
</tr>
<tr>
<td align="center">concatenation</td>
<td align="center"><span class="arithmatex">\(L_1 \cdot  L_2 = \{wz : w \in L_1 \land z \in L_2\}\)</span></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>형식 언어는 프로그래밍 언어에 응용된다.</p>
</li>
<li>
<p>수리논리학에서 형식 이론(formal theory)란 형식 언어의 sentence 집합이다.</p>
</li>
<li>
<p>형식 체계는 연역 규칙와 형식 언어로 구성된다. 형식 언어가 그것의 식(formula)을 식별할 수 있는데 반해, 형식 체계는 그것의 정리를 식별할 수 없다.</p>
<p>다음 그림은 형식 체계의 문법적 구분을 보여준다. string 은 nonsense 와 잘 구성된 식으로 구분되며, 잘 구성된 식은 비정리와 정리로 구분된다.</p>
<p><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Formal_languages.svg/450px-Formal_languages.svg.png"/></p>
</li>
<li>
<p>형식 언어는 완벽하게 문법적이고, 의미를 배제하고 정의된다. 그러나 진리값에 의한 해석이 형식 언어의 식에 부여될 수 있다. 형식 언어의 해석을 연구하는 분야를 <a href="https://en.wikipedia.org/wiki/Semantics_of_logic">formal semantic</a> 이라고 한다.</p>
<p>모델 이론에서는 식의 용어가 수학적 구조의 객체로 해석되고 그것의 진리값을 결정하는 결정 절차가 용어의 진리값을 결정한다. 식(formula) 에 대한 <strong>모델(model) 이란 식을 참으로 만드는 용어에 대한 해석</strong> 을 뜻한다.</p>
</li>
</ul>
<a href="#7e1b89315"><div class="admonition def" id="7e1b89315">
<p>sentence : 자유변수가 없는 술어 논리의 Boolean-valued 식이다.</p>
</div></a>
<ul>
<li>
<p>술어논리는 1차 논리 등을 뜻한다.</p>
</li>
<li>
<p>예시 </p>
<p>1차 논리의 <span class="arithmatex">\(\forall y \exists x (x ^{2} = y)\)</span> 는 sentence 이다. 자유변수란 양화사가 가해지지 않은 변수이므로 이 명제에 자유변수는 없다. 이 명제의 논의 영역이 <span class="arithmatex">\(\R ^{+}\)</span> 라면 참이고, <span class="arithmatex">\(\R\)</span> 이면 거짓이며, <span class="arithmatex">\(\mathbb{C}\)</span> 이면 참이다.</p>
<p>반면 <span class="arithmatex">\(\exists x(x ^{2} = y)\)</span> 는 sentence 가 아니다.</p>
</li>
</ul>
<a href="#d05e0bff1"><div class="admonition def" id="d05e0bff1">
<p>이론(theory) : 형식 언어의 sentence 집합이다.</p>
</div></a>
<ul>
<li>
<p>이론 <span class="arithmatex">\(T\)</span> 의 원소 <span class="arithmatex">\(\phi \in T\)</span> 를 정리(theorem)라고 한다.</p>
</li>
<li>
<p>대부분의 경우 연역 체계에는 <span class="arithmatex">\(\Sigma \subset T\)</span> 인 <span class="arithmatex">\(T\)</span> 의 공리 집합이 존재한다. 이 경우 연역 체계를 공리적 체계라고 한다. 정의에 의하여 공리는 정리가 된다. </p>
</li>
<li>
<p>1차 이론이란 추론 규칙을 공리에 재귀적으로 적용하여 얻어진 1차 논리의 sentence 집합이다.</p>
</li>
<li>
<p>이론을 구성하는 첫단계는 명제로 구성된 비어있지 않은 개념적 클래스 <span class="arithmatex">\(\mathcal{E }\)</span> 를 정의하는 것이다. 이 초기 명제들을 이론의 원시 원소(primitive elements) 혹은 기본 명제라고 한다. </p>
<p>이론 <span class="arithmatex">\(\mathcal{T}\)</span> 는 이러한 기본 명제들로 구성된 개념적 클래스이다. <span class="arithmatex">\(\mathcal{T}\)</span> 의 기본 명제를 <span class="arithmatex">\(\mathcal{T}\)</span> 의 기본 정리(elementary theorem) 이라고 하고 진리값 참을 부여한다. 이로써 이론이란 <span class="arithmatex">\(\mathcal{E }\)</span> 에 참인 명제를 부여하는 것으로 볼 수 있다.</p>
<p>그래서 한 이론에서 명제가 참일 수도 있고, 다른 이론에서 동일한 명제가 거짓이 될 수도 있다.</p>
</li>
<li>
<p><span class="arithmatex">\(\mathcal{S}\)</span> 가 <span class="arithmatex">\(\mathcal{T}\)</span> 의 부분이론이라는 것은 <span class="arithmatex">\(\mathcal{S} \subset \mathcal{T}\)</span> 라는 것이다. 반면 <span class="arithmatex">\(\mathcal{T} \subset \mathcal{S}\)</span> 이라면 <span class="arithmatex">\(\mathcal{S}\)</span> 를 <span class="arithmatex">\(\mathcal{T}\)</span> 의 확장 또는 초이론(supertheory)이라고 한다.</p>
</li>
<li>
<p>연역적 이론(deductive theory)이란 이론의 내용이 형식적 연역 체계에 기반을 두고 있고, 기본 명제들 중 몇몇이 공리로 채택된 이론이다. 이로써 연역적 이론에서는 모든 sentence 가 공리의 논리적 귀결이 된다.</p>
</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Structure_(mathematical_logic">https://en.wikipedia.org/wiki/Structure_(mathematical_logic</a>)</p>
<a href="#2ee384fa6"><div class="admonition def" id="2ee384fa6">
<p>모델 이론(model theory) : 형식 이론과 그것의 모델의 관계에 대한 연구 분야이다. </p>
</div></a>
<ul>
<li>이때 말하는 모델이란 그 이론의 sentence 들을 참이 되게 하는 해석을 뜻한다.</li>
</ul>
<a href="#6a17f9e73"><div class="admonition def" id="6a17f9e73">
<p>구조(structure) : 논의영역 <span class="arithmatex">\(A\)</span>, 부호수 <span class="arithmatex">\(\sigma\)</span>, 해석 함수 <span class="arithmatex">\(I\)</span> 에 대하여 </p>
<div class="arithmatex">\[ \mathcal{A} = (A, \sigma , I) \]</div>
<p>이다.</p>
</div></a>
<ul>
<li>
<p>해석 함수 <span class="arithmatex">\(I\)</span> 는 부호수가 논의영역에서 어떻게 해석될지 정한다. </p>
</li>
<li>
<p>보편대수학과 모델 이론에서 구조란 유한 항수와 관계가 정의된 집합이다.</p>
</li>
<li>
<p>보편 대수학에서 연구하는 구조란 군, 환, 체, 벡터 공간 같은 대수구조를 일반화시킨 것이다. 보편대수학이라는 기호는 관계기호가 없는 구조에 사용된다.</p>
</li>
<li>
<p>모델 이론의 관점에서 구조는 1차 논리에서의 의미를 정의하는데 사용된다. 모델 이론에서 구조가 해당 이론의 공리를 만족하면 구조를 모델(model) 이라고 부른다. 논리학자들은 구조를 해석이라고도 부른다.</p>
</li>
<li>
<p>논의영역은 임의의 집합이다. 보편대수학에서는 carrier 라고도 부르고 모델 이론에서는 universe 라고도 부른다. 1차 논리에서는 논의영역이 공집합이 되는 것을 허용하지 않는다. 구조 <span class="arithmatex">\(\mathcal{A}\)</span> 의 논의 영역을 <span class="arithmatex">\(\text{dom}(\mathcal{A})\)</span> 로 표현한다.</p>
<p>가끔 구조 <span class="arithmatex">\(\mathcal{A}\)</span> 의 논의 영역을 <span class="arithmatex">\(\mathcal{A}\)</span> 로 표현할 때도 있다.</p>
</li>
<li>
<p>해석 함수 <span class="arithmatex">\(I\)</span> 는 함수과 관계에 부호수의 기호를 할당한다. 항수 <span class="arithmatex">\(n\)</span> 인 함수기호 <span class="arithmatex">\(f\)</span> 를 항수 <span class="arithmatex">\(n\)</span> 함수로 <span class="arithmatex">\(f ^{\mathcal{A}} = I(f)\)</span> 와 같이 사상시킨다. 마찬가지로 관계 기호 <span class="arithmatex">\(R\)</span> 을 관계 <span class="arithmatex">\(R\)</span> 로 <span class="arithmatex">\(R ^{\mathcal{A}} = I(R) \subseteq A ^{\text{ar}(R)}\)</span> 와 같이 사상시킨다. </p>
</li>
<li>
<p>예시 </p>
<p>체의 표준부호수 <span class="arithmatex">\(\sigma _{f}\)</span> 는 두 이항 함수 기호 <span class="arithmatex">\(+, \times\)</span> 으로 구정된다. 이 부호수에 대한 구조는 두 이항함수가 정의된 집합으로 구성된다. 하지만 이때의 구조가 체의 공리를 만족해야 할 필요는 없다. <span class="arithmatex">\(\mathbb{Q} , \mathbb{R} , \mathbb{C}\)</span> 같은 체들은 부호수 <span class="arithmatex">\(\sigma\)</span> 에 대한 구조 <span class="arithmatex">\(\sigma\)</span>-structure </p>
<div class="arithmatex">\[ \mathcal{Q} = (\mathbb{Q} , \sigma _f, I _{\mathbb{Q} }) \]</div>
<div class="arithmatex">\[ \mathcal{R} = (\mathbb{R} , \sigma _f, I _{\mathbb{R} }) \]</div>
<div class="arithmatex">\[ \mathcal{C} = (\mathbb{C} , \sigma _f, I _{\mathbb{C} }) \]</div>
<p>로 여겨진다. 이 구조의 부호수는 </p>
<div class="arithmatex">\[ S_f = \{+, \times , -, 0, 1\} \]</div>
<div class="arithmatex">\[ \text{ar}_f(+) = \text{ar}_f(\times ) = 2, \enspace \text{ar}_f(-)=1, \enspace \text{ar}_f(0)=\text{ar}_f(1) = 0 \]</div>
<p>에 대하여</p>
<div class="arithmatex">\[ \sigma _f = (S_f, \text{ar}_f) \]</div>
<p>이다. 해석함수는 다음과 같으며</p>
<div class="arithmatex">\[ I _{\mathcal{Q}}(+): \mathbb{Q} \times \mathbb{Q} \to \mathbb{Q} \]</div>
<div class="arithmatex">\[ I _{\mathcal{Q}}(\times ): \mathbb{Q} \times \mathbb{Q} \to \mathbb{Q} \]</div>
<div class="arithmatex">\[ I _{\mathcal{Q}}(- ): \mathbb{Q} \times \mathbb{Q} \to \mathbb{Q} \]</div>
<div class="arithmatex">\[ I _{\mathcal{Q}}(0 ) \in  \mathbb{Q}, I _{\mathcal{Q}}(1 ) \in  \mathbb{Q} \]</div>
<p>각각 덧셈, 곱셈, 뺄셈, 유리수 <span class="arithmatex">\(0\)</span>, 유리수 <span class="arithmatex">\(1\)</span> 로 정의된다. 해석함수 <span class="arithmatex">\(I _{\mathcal{R}}, I _{\mathcal{C}}\)</span> 도 비슷하게 정의된다.</p>
<p>이때 체가 아닌 정수 집합 <span class="arithmatex">\(\mathbb{Z}\)</span> 은 환인데, 마찬가지로 <span class="arithmatex">\(\sigma _f\)</span>-structure 로 비슷하게 정의된다. 마찬가지로 <span class="arithmatex">\(\sigma _f\)</span>-structure 가 체의 공리를 만족해야 할 필요는 없다. </p>
<p>순서체의 부호수는 추가적으로 <span class="arithmatex">\(&lt; , \leq\)</span> 와 같은 이항 관계가 추가된다. 따라서 이 부호수는 대수적 부호수가 아니다.</p>
<p>집합론의 부호수는 오직 이항 관계 <span class="arithmatex">\(\in\)</span> 만을 갖는다. 이 부호수의 구조는 집합의 원소와 이 원소들의 관계 <span class="arithmatex">\(\in\)</span> 에 대한 해석으로 구성된다.</p>
</li>
<li>
<p>구조가 반드시 1차 논리에서 정의되는 것은 아니다. 1차 논리에서 정의된 구조를 모델(model) 이라고 한다. 1차 논리 구조 <span class="arithmatex">\(\mathcal{M}\)</span> 은 만족 관계(satisfaction relation) <span class="arithmatex">\(\mathcal{M} \vDash \phi\)</span> 를 갖는데, 이 만족 관계는 language 의 모든 식 <span class="arithmatex">\(\phi\)</span> 와 language 의 구조 <span class="arithmatex">\(\mathcal{M}\)</span> 에서 정의된다. 이 관계는 Tarski 의 T-schema 에 의하여 귀납적으로 정의된다.</p>
<p>language 의 구조 <span class="arithmatex">\(\mathcal{M}\)</span> 이 language 의 이론 <span class="arithmatex">\(T\)</span> 와 같으며, <span class="arithmatex">\(\mathcal{M}\)</span> 이 모든 <span class="arithmatex">\(T\)</span> 의 sentence 를 만족하면 구조 <span class="arithmatex">\(\mathcal{M}\)</span> 을 이론 <span class="arithmatex">\(T\)</span> 의 모델이라고 한다.</p>
<ul>
<li>
<p>예시 </p>
<p>환은 환 공리를 만족하는 환의 language 의 구조이다. 그리고 ZFC 의 모델은 ZFC 공리를 만족하는 집합론의 language 의 구조이다.</p>
</li>
</ul>
</li>
</ul>
<h2 id="_4">완전성 정리<a class="headerlink" href="#_4" title="Permanent link">¶</a></h2>
<a href="#eef121b13"><div class="admonition def" id="eef121b13">
<p>완전성 정리(Godel's completeness theorem) : </p>
</div></a>
<ul>
<li>
<p>1차 논리에서 의미적인 참과 문법적인 증명가능성 사이의 대응을 설립하는 근본 정리이다.</p>
</li>
<li>
<p>완전성 정리는 모든 1차 이론에 적용된다.</p>
</li>
</ul>
<h2 id="2">2차 논리<a class="headerlink" href="#2" title="Permanent link">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>완전성 정리를 살펴보려 했는데 모델이론의 모델이라는 개념 같이 대수학, 추상대수학, 보편대수학, 모델이론 등에 대한 지식이 있어야 이해가 수월한 이야기들이 많아서 지금 살펴보는 것은 비효율적인 것 같았다. 나중에 기반지식이 좀 쌓였을 때 증명이론, 계산이론, 튜링 머신의 위키에서의 엄밀한 정의 같은 것들을 살펴보는 것이 더 효율적인듯.</p>
</div>
<hr/>
<dl>
<dt>ref:</dt>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Propositional_calculus">https://en.wikipedia.org/wiki/Propositional_calculus</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Formal_system">https://en.wikipedia.org/wiki/Formal_system</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Axiomatic_system">https://en.wikipedia.org/wiki/Axiomatic_system</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Theory_(mathematical_logic">https://en.wikipedia.org/wiki/Theory_(mathematical_logic</a>)</p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Formal_proof">https://en.wikipedia.org/wiki/Formal_proof</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Mathematical_proof">https://en.wikipedia.org/wiki/Mathematical_proof</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Contradiction">https://en.wikipedia.org/wiki/Contradiction</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Principle_of_explosion">https://en.wikipedia.org/wiki/Principle_of_explosion</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Completeness_(logic">https://en.wikipedia.org/wiki/Completeness_(logic</a>)</p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Primitive_notion">https://en.wikipedia.org/wiki/Primitive_notion</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Model_theory">https://en.wikipedia.org/wiki/Model_theory</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Isomorphism">https://en.wikipedia.org/wiki/Isomorphism</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Recursive_set">https://en.wikipedia.org/wiki/Recursive_set</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Recursively_enumerable_set">https://en.wikipedia.org/wiki/Recursively_enumerable_set</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Interpretation_(logic">https://en.wikipedia.org/wiki/Interpretation_(logic</a>)</p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Metatheorem">https://en.wikipedia.org/wiki/Metatheorem</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Metamathematics">https://en.wikipedia.org/wiki/Metamathematics</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Metalanguage">https://en.wikipedia.org/wiki/Metalanguage</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Metatheory">https://en.wikipedia.org/wiki/Metatheory</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Arity">https://en.wikipedia.org/wiki/Arity</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Hilbert_system">https://en.wikipedia.org/wiki/Hilbert_system</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Substitution_(logic">https://en.wikipedia.org/wiki/Substitution_(logic</a>)</p>
</dd>
<dd>
<p><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EC%97%B0_%EC%97%B0%EC%97%AD">https://ko.wikipedia.org/wiki/%EC%9E%90%EC%97%B0_%EC%97%B0%EC%97%AD</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Method_of_analytic_tableaux">https://en.wikipedia.org/wiki/Method_of_analytic_tableaux</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Mathematical_model">https://en.wikipedia.org/wiki/Mathematical_model</a></p>
</dd>
<dd>
<p><a href="https://math.stackexchange.com/questions/105575/what-is-the-difference-between-completeness-and-soundness-in-first-order-logic">https://math.stackexchange.com/questions/105575/what-is-the-difference-between-completeness-and-soundness-in-first-order-logic</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Deduction_theorem">https://en.wikipedia.org/wiki/Deduction_theorem</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Automated_theorem_proving">https://en.wikipedia.org/wiki/Automated_theorem_proving</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Decidability_(logic)#Semidecidability">https://en.wikipedia.org/wiki/Decidability_(logic)#Semidecidability</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Metalogic">https://en.wikipedia.org/wiki/Metalogic</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Categorical_theory">https://en.wikipedia.org/wiki/Categorical_theory</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/Type_theory">https://en.wikipedia.org/wiki/Type_theory</a></p>
</dd>
<dd>
<p><a href="https://en.wikipedia.org/wiki/%CE%A9-inconsistent_theories">https://en.wikipedia.org/wiki/%CE%A9-inconsistent_theories</a></p>
</dd>
</dl>
</article>
</div>
</div>
<a class="md-top md-icon" data-md-component="top" data-md-state="hidden" href="#">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path></svg>
            Back to top
          </a>
</main>
<!-- 
<footer class="md-footer">
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        
      </div>
      
    </div>
  </div>
</footer> -->
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.tabs", "navigation.top", "header.autohide"], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../../assets/javascripts/workers/search.409db549.min.js", "version": null}</script>
<script src="../../../assets/javascripts/bundle.756773cc.min.js"></script>
<script src="../../../javascripts/highlight.min.js"></script>
<script src="../../../javascripts/config.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script>
<script src="../../../javascripts/b27b3e6448.js"></script>
</body>
</html>