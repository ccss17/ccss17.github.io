<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="ccsss" name="author"/>
<link href="https://ccss17.github.io/Math/Set/InfiniteSet/" rel="canonical"/>
<link href="../../../assets/images/bolt-solid.svg" rel="icon"/>
<meta content="mkdocs-1.2.2, mkdocs-material-7.2.6" name="generator"/>
<title>Infinite Set - ccss17</title>
<link href="../../../assets/stylesheets/main.802231af.min.css" rel="stylesheet"/>
<link href="../../../assets/stylesheets/palette.3f5d1f46.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Nanum+Gothic:300,400,400i,700%7C&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font-family:"Nanum Gothic";--md-code-font-family:""}</style>
<link href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" rel="stylesheet"/>
<link href="../../../stylesheets/config.css" rel="stylesheet"/>
</head>
<body data-md-color-accent="" data-md-color-primary="white" data-md-color-scheme="default" dir="ltr">
<script>function __prefix(e){return new URL("../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
<script>var palette=__get("__palette");if(null!==palette&&"object"==typeof palette.color)for(var key in palette.color)document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#axiom-of-choice">
          Skip to content
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="Header" class="md-header__inner md-grid">
<a aria-label="ccss17" class="md-header__button md-logo" data-md-component="logo" href="../../.." title="ccss17">
<img alt="logo" src="../../../assets/images/bolt-solid.svg"/>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            ccss17
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Infinite Set
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Switch to dark mode" class="md-option" data-md-color-accent="" data-md-color-media="" data-md-color-primary="white" data-md-color-scheme="default" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_2" hidden="" title="Switch to dark mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5z"></path></svg>
</label>
<input aria-label="Switch to light mode" class="md-option" data-md-color-accent="" data-md-color-media="" data-md-color-primary="deep-purple" data-md-color-scheme="slate" id="__palette_2" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Switch to light mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1z"></path></svg>
</label>
</form>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="Tabs" class="md-tabs" data-md-component="tabs">
<div class="md-tabs__inner md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../..">
      ccss17
    </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link md-tabs__link--active" href="../../MathHistory/">
        Math
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../paper/1404.6388/">
        Paper
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../Computer/nand2tetris/">
        Computer
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../ProgrammerBase/">
        ProgrammerBase
      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../security-tutorial/">
        security tutorial
      </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navigation" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="ccss17" class="md-nav__button md-logo" data-md-component="logo" href="../../.." title="ccss17">
<img alt="logo" src="../../../assets/images/bolt-solid.svg"/>
</a>
    ccss17
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../..">
        ccss17
      </a>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" id="__nav_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2">
        Math
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Math" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
          Math
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_1" id="__nav_2_1" type="checkbox"/>
<label class="md-nav__link" for="__nav_2_1">
        Foundation of Math
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Foundation of Math" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_1">
<span class="md-nav__icon md-icon"></span>
          Foundation of Math
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../MathHistory/">
        History of Math
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Logic/FormalSystem/">
        Formal System
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../incompleteness/">
        Incompleteness theorem
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../turing/">
        Turing's proof
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../gentzen/">
        Consistency proof of Peano arithmetic
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_2" id="__nav_2_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2_2">
        Set Theory
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Set Theory" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_2">
<span class="md-nav__icon md-icon"></span>
          Set Theory
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../Set/">
        Set
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../numbers/">
        Number Theory
      </a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" data-md-toggle="toc" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
          Infinite Set
          <span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
        Infinite Set
      </a>
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<!-- <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label> -->
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#axiom-of-choice">
    Axiom of Choice
  </a>
<nav aria-label="Axiom of Choice" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#zorn-lemma">
    Zorn Lemma
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#hausdorff-maximal-principle">
    Hausdorff maximal principle
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#well-ordered-set">
    Well Ordered Set
  </a>
<nav aria-label="Well Ordered Set" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#zermelos-theorem">
    Zermelo's theorem
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#segment">
    Segment
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#order-isomorphism">
    Order Isomorphism
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ordinal">
    Ordinal
  </a>
<nav aria-label="Ordinal" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#transfinite-ordinal-number">
    Transfinite Ordinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#addition-multiples-of-ordinal-number">
    Addition, Multiples of Ordinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#order-of-ordinal-number">
    Order of Ordinal Number
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#infinite-set">
    Infinite Set
  </a>
<nav aria-label="Infinite Set" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#equinumerous">
    Equinumerous
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#finite-set">
    Finite Set
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#definition-of-infinite-set">
    Definition of Infinite Set
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cardinal-number">
    Cardinal Number
  </a>
<nav aria-label="Cardinal Number" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#addition-multiples-of-cardinal-number">
    Addition, Multiples of Cardinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cantorbernstein-theorem">
    Cantor–Bernstein theorem
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#order-of-cardinal-number">
    Order of Cardinal Number
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#transfinite-cardinal-number">
    Transfinite Cardinal Number
  </a>
<nav aria-label="Transfinite Cardinal Number" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#size-of-natual-number">
    Size of Natual Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#size-of-real-number">
    Size of Real Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#countable-set">
    Countable Set
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#uncountable-set">
    Uncountable Set
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#properties-of-transfinite-cardinal-number">
    Properties of Transfinite Cardinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#relation-between-n-and-r">
    Relation between \(|\N|\) and \(|\R|\)
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#properties-of-ordinal-number">
    Properties of Ordinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#continuum-hypothesis">
    Continuum Hypothesis
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../ZFC/">
        ZFC axiom system
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ArithmeticOperations/">
        Arithmetic Operations
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Polynomials/">
        Polynomials
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../HyperrealNumbers/">
        Hyperreal Numbers
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../SurrealNumbers/">
        Surreal Numbers
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_7" id="__nav_2_7" type="checkbox"/>
<label class="md-nav__link" for="__nav_2_7">
        Linear Algebra
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Linear Algebra" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_7">
<span class="md-nav__icon md-icon"></span>
          Linear Algebra
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/VectorSpace/">
        Vector Space
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/LinearTransformation/">
        Linear Transformation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/MatrixOperation/">
        Matrix Operation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/Determinants/">
        Determinants
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/Diagonalization/">
        Diagonalization
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/InnerProductSpaces/">
        Inner Product Spaces
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LinearAlgebra/CanonicalForms/">
        Canonical Forms
      </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" id="__nav_3" type="checkbox"/>
<label class="md-nav__link" for="__nav_3">
        Paper
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Paper" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
          Paper
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/1404.6388/">
        Performance of Python runtimes on a non-numeric scientific code
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/1102.1523/">
        The NumPy array: a structure for efficient numerical computation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/facenet/">
        Facenet (2015)
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/quadruplet/">
        Quadruplet (2017)
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../paper/blueborne/">
        BlueBorne
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" id="__nav_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_4">
        Computer
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Computer" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
          Computer
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Computer/nand2tetris/">
        Nand to Tetris
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Computer/future/">
        Why the future doesn't need us
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Computer/Rust/">
        Rust Memo
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" id="__nav_5" type="checkbox"/>
<label class="md-nav__link" for="__nav_5">
        ProgrammerBase
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="ProgrammerBase" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
          ProgrammerBase
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/">
        README
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_2" id="__nav_5_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_5_2">
        Contents
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Contents" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_5_2">
<span class="md-nav__icon md-icon"></span>
          Contents
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/01-Day1/readme/">
        Day 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/02-Day2/readme/">
        Day 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/03-Day3/readme/">
        Day 3
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/04-Day4/readme/">
        Day 4
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/05-Day5/readme/">
        Day 5
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/docker/">
        Docker
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/codingconvention/">
        Coding Convention
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/build/">
        Build System
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/information/">
        Information
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/git/">
        Git
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/vscode/">
        VSCode
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/markdown/">
        Markdown
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/tmux/">
        Tmux
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/vim/">
        Vim
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../ProgrammerBase/cli/">
        CLI
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" id="__nav_6" type="checkbox"/>
<label class="md-nav__link" for="__nav_6">
        security tutorial
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="security tutorial" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
          security tutorial
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/">
        README
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/01-Base/">
        Day1 Base
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/02-Computer1/">
        Day2 Computer Principle 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/03-Computer2/">
        Day3 Computer Principle 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/04-Reversing1/">
        Day4 Reversing 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/05-Reversing2/">
        Day5 Reversing 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/06-Exploit1/">
        Day6 Exploit 1
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/07-Exploit2/">
        Day7 Exploit 2
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/08-Exploit3/">
        Day8 Exploit 3
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/09-Exploit4/">
        Day9 Exploit 4
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../security-tutorial/10-Pentesting/">
        Day10 Pentesting
      </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<!-- <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label> -->
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#axiom-of-choice">
    Axiom of Choice
  </a>
<nav aria-label="Axiom of Choice" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#zorn-lemma">
    Zorn Lemma
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#hausdorff-maximal-principle">
    Hausdorff maximal principle
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#well-ordered-set">
    Well Ordered Set
  </a>
<nav aria-label="Well Ordered Set" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#zermelos-theorem">
    Zermelo's theorem
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#segment">
    Segment
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#order-isomorphism">
    Order Isomorphism
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ordinal">
    Ordinal
  </a>
<nav aria-label="Ordinal" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#transfinite-ordinal-number">
    Transfinite Ordinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#addition-multiples-of-ordinal-number">
    Addition, Multiples of Ordinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#order-of-ordinal-number">
    Order of Ordinal Number
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#infinite-set">
    Infinite Set
  </a>
<nav aria-label="Infinite Set" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#equinumerous">
    Equinumerous
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#finite-set">
    Finite Set
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#definition-of-infinite-set">
    Definition of Infinite Set
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cardinal-number">
    Cardinal Number
  </a>
<nav aria-label="Cardinal Number" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#addition-multiples-of-cardinal-number">
    Addition, Multiples of Cardinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cantorbernstein-theorem">
    Cantor–Bernstein theorem
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#order-of-cardinal-number">
    Order of Cardinal Number
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#transfinite-cardinal-number">
    Transfinite Cardinal Number
  </a>
<nav aria-label="Transfinite Cardinal Number" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#size-of-natual-number">
    Size of Natual Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#size-of-real-number">
    Size of Real Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#countable-set">
    Countable Set
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#uncountable-set">
    Uncountable Set
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#properties-of-transfinite-cardinal-number">
    Properties of Transfinite Cardinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#relation-between-n-and-r">
    Relation between \(|\N|\) and \(|\R|\)
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#properties-of-ordinal-number">
    Properties of Ordinal Number
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#continuum-hypothesis">
    Continuum Hypothesis
  </a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1>Infinite Set</h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>아래의 논의의 "순서관계" 란 부분순서관계를 뜻한다.</p>
</div>
<h2 id="axiom-of-choice">Axiom of Choice<a class="headerlink" href="#axiom-of-choice" title="Permanent link">¶</a></h2>
<a href="#cdd5ff200"><div class="admonition def" id="cdd5ff200">
<p class="admonition-title">선택 함수(choice function)</p>
<p>집합족 <span class="arithmatex">\(\{S_i\} _{i \in I}\)</span> 위의 선택함수 <span class="arithmatex">\(f: I \to \bigcup_{i \in I}^{}S_i\)</span> 는 다음과 같이 정의된 함수이다.</p>
<div class="arithmatex">\[ \forall i \in I: f(i) \in S_i \]</div>
</div></a>
<ul>
<li>
<p>만약 <span class="arithmatex">\(\varnothing \in \{S_i\}_{i \in I}\)</span> 이면 <span class="arithmatex">\(\{S_i\} _{i \in I}\)</span> 는 선택 함수를 가질 수 없다.</p>
</li>
<li>
<p>아래의 선택공리에 의하여 공집합을 포함하지 않는 모든 집합족은 선택 함수를 갖는다.</p>
</li>
</ul>
<a href="#2009b3b63"><div class="admonition def" id="2009b3b63">
<p class="admonition-title">선택공리(axiom of choice, AC)</p>
<p>선택공리는 공집합이 아닌 집합들의 집합이 주어지면, 각 원소로부터 한 원소를 택할 수 있고, 이를 무한히 반복할 수 있다는 공리</p>
<div class="arithmatex">\[ \forall X \bigg [\varnothing \not \in X \implies \exists f: X \to \bigcup_{}^{}X \quad \forall A \in X(f(A) \in A) \bigg ] \]</div>
<p>로써 다음의 동치 명제들로도 정의된다.</p>
<ol>
<li>
<p>함수 <span class="arithmatex">\(f: X \to Y\)</span> 가 전사이면 <span class="arithmatex">\(f \circ g = 1_Y\)</span> 인 함수 <span class="arithmatex">\(g: Y \to X\)</span> 가 존재한다.</p>
</li>
<li>
<p>집합 <span class="arithmatex">\(X\)</span> 의 분할 <span class="arithmatex">\(\mathcal{P}\)</span> 에 대한 각 <span class="arithmatex">\(A \in \mathcal{P}\)</span> 에 대하여 다음이 성립한다.</p>
<div class="arithmatex">\[ \exists g: \mathcal{P} \to X \text{ s.t. }\ g(A) \in A \]</div>
</li>
<li>
<p>집합 <span class="arithmatex">\(X\)</span> 에 대한 각 <span class="arithmatex">\(A \in 2 ^{X} \setminus \{\varnothing \}\)</span> 에 대하여 다음이 성립한다.</p>
<div class="arithmatex">\[ \exists h: 2 ^{X} \setminus \{\varnothing \} \to X \text{ s.t. }\ h(A) \in A\]</div>
</li>
<li>
<p>집합 <span class="arithmatex">\(I\)</span> 와 각 <span class="arithmatex">\(i \in I\)</span> 에 대한 집합 <span class="arithmatex">\(X_i\)</span> 에 대하여 다음이 성립한다.</p>
<div class="arithmatex">\[I \neq \varnothing \land  \forall i \in I , X_i \neq \varnothing \implies \displaystyle \prod_{i \in I}^{}X_i \neq \varnothing\]</div>
</li>
</ol>
</div></a>
<ul>
<li>
<p>아래의 2) 에서 3) 을 도출하는 증명에서 <span class="arithmatex">\(h(A) \in A\)</span> 를 만족하는 함수 <span class="arithmatex">\(h\)</span> 를 집합 <span class="arithmatex">\(X\)</span> 의 선택함수라고 하고, 3) 을 선택공리라고 부른다.</p>
</li>
<li>
<p>선택공리가 수학에서 사용될 때 대부분 순서와 관련된다. 아래에서 살펴볼 <a href="#b78f346ef">초른 보조정리</a>와 <a href="#a85bbef49">하우스도르프 극대 원리</a>은 선택공리과 동치인 명제인데 수학의 여러 분야에서 널리 쓰인다.</p>
<p>선택공리를 사용하는 정리들은 수학의 각 분야에서 매우 중요한 역할을 하는 경우가 많다. </p>
</li>
<li>
<p>선택공리는 다음과 같이 각 집합 <span class="arithmatex">\(S_i\)</span> 를 그 속의 원소 <span class="arithmatex">\(x_i \in S_i\)</span> 로 대응시킨다. </p>
<p><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f0/Axiom_of_choice.svg/330px-Axiom_of_choice.svg.png"/></p>
</li>
<li>
<p>1) 에서 2) 를 도출하는 증명 </p>
<p>집합 <span class="arithmatex">\(X\)</span> 의 분할 <span class="arithmatex">\(\mathcal{P}\)</span> 가 주어졌을 때 각 <span class="arithmatex">\(x \in X\)</span> 가 속하는 <span class="arithmatex">\(A \in \mathcal{P}\)</span> 가 유일하게 결정되는데 이를 <span class="arithmatex">\(f(x)\)</span> 라고 두면, <span class="arithmatex">\(f: X \to \mathcal{P}\)</span> 는 전사함수이다. 이때 1) 이 가정이므로 <span class="arithmatex">\(f \circ g = 1 _{\mathcal{P}}\)</span> 인 함수 <span class="arithmatex">\(g: \mathcal{P}\to X\)</span> 가 존재한다. </p>
<p>그러면 <span class="arithmatex">\(f(g(A)) = A\)</span> 이므로 <span class="arithmatex">\(g(A) \in A\)</span> 이다. ■ </p>
<p><span class="arithmatex">\(g(A)\)</span> 는 <span class="arithmatex">\(X\)</span> 의 원소 가운데 <span class="arithmatex">\(A\)</span> 에 들어가는 것을 하나 고른 것이다.</p>
</li>
<li>
<p>2) 에서 1) 을 도출하는 증명 </p>
<p><span class="arithmatex">\(f: X \to Y\)</span> 가 전사이면 <span class="arithmatex">\(\mathcal{P} = \{f ^{-1}(\{y\}) : y \in Y\}\)</span> 는 <span class="arithmatex">\(X\)</span> 의 분할이다. (<em>왜냐하면 <span class="arithmatex">\(\mathcal{P}\)</span> 은 <span class="arithmatex">\(f\)</span> 의 공역 <span class="arithmatex">\(Y\)</span> 의 원소 <span class="arithmatex">\(y\)</span> 에 대한 집합 <span class="arithmatex">\(\{y\}\)</span> 를 <span class="arithmatex">\(f\)</span> 의 역함수 <span class="arithmatex">\(f ^{-1}\)</span> 에 집어넣어서 그것에 대응하는 <span class="arithmatex">\(X\)</span> 의 원소 <span class="arithmatex">\(x\)</span> 의 집합으로 구성되었기 때문이다. 이것이 가능한 이유는 <span class="arithmatex">\(f\)</span> 가 전사 사상이기 때문이고, 하나의 <span class="arithmatex">\(y \in Y\)</span> 로 가는 여러개의 <span class="arithmatex">\(x\)</span> 가 있을 수도 있으므로 <span class="arithmatex">\(\mathcal{P}\)</span> 의 원소들은 원소의 갯수가 하나 이상이다.</em>) 따라서 <span class="arithmatex">\(\forall y \in Y\)</span> 에 대하여 <span class="arithmatex">\(g[f ^{-1}(\{y\})] \in f ^{-1}(\{y\})\)</span> 를 만족하는 함수 <span class="arithmatex">\(g : \mathcal{P} \to X\)</span> 가 존재한다. </p>
<p>이때 각 <span class="arithmatex">\(y \in Y\)</span> 에 대하여 </p>
<div class="arithmatex">\[ h(y) = g[f ^{-1}(\{y\})] \]</div>
<p>라 정의하면 <span class="arithmatex">\(h: Y \to X\)</span> 는 함수이고, <span class="arithmatex">\(h(y) \in f ^{-1}(\{y\})\)</span> 이므로 증명하고자 하는 바인 <span class="arithmatex">\(f(h(y))=y\)</span> 가 성립한다. (<em>이 함수 <span class="arithmatex">\(h\)</span> 는 같은 <span class="arithmatex">\(y \in Y\)</span> 로 대응되는 <span class="arithmatex">\(x \in X\)</span> 들로 이루어진 집합 중에서 하나를 택하는 함수라고 이해하면 될 것 같다.</em>) ■ </p>
</li>
<li>
<p>2) 에서 3) 을 도출하는 증명 </p>
<p>각 <span class="arithmatex">\(A \in 2 ^{X} \setminus \{\varnothing \}\)</span> 에 대하여 </p>
<div class="arithmatex">\[ \tilde{A} = \{(A, a) : a \in A\} \subset (2 ^{X} \setminus \{\varnothing \}) \times X \]</div>
<p>라 두면 <span class="arithmatex">\(\mathcal{P} = \{\tilde{A} : A \in 2 ^{X} \setminus \{\varnothing \}\}\)</span> 은 집합 <span class="arithmatex">\(Y = \bigcup_{}^{}\{\tilde{A} : A \in 2 ^{X} \setminus \{\varnothing \}\}\)</span> 의 분할이다. 이때 <span class="arithmatex">\(\forall A \in 2 ^{X} \setminus \{\varnothing \}\)</span> 에 대하여 <span class="arithmatex">\(g(\tilde{A}) \in \tilde{A}\)</span> 를 만족하는 함수 <span class="arithmatex">\(g: \mathcal{P} \to Y\)</span> 가 존재한다.</p>
<p>이때 <span class="arithmatex">\(\pi_2 :(2 ^{X} \setminus \{\varnothing \}) \times X \to X\)</span> 를 사영이라 두고 <span class="arithmatex">\(A \in 2 ^{X} \setminus \{\varnothing \}\)</span> 에 대하여</p>
<div class="arithmatex">\[ h: A \mapsto \pi_2 (g(\tilde{A})) \]</div>
<p>라 정의하면 <span class="arithmatex">\(h: 2 ^{X} \setminus \{\varnothing \} \to X\)</span> 가 원하는 함수이다. ■  </p>
</li>
<li>
<p>3) 에서 2) 를 도출하는 증명 </p>
<p>집합 <span class="arithmatex">\(X\)</span> 의 분할 <span class="arithmatex">\(\mathcal{P}\)</span> 는 <span class="arithmatex">\(2 ^{X} \setminus \{\varnothing \}\)</span> 의 부분집합이므로 3) 을 가정하면 2) 는 바로 도출된다. ■ </p>
</li>
<li>
<p>3) 에서 4) 를 도출하는 증명 </p>
<p>먼저 집합 <span class="arithmatex">\(X (\neq \varnothing )\)</span> 와 <span class="arithmatex">\(Y (\neq \varnothing )\)</span> 의 곱집합 <span class="arithmatex">\(X \times Y\)</span> 가 <span class="arithmatex">\(\varnothing\)</span> 이 아님은 자명하다. 왜냐하면 <span class="arithmatex">\(x \in X\)</span> 와 <span class="arithmatex">\(y \in Y\)</span> 를 택하면 <span class="arithmatex">\((x,y) \in X \times Y\)</span> 이기 때문이다.</p>
<p>임의의 집합족 <span class="arithmatex">\(\{X_i : i \in I\}\)</span> 에 대하여 4) 를 정의했는데 3) 에서 4) 를 도출해보자. 먼저 3) 을 가정했으므로 집합 <span class="arithmatex">\(X = \bigcup_{i \in I}^{}X_i\)</span> 의 선택함수 <span class="arithmatex">\(h: 2 ^{X} \setminus \{\varnothing \} \to X\)</span> 가 존재하는데, 함수 <span class="arithmatex">\(g: I \to X\)</span> 를 </p>
<div class="arithmatex">\[ g(i) = h(X_i) \]</div>
<p>라 정의하자. 그러면 각 <span class="arithmatex">\(i \in I\)</span> 에 대하여 <span class="arithmatex">\(g(i) = h(X_i) \in X_i\)</span> 이므로 </p>
<div class="arithmatex">\[ g \in \prod_{i \in I}^{}X_i \]</div>
<p>이다. ■ </p>
</li>
<li>
<p>4) 에서 3) 를 도출하는 증명 </p>
<p>4) 가 가정인 것에서 <span class="arithmatex">\(\prod_{}^{}\{A:A \in 2 ^{X} \setminus \{\varnothing \}\} \neq \varnothing\)</span> 이므로 </p>
<div class="arithmatex">\[ \exists h \text{ s.t. }\ h \in \prod_{}^{}\{A:A \in 2 ^{X} \setminus \{\varnothing \}\} \]</div>
<p>이다. 그러면 각 <span class="arithmatex">\(A \in 2 ^{X} \setminus \{\varnothing \}\)</span> 에 대하여 <span class="arithmatex">\(h(A) \in A\)</span> 이므로 <span class="arithmatex">\(h\)</span> 는 <span class="arithmatex">\(X\)</span> 의 선택함수이다. ■ </p>
</li>
</ul>
<a href="#84f732f88"><div class="admonition def" id="84f732f88">
<p class="admonition-title">사슬(chain)</p>
<p>순서집합 <span class="arithmatex">\(X\)</span> 의 부분집합 <span class="arithmatex">\(A\)</span> 가 다음을 만족하면 <span class="arithmatex">\(A\)</span> 를 <span class="arithmatex">\(X\)</span> 의 사슬이라 한다.</p>
<div class="arithmatex">\[ a, b \in A \implies a \leq b \lor a \geq b \]</div>
</div></a>
<ul>
<li>
<p>즉 사슬 속의 서로 다른 두 원소는 항상 비교 가능하다.</p>
</li>
<li>
<p>예시 </p>
<p>집합 <span class="arithmatex">\(X\)</span> 의 멱집합 <span class="arithmatex">\(2 ^{X}\)</span> 에 포함관계에 의한 순서를 부여하여 <span class="arithmatex">\(A \subset B \iff A \leq B\)</span> 라고 정의하자. <span class="arithmatex">\(a,b,c \in X\)</span> 에 대하여 </p>
<div class="arithmatex">\[ \{\{a\}, \{a,c\}\}, \quad \{\varnothing , \{a\},\{a,b\},\{a,b,c\},X\} \]</div>
<p>등은 <span class="arithmatex">\(2 ^{X}\)</span> 의 사슬이고, <span class="arithmatex">\(X\)</span> 는 사슬의 상계이다.</p>
</li>
</ul>
<a href="#8f75fb43e"><div class="admonition def" id="8f75fb43e">
<p class="admonition-title">반사슬(antichain)</p>
<p>순서집합 <span class="arithmatex">\(X\)</span> 의 부분집합 <span class="arithmatex">\(A\)</span> 의 서로 다른 두 원소를 비교할 순서관계가 없을 때 <span class="arithmatex">\(A\)</span> 를 <span class="arithmatex">\(X\)</span> 의 반사슬이라 한다.</p>
</div></a>
<ul>
<li>즉 반사슬 속의 서로 다른 두 원소는 비교 불가능하다.</li>
</ul>
<a href="#717ffc54e"><div class="admonition def" id="717ffc54e">
<p class="admonition-title">극대원소(maximal element)</p>
<p>순서집합 <span class="arithmatex">\(X\)</span> 의 원소 <span class="arithmatex">\(m \in X\)</span> 이 다음을 만족하면 <span class="arithmatex">\(m\)</span> 을 <span class="arithmatex">\(X\)</span> 의 극대원소라 한다.</p>
<div class="arithmatex">\[ x \in X, x \geq m \implies x = m \]</div>
</div></a>
<ul>
<li>
<p>예시 </p>
<p>사슬의 예시에서 순서집합 <span class="arithmatex">\(2 ^{X}\)</span> 의 극대원소는 <span class="arithmatex">\(X\)</span> 이다.</p>
<p>한편 <span class="arithmatex">\(\N\)</span> 이나 <span class="arithmatex">\(\mathbb{Z}\)</span> 는 그 자체가 사슬이지만, 극대원소가 존재하지 않는다.</p>
</li>
</ul>
<a href="#a6684cc21"><div class="admonition def" id="a6684cc21">
<p class="admonition-title">극소원소(minimal element)</p>
<p>순서집합 <span class="arithmatex">\(X\)</span> 의 원소 <span class="arithmatex">\(n \in X\)</span> 이 다음을 만족하면 <span class="arithmatex">\(n\)</span> 을 <span class="arithmatex">\(X\)</span> 의 극대원소라 한다.</p>
<div class="arithmatex">\[ x \in X, x \leq n \implies x = n \]</div>
</div></a>
<h3 id="zorn-lemma">Zorn Lemma<a class="headerlink" href="#zorn-lemma" title="Permanent link">¶</a></h3>
<a href="#b78f346ef"><div class="admonition def" id="b78f346ef">
<p class="admonition-title">정리 3.1.1 초른의 보조정리(Zorn lemma)</p>
<p>공집합이 아닌 순서집합 <span class="arithmatex">\(X\)</span> 의 모든 사슬이 상계를 가지면 <span class="arithmatex">\(X\)</span> 는 극대원소를 가진다.</p>
</div></a>
<ul>
<li>선택공리과 동치인 명제로써 수학의 여러 분야에서 널리 쓰인다.</li>
</ul>
<h3 id="hausdorff-maximal-principle">Hausdorff maximal principle<a class="headerlink" href="#hausdorff-maximal-principle" title="Permanent link">¶</a></h3>
<a href="#a85bbef49"><div class="admonition def" id="a85bbef49">
<p class="admonition-title">정리 3.1.2 하우스도르프 극대 원리(Hausdorff maximal principle)</p>
<p>임의의 순서집합은 극대 사슬을 가진다.</p>
</div></a>
<ul>
<li>
<p>선택공리과 동치인 명제로써 수학의 여러 분야에서 널리 쓰인다.</p>
</li>
<li>
<p>예시</p>
<p>포함관계에 의한 순서를 부여받은 순서집합 <span class="arithmatex">\(X\)</span> 의 모든 사슬을 모은 집합 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 는 포함관계에 의하여 다시 순서집합이 된다. 이 정리는 순서집합 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 가 극대원소를 가진다는 것을 말한다. </p>
</li>
</ul>
<a href="#460d5f66d"><div class="admonition def" id="460d5f66d">
<p>포함관계에 의하여 순서가 부여된 집합 <span class="arithmatex">\(X\)</span> 의 사슬의 집합 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 의 사슬 <span class="arithmatex">\(\mathcal{C}\)</span> 에 대하여 모든 사슬 <span class="arithmatex">\(\mathcal{C}\)</span> 의 원소의 합집합 <span class="arithmatex">\(\bigcup_{}^{}\mathcal{C} (\subset X)\)</span> 은 <span class="arithmatex">\(X\)</span> 의 사슬이다. 즉, 다음이 성립한다.</p>
<div class="arithmatex">\[ \bigcup_{}^{}\mathcal{C} \in \mathcal{C}(X) \]</div>
</div></a>
<ul>
<li>
<p>증명</p>
<p><span class="arithmatex">\(\forall  a,b \in \bigcup_{}^{}\mathcal{C}\)</span> 와 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 의 어떤 사슬 <span class="arithmatex">\(\mathcal{C}\)</span> 에 대하여</p>
<div class="arithmatex">\[ \exists C_1, C_2 \text{ s.t. }\ a \in C_1 \in \mathcal{C}, b \in C_2 \in \mathcal{C} \]</div>
<p>이다. <span class="arithmatex">\(\mathcal{C}\)</span> 은 사슬이므로 <span class="arithmatex">\(C_1 \subset C_2 \lor C_2 \subset C_1\)</span> 이다. <span class="arithmatex">\(C_1 \subset C_2\)</span> 일 경우 <span class="arithmatex">\(a,b \in C_2\)</span> 인데 <span class="arithmatex">\(C_2\)</span> 는 <span class="arithmatex">\(X\)</span> 의 사슬이므로 <span class="arithmatex">\(a \leq b \lor b \leq a\)</span> 이다. 마찬가지로 <span class="arithmatex">\(C_2 \subset C_1\)</span> 인 경우에도 <span class="arithmatex">\(a \leq b \lor b \leq a\)</span> 이다. 이로써 <span class="arithmatex">\(\bigcup_{}^{}\mathcal{C}\)</span> 의 임의의 두 원소가 서로 비교 가능함을 알 수 있고, 이에따라 <span class="arithmatex">\(\bigcup_{}^{}\mathcal{C}\)</span> 는 <span class="arithmatex">\(X\)</span> 의 사슬임이 증명되었다. 즉 <span class="arithmatex">\(\bigcup_{}^{}\mathcal{C} \in \mathcal{C}(X)\)</span> 이다. ▲</p>
</li>
</ul>
<a href="#a4f694c36"><div class="admonition def" id="a4f694c36">
<p>초른의 보조정리는 하우스도르프 극대 원리와 동치이다.</p>
</div></a>
<ul>
<li>
<p>초른의 보조정리에서 하우스도르프 극대 원리를 도출하는 증명 </p>
<p>우선 <a href="#b78f346ef">초른 보조정리</a>를 가정하자. 그리고 포함관계에 의한 순서를 부여받은 순서집합 <span class="arithmatex">\(X\)</span> 의 모든 사슬을 모은 순서집합 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 에 <a href="#b78f346ef">초른 보조정리</a>를 적용해보고, <a href="#a85bbef49">하우스도르프 극대 원리</a>가 도출되는지 보자. </p>
<p><a href="#460d5f66d">정리 "포함관계에 의하여 순서가 부여된 집합 <span class="arithmatex">\(X\)</span> 의 사슬의 집합 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 의 사슬 <span class="arithmatex">\(\mathcal{C}\)</span> 에 대하여 모든 사슬 <span class="arithmatex">\(\mathcal{C}\)</span> 의 원소의 합집합 <span class="arithmatex">\(\bigcup_{}^{}\mathcal{C} (\subset X)\)</span> 은 <span class="arithmatex">\(X\)</span> 의 사슬이다."</a> 에서</p>
<div class="arithmatex">\[ C = \bigcup_{}^{}\mathcal{C} \]</div>
<p>라고 두면 <span class="arithmatex">\(C\)</span> 는 <span class="arithmatex">\(\mathcal{C}\)</span> 들의 합집합이므로 <span class="arithmatex">\(\mathcal{C} \subset \mathcal{C}(X)\)</span> 의 상계임이 자명하다. 그러므로 순서집합 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 는 <a href="#b78f346ef">초른 보조정리</a>의 가정을 만족하고, <span class="arithmatex">\(\mathcal{C}(X)\)</span> 는 <a href="#b78f346ef">초른 보조정리</a>의 귀결(극대원소를 가진다) 또한 만족한다. 이처럼 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 이 <a href="#b78f346ef">초른 보조정리</a>를 만족하는데, 위의 증명이 보인 것은 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 이 극대 사슬 <span class="arithmatex">\(C\)</span> 를 가진다는 것이다. 따라서 <a href="#b78f346ef">초른 보조정리</a>를 가정하면 <a href="#a85bbef49">하우스도르프 극대 원리</a>가 성립한다. ■ </p>
</li>
<li>
<p><a href="#a85bbef49">하우스도르프 극대 원리</a>에서 <a href="#b78f346ef">초른 보조정리</a>를 도출하는 증명 </p>
<p><span class="arithmatex">\(X\)</span> 의 모든 사슬이 상계를 가진다고 가정하자. 그러면 <a href="#a85bbef49">하우스도르프 극대 원리</a>에 의하여 <span class="arithmatex">\(X\)</span> 는 극대 사슬 <span class="arithmatex">\(C\)</span> 를 가지는데 가정에 의하여 이것의 상계 <span class="arithmatex">\(m \in X\)</span> 또한 존재한다. 이제 이 <span class="arithmatex">\(m\)</span> 이 극대원소임을 보이면 된다.</p>
<p>먼저 <span class="arithmatex">\(x \in X, x &gt; m\)</span> 이라고 가정하자. 그러면 <span class="arithmatex">\(x\)</span> 는 <span class="arithmatex">\(C\)</span> 의 임의의 원소와 비교 가능하고, 따라서 <span class="arithmatex">\(C \cup \{x\}\)</span> 도 사슬이다. 그런데 <span class="arithmatex">\(C \subsetneq C \cup \{x\}\)</span> 이므로 <span class="arithmatex">\(C\)</span> 가 극대사슬이라는 것에 모순이다. 따라서 <span class="arithmatex">\(x\)</span> 는 존재하지 않으며 <span class="arithmatex">\(m\)</span> 이 <span class="arithmatex">\(X\)</span> 의 극대원소가 된다. ■ </p>
</li>
</ul>
<a href="#8533ea869"><div class="admonition def" id="8533ea869">
<p class="admonition-title">도움정리 3.1.3</p>
<p>순서집합 <span class="arithmatex">\(X\)</span> 의 부분집합족 <span class="arithmatex">\(\mathcal{X} \subset 2 ^{X}\)</span> 가 다음을 만족하면 <span class="arithmatex">\(\mathcal{X}\)</span> 는 극대원소를 가진다. </p>
<ol>
<li>
<p><span class="arithmatex">\(A \in \mathcal{X}, B \subset A \implies B \in \mathcal{X}\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(\mathcal{C}\)</span> 이 <span class="arithmatex">\(\mathcal{X}\)</span> 의 사슬이면 <span class="arithmatex">\(\bigcup_{}^{}\mathcal{C}\in \mathcal{X}\)</span> 이다.</p>
</li>
</ol>
</div></a>
<ul>
<li>
<p><a href="#a4f694c36">정리 "초른 보조정리는 하우스도르프 극대 원리와 동치이다."</a> 의 증명과정에서 살펴보았듯 포함관계에 의한 순서가 부여된 <span class="arithmatex">\(X\)</span> 의 사슬 집합 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 는 본 정리의 두 가지 조건을 만족한다. </p>
<p>따라서 하우스드로프 극대 원리는 이 정리에서 바로 도출된다.</p>
</li>
<li>
<p>증명 </p>
<p>조건 1), 2) 를 만족하는 <span class="arithmatex">\(\mathcal{X}\)</span> 가 존재할 때 극대원소가 존재함을 보이면 증명이 된다. 그러므로 <span class="arithmatex">\(\mathcal{X}\)</span> 이 존재한다고 하면, 조건 1) 에 의하여 <span class="arithmatex">\(\mathcal{X}\)</span> 는 임의의 원소 <span class="arithmatex">\(A \in \mathcal{X}\)</span> 의 모든 부분집합을 원소로 갖는다. </p>
<p>그러면 각 <span class="arithmatex">\(A \in \mathcal{X}\)</span> 에 대하여 </p>
<div class="arithmatex">\[ \tilde{A} = \{x \in X : A \cup \{x\}\in \mathcal{X}\} \]</div>
<p>라고 하자. 그러면 임의의 <span class="arithmatex">\(A \in \mathcal{X}\)</span> 가 결정되었을 때 그 <span class="arithmatex">\(A\)</span> 의 원소인 <span class="arithmatex">\(x \in X\)</span> 에 대하여 <span class="arithmatex">\(A \cup \{x\} \in \mathcal{X}\)</span> 도 성립하므로 당연히 <span class="arithmatex">\(A\)</span> 의 모든 원소는 기본적으로 <span class="arithmatex">\(\tilde{A}\)</span> 에 속하고, 추가적으로 <span class="arithmatex">\(A\)</span> 를 포함하면서 <span class="arithmatex">\(A\)</span> 보다 큰 집합 <span class="arithmatex">\(B (\supset A)\)</span> 가 <span class="arithmatex">\(\mathcal{X}\)</span> 에 존재하면 <span class="arithmatex">\(B \setminus A\)</span> 의 원소들 또한 <span class="arithmatex">\(\tilde{A}\)</span> 에 속하게 될 것이다. 그러므로 먼저 자명하게 <span class="arithmatex">\(A \subset \tilde{A}\)</span> 이고, <span class="arithmatex">\(A\)</span> 가 <span class="arithmatex">\(\mathcal{X}\)</span> 의 극대 원소일 필요충분조건은 <span class="arithmatex">\(A\)</span> 보다 큰 집합이 없다는 것에서 <span class="arithmatex">\(A = \tilde{A}\)</span> 이다. ▲ </p>
<p>이제 집합 <span class="arithmatex">\(X\)</span> 의 선택함수 <span class="arithmatex">\(h\)</span> 를 택하고 함수 <span class="arithmatex">\(g: \mathcal{X}\to \mathcal{X}\)</span> 를 </p>
<div class="arithmatex">\[ g(A) = \begin{cases} A \sqcup \{h(\tilde{A}\setminus A)\} &amp; A \subsetneq \tilde{A}\\ A &amp; A = \tilde{A}\\ \end{cases} \]</div>
<p>로 두자. 그러면 <span class="arithmatex">\(g(A)=A\)</span> 를 만족하는 <span class="arithmatex">\(A \in \mathcal{X}\)</span> 의 존재성을 보이면 증명이 끝난다. 함수 <span class="arithmatex">\(g\)</span> 의 특성상 <span class="arithmatex">\(A \subset g(A)\)</span> 는 항상 성립하므로 <span class="arithmatex">\(g(A) \subset A\)</span> 인 <span class="arithmatex">\(A\)</span> 를 보이면 된다. ▲ </p>
<p>이제 조건</p>
<div class="arithmatex">\[ \varnothing \in \mathcal{Y}, \quad A \in \mathcal{Y} \implies g(A) \in \mathcal{Y}, \quad \mathcal{C} \in \mathcal{C}(\mathcal{Y}) \implies \bigcup_{}^{}\mathcal{C}\in \mathcal{Y} \tag{1} \]</div>
<p>을 만족하는 <span class="arithmatex">\(\mathcal{X}\)</span> 의 부분집합 <span class="arithmatex">\(\mathcal{Y} \subset \mathcal{X}\)</span> 를 생각해보자. 이런 조건을 만족하는 <span class="arithmatex">\(\mathcal{X}\)</span> 의 모든 부분집합들의 교집합을 <span class="arithmatex">\(\mathcal{Y}_0\)</span> 이라고 하자. 그러면 <span class="arithmatex">\(\varnothing \in \mathcal{Y}_0\)</span> 이므로 <span class="arithmatex">\(\mathcal{Y}_0 \neq \varnothing\)</span> 이고, <span class="arithmatex">\((1)\)</span> 을 만족하는 최소의 집합족이 된다. 이때 이 <span class="arithmatex">\(\mathcal{Y}_0\)</span> 이 <span class="arithmatex">\(\mathcal{X}\)</span> 의 사슬임을 보이려 한다. 만약 <span class="arithmatex">\(\mathcal{Y}_0\)</span> 이 <span class="arithmatex">\(\mathcal{X}\)</span> 의 사슬이면 <span class="arithmatex">\(\mathcal{Y}_0 \in \mathcal{C}(\mathcal{Y}_0)\)</span> 이므로 <span class="arithmatex">\(\bigcup_{}^{}\mathcal{Y}_0 \in \mathcal{Y}_0\)</span> 인데 <span class="arithmatex">\(A = \bigcup_{}^{}\mathcal{Y}_0\)</span> 로 두면 <span class="arithmatex">\(A = \bigcup_{}^{}\mathcal{Y}_0 \in \mathcal{Y}_0\)</span> 에서 <span class="arithmatex">\(g(A) \in \mathcal{Y}_0\)</span> 이므로 </p>
<div class="arithmatex">\[ g(A) \subset \bigcup_{}^{}\mathcal{Y}_0 = A \]</div>
<p>가 되어 증명이 끝난다. ▲ </p>
<p><span class="arithmatex">\(C \in \mathcal{Y}_0\)</span> 가 </p>
<div class="arithmatex">\[ D \in \mathcal{Y}_0 \implies C \subset D \lor D \subset C \]</div>
<p>를 만족할 때 <span class="arithmatex">\(C\)</span> 를 comparable element 이라고 하자. 가령 <span class="arithmatex">\(\varnothing\)</span> 는 comparable element 이다. 우리의 목표는 다음을 증명하는 것이다.</p>
<div class="arithmatex">\[ C \text{ is comparable element  } \implies g(C) \text{ is comparable element   } \tag{2} \]</div>
<p>이것을 증명하면 <span class="arithmatex">\(\mathcal{Y}_0\)</span> 의 모든 comparable element 의 집합 <span class="arithmatex">\(\mathcal{C}_0\)</span> 이 <span class="arithmatex">\((1)\)</span> 을 만족함을 알 수 있다. (<em><span class="arithmatex">\((1)\)</span> 의 <span class="arithmatex">\(\mathcal{Y}\)</span> 를 <span class="arithmatex">\(\mathcal{C}_0\)</span> 으로 대체하여 따져보면 쉽게 알 수 있다.</em>) 그런데 <span class="arithmatex">\(\mathcal{Y}_0\)</span> 은 <span class="arithmatex">\((1)\)</span> 을 만족하는 최소의 집합족이었으므로 <span class="arithmatex">\(\mathcal{Y}_0 \subset \mathcal{C}_0\)</span> 인데 <span class="arithmatex">\(\mathcal{C}_0\)</span> 은 <span class="arithmatex">\(\mathcal{Y}_0\)</span> 의 원소로 구성되어 있으므로 <span class="arithmatex">\(\mathcal{C}_0 \subset \mathcal{Y}_0\)</span> 이므로 <span class="arithmatex">\(\mathcal{Y}_0=\mathcal{C}_0\)</span> 이다. 이는 <span class="arithmatex">\(\mathcal{Y}_0\)</span> 의 모든 원소가 비교가능하는 것을 말해준다. 그렇게 되면 <span class="arithmatex">\(\mathcal{Y}_0\)</span> 는 사슬이라는 말이 되고, 결국 모든 증명이 끝난다. ▲ </p>
<p>이제 <span class="arithmatex">\((2)\)</span> 를 증명하기 위해 comparable element 인 <span class="arithmatex">\(C \in \mathcal{Y}_0\)</span> 를 고정하고 집합족 </p>
<div class="arithmatex">\[ \mathcal{U} = \{A \in \mathcal{Y}_0 : A \subset C \lor g(C) \subset A\} \]</div>
<p>에 대하여 <span class="arithmatex">\((1)\)</span> 을 보이려 한다. 이때 <span class="arithmatex">\((1)\)</span> 의 첫째 조건은 자명하고, <a href="#460d5f66d">정리 "포함관계에 의하여 순서가 부여된 집합 <span class="arithmatex">\(X\)</span> 의 사슬의 집합 <span class="arithmatex">\(\mathcal{C}(X)\)</span> 의 사슬 <span class="arithmatex">\(\mathcal{C}\)</span> 에 대하여 모든 사슬 <span class="arithmatex">\(\mathcal{C}\)</span> 의 원소의 합집합 <span class="arithmatex">\(\bigcup_{}^{}\mathcal{C} (\subset X)\)</span> 은 <span class="arithmatex">\(X\)</span> 의 사슬이다."</a> 에 의하여 <span class="arithmatex">\(\mathcal{Y}\)</span> 의 모든 사슬의 합집합 <span class="arithmatex">\(\bigcup_{}^{}C\)</span> 은 <span class="arithmatex">\(\mathcal{Y}\)</span> 의 사슬인데 <span class="arithmatex">\(\mathcal{Y}\)</span> 는 조건 2) 를 만족하므로 <span class="arithmatex">\((1)\)</span> 의 셋째 조건도 자명하다. </p>
<p>둘째 조건을 보이기 위하여 <span class="arithmatex">\(\forall A \in \mathcal{Y}_0\)</span> 에 대하여 </p>
<div class="arithmatex">\[ A \subset C \lor g(C) \subset A \implies g(A) \subset C \lor g(C) \subset g(A) \tag{3} \]</div>
<p>를 보이면 된다. </p>
<ul>
<li>
<p><span class="arithmatex">\(A = C\)</span> 이면 <span class="arithmatex">\(g(C) = g(A)\)</span> 이므로 <span class="arithmatex">\((3)\)</span> 이 성립한다.</p>
</li>
<li>
<p><span class="arithmatex">\(g(C) \subset A\)</span> 이면 <span class="arithmatex">\(g(C) \subset A \subset g(A)\)</span> 이므로 성립한다. </p>
</li>
<li>
<p><span class="arithmatex">\(A \subsetneq C\)</span> 이면 <span class="arithmatex">\(C\)</span> 가 comparable element 이므로 <span class="arithmatex">\(g(A) \subset C \lor C \subset g(A)\)</span> 이다. </p>
<ul>
<li>
<p><span class="arithmatex">\(g(A) \subset C\)</span> 이면 성립한다.</p>
</li>
<li>
<p><span class="arithmatex">\(C \subsetneq g(A)\)</span> 이면 <span class="arithmatex">\(A \subsetneq C \subsetneq g(A)\)</span> 이므로 <span class="arithmatex">\(g(A) \setminus A\)</span> 가 두 개 이상의 원소를 갖는데(<em><span class="arithmatex">\(g(C), C\)</span> 가 <span class="arithmatex">\(g(A)\)</span> 에 속하기 때문</em>), 이는 <span class="arithmatex">\(g\)</span> 의 정의에 의하여 불가능하다. (<em>왜냐하면 <span class="arithmatex">\(g\)</span> 는 <span class="arithmatex">\(A\)</span> 이거나 <span class="arithmatex">\(A\)</span> 이외에 다른 원소를 하나만 갖기 때문에 <span class="arithmatex">\(g(A)\setminus A\)</span> 의 원소의 갯수는 <span class="arithmatex">\(0\)</span> 이거나 <span class="arithmatex">\(1\)</span> 이기 때문.</em>) 그러므로 <span class="arithmatex">\(C \subsetneq g(A)\)</span> 은 모순이고, 반드시 <span class="arithmatex">\(C \supset g(A)\)</span> 이다.</p>
</li>
</ul>
</li>
</ul>
<p>이로써 <span class="arithmatex">\((3)\)</span> 이 증명되었고, 집합족 <span class="arithmatex">\(\mathcal{U}\)</span> 는 <span class="arithmatex">\((1)\)</span> 을 만족한다. ▲ </p>
<p>집합족 <span class="arithmatex">\(\mathcal{Y}_0\)</span> 는 <span class="arithmatex">\((1)\)</span> 을 만족하는 최소의 집합족인데 <span class="arithmatex">\(\mathcal{U}\subset \mathcal{Y}_0\)</span> 이므로 <span class="arithmatex">\(\mathcal{U}=\mathcal{Y}_0\)</span> 이다. 따라서 <span class="arithmatex">\(\forall A \in \mathcal{Y}_0, A \subset C \subset g(C) \lor g(C) \subset A\)</span> 이다. 즉, <span class="arithmatex">\(g(C)\)</span> 는 comparable element 라는 말이다. 집합 <span class="arithmatex">\(C \in \mathcal{Y}_0\)</span> 가 임의의 comparable element 이므로 <span class="arithmatex">\((2)\)</span> 가 증명되었고 모든 증명이 끝났다. ■ </p>
</li>
<li>
<p>이 정리로부터 하우스드로프 극대 원리를 도출하는 증명</p>
</li>
</ul>
<h2 id="well-ordered-set">Well Ordered Set<a class="headerlink" href="#well-ordered-set" title="Permanent link">¶</a></h2>
<a href="#ba9ece221"><div class="admonition def" id="ba9ece221">
<p class="admonition-title">정렬 집합(well ordered set)</p>
<p>순서집합 <span class="arithmatex">\(X\)</span> 에 대한 임의의 부분집합 <span class="arithmatex">\(A \in 2 ^{X} \setminus \{\varnothing \}\)</span> 가 최소 원소를 가지면 <span class="arithmatex">\(X\)</span> 를 정렬집합이라고 한다. </p>
</div></a>
<ul>
<li>
<p>정렬 집합의 순서관계를 정렬 순서라 한다. </p>
</li>
<li>
<p><a href="../numbers#5efd87f3f">정리 2.1.4</a> 는 자연수집합 <span class="arithmatex">\(\N\)</span> 이 정렬 집합임을 말해준다.</p>
</li>
<li>
<p>정렬 집합은 그 자체로서 사슬이 된다.</p>
</li>
</ul>
<a href="#40344a17f"><div class="admonition def" id="40344a17f">
<p class="admonition-title">정렬 순서(well ordered)</p>
<p>정렬 집합이 갖는 순서관계이다.</p>
</div></a>
<h3 id="zermelos-theorem">Zermelo's theorem<a class="headerlink" href="#zermelos-theorem" title="Permanent link">¶</a></h3>
<a href="#2f7ff02de"><div class="admonition def" id="2f7ff02de">
<p class="admonition-title">정리 3.1.4 체르멜로 정렬정리(Well-ordering theorem, Zermelo's theorem)</p>
<p>임의의 집합에는 정렬순서가 존재한다.</p>
</div></a>
<ul>
<li>
<p>아래의 증명은 <a href="#b78f346ef">초른 보조정리</a>를 사용하는데 이는 <a href="#b78f346ef">초른 보조정리</a>가 적용되는 대표적인 사례이다.</p>
</li>
<li>
<p>증명</p>
<p>먼저 <span class="arithmatex">\(X\)</span> 의 부분집합 <span class="arithmatex">\(A\)</span> 와 <span class="arithmatex">\(G \subset A \times A\)</span> 로써 <span class="arithmatex">\(A\)</span> 의 정렬순서를 부여해주는 관계들의 순서쌍 <span class="arithmatex">\((A,G)\)</span> 를 생각하고, 이런 순서쌍 전체 집합을 <span class="arithmatex">\(\mathcal{X}\)</span> 라 두자. 이때 <span class="arithmatex">\((A,G), (B,H) \in \mathcal{X}\)</span> 가 </p>
<div class="arithmatex">\[ A \subset B, \quad G \subset H, \quad x \in A, y \in B \setminus A \implies (x, y) \in H \]</div>
<p>를 만족할 때 <span class="arithmatex">\((A, G) \leq (B, H)\)</span> 라 정의하면 순서관계가 됨을 바로 확인할 수 있다.</p>
<p>순서집합 <span class="arithmatex">\(\mathcal{X}\)</span> 에 <a href="#b78f346ef">초른 보조정리</a>를 적용하기 위하여 <span class="arithmatex">\(\mathcal{C}\)</span> 가 <span class="arithmatex">\(\mathcal{X}\)</span> 의 사슬이라고 하고 </p>
<div class="arithmatex">\[ A_0 = \bigcup_{}^{}\{A \subset X:(A,G) \in \mathcal{C}\} \]</div>
<div class="arithmatex">\[ G_0 = \bigcup_{}^{}\{G \subset X \times X:(A,G) \in \mathcal{C}\} \]</div>
<p>라 두자. 이제 <span class="arithmatex">\((A_0, G_0) \in \mathcal{X}\)</span> 임을 보이려 하는데 먼저 <span class="arithmatex">\(G_0\)</span> 가 <span class="arithmatex">\(A_0\)</span> 의 순서관계임을 보이려 한다. ▲ </p>
<p>만약 <span class="arithmatex">\(x \in A_0\)</span> 이면 <span class="arithmatex">\(\exists  (A, G) \in \mathcal{C} \text{ s.t. }\ x \in A\)</span> 이다. 이때 <span class="arithmatex">\(G\)</span> 는 <span class="arithmatex">\(A\)</span> 의 정렬순서를 부여하므로 순서관계도 부여한다. 따라서 순서관계의 조건 1) 에 의하여 <span class="arithmatex">\(x \in A \subset  A_0 \implies (x, x) \in G \subset G_0\)</span> 이다. <span class="arithmatex">\(A\)</span> 와 <span class="arithmatex">\(G\)</span> 가 순서관계 조건 1) 을 만족하는 것에서 <span class="arithmatex">\(x \in A_0 \implies (x, x) \in \subset G_0\)</span> 을 도출했으므로 <span class="arithmatex">\(A_0\)</span> 와 <span class="arithmatex">\(G_0\)</span> 는 순서관계 조건 1) 을 만족한다.</p>
<p>순서관계 조건 2) 를 보이기 위하여 <span class="arithmatex">\(x, y \in A_0, (x, y) \in G_0, (y, x) \in G_0\)</span> 을 가정하자. 그러면 <span class="arithmatex">\((x, y)\)</span> 와 <span class="arithmatex">\((y, x)\)</span> 라는 순서관계도 어떤 집합에 속하게 되므로 <span class="arithmatex">\((x, y) \in G\)</span> 와 <span class="arithmatex">\((y, x) \in H\)</span> 라고 하자. 그러면 <span class="arithmatex">\((A, G), (B, H) \in \mathcal{C}\)</span> 가 존재한다. 이때 <span class="arithmatex">\(\mathcal{C}\)</span> 가 사슬이므로 <span class="arithmatex">\((A, G) \leq (B, H) \lor (A, G) \geq (B, H)\)</span> 이다. 어느 경우에나 <span class="arithmatex">\((x,y)\)</span> 와 <span class="arithmatex">\((y,x)\)</span> 는 <span class="arithmatex">\(G \cup H = (A \cup B) \times (A \cup B)\)</span> 에 속하게 된다. 그런데 <span class="arithmatex">\(G \cup H\)</span> 는 <span class="arithmatex">\(A \cup B\)</span> 의 모든 원소의 순서관계를 잘 부여하는데 순서관계의 조건 2) 에 의하여 <span class="arithmatex">\((x, y) \in G \cup H, (y, x) \in G \cup H \implies x = y\)</span> 이다. 이로써 <span class="arithmatex">\(x = y\)</span> 가 도출되었고, <span class="arithmatex">\(G_0\)</span> 이 <span class="arithmatex">\(A_0\)</span> 에 대한 순서관계 2) 를 만족한다는 것이 증명되었다.</p>
<p>마지막으로 순서관계 3) 이 성립함을 보여야하는데, <span class="arithmatex">\((x, y) , (y, z) \in G_0\)</span> 를 가정하면, 이번에도 <span class="arithmatex">\((x, y) \in G\)</span> 이고 <span class="arithmatex">\((y, z) \in H\)</span> 인 <span class="arithmatex">\((A, G), (B, H) \in \mathcal{C}\)</span> 가 존재하므로 순서관계 2) 를 증명했던 것과 마찬가지의 방법으로 <span class="arithmatex">\((x, z) \in G_0\)</span> 이 증명된다. </p>
<p>그러므로 <span class="arithmatex">\(G_0\)</span> 는 <span class="arithmatex">\(A_0\)</span> 의 순서관계이다. ▲ </p>
<p>이제 <span class="arithmatex">\(G_0\)</span> 가 <span class="arithmatex">\(A_0\)</span> 의 정렬순서임을 보이려 한다. <span class="arithmatex">\(\varnothing \neq B \subset A_0\)</span> 라 하면 <span class="arithmatex">\((A, G) \in \mathcal{C}\)</span> 가 존재하여 <span class="arithmatex">\(B \cap A \neq \varnothing\)</span> 을 만족한다. 이때 <span class="arithmatex">\(\varnothing \neq B \cap A \subset A\)</span> 이고, <span class="arithmatex">\(G\)</span> 가 <span class="arithmatex">\(A\)</span> 의 정렬순서이므로 <span class="arithmatex">\(B \cap A\)</span> 는 최소 원소 <span class="arithmatex">\(b\)</span> 를 가진다. 이러한 최소원소 <span class="arithmatex">\(b\)</span> 는 모든 원소 <span class="arithmatex">\(\forall a \in B \cap A\)</span> 에 대하여 <span class="arithmatex">\(b \leq a \iff (b, a) \in G\)</span> 를 만족하므로 </p>
<div class="arithmatex">\[ b \in B \cap A, \quad a \in B \cap A \implies (b, a) \in G \]</div>
<p>이다. 이제 <span class="arithmatex">\(b \in B\)</span> 가 <span class="arithmatex">\(B (\subset A_0)\)</span> 의 최소 원소임을 보이려 한다. 즉, </p>
<div class="arithmatex">\[ x \in B \implies (b, x) \in G_0 \]</div>
<p>임을 보이려 한다. <span class="arithmatex">\(x \in B\)</span> 가 가정이므로 <span class="arithmatex">\(x \in A\)</span> 이면 <span class="arithmatex">\(x \in B \cap A\)</span> 이다. 그러므로 <span class="arithmatex">\((b, x) \in G \subset G_0\)</span> 이다. 만약 <span class="arithmatex">\(x \not\in A\)</span> 이면 적절한 <span class="arithmatex">\((C, K) \in \mathcal{C}\)</span> 에 대하여 <span class="arithmatex">\(x \in C\)</span> 인데, <span class="arithmatex">\(x \in C \setminus A\)</span> 이므로 <span class="arithmatex">\(C \not \subseteq A\)</span> 이다. 따라서 <span class="arithmatex">\((C, K) \not \leq (A, G)\)</span> 인데 <span class="arithmatex">\(\mathcal{C}\)</span> 가 사슬이므로 <span class="arithmatex">\((A, G) \leq (C, K)\)</span> 이다. 그런데 <span class="arithmatex">\(b \in A \land x \in C \setminus A\)</span> 이므로 <span class="arithmatex">\((A, G) \leq (C, K)\)</span> 의 정의에 의하여 <span class="arithmatex">\((b, x) \in K \subset G_0\)</span> 이다. 이로써 <span class="arithmatex">\(b\)</span> 가 <span class="arithmatex">\(B\)</span> 의 최소원소임이 증명되었다. ▲ </p>
<p>이제 <span class="arithmatex">\((A_0, G_0) \in \mathcal{X}\)</span> 가 <span class="arithmatex">\(\mathcal{C}\)</span> 의 상계임을 보이려 하는데 방금 증명한 방법과 비슷하기에 생략한다. ▲ </p>
<p>지금까지 순서집합 <span class="arithmatex">\(\mathcal{X}\)</span> 가 <a href="#b78f346ef">초른 보조정리</a>의 가정부를 만족함을 보였다. 그러므로 <span class="arithmatex">\(\mathcal{X}\)</span> 는 극대원소 <span class="arithmatex">\((D, L) \in \mathcal{X}\)</span> 을 가진다. 이제 <span class="arithmatex">\(D=X\)</span> 임을 보일 것이다. <span class="arithmatex">\(D \subsetneq X\)</span> 이면 <span class="arithmatex">\(x \in X \setminus D\)</span> 를 잡고 </p>
<div class="arithmatex">\[ E = D \cup \{x\}, \quad M = L \cup \{(a,x):a \in D\} \cup \{(x,x)\} \]</div>
<p>라 두자. 그러면 <span class="arithmatex">\(M\)</span> 은 <span class="arithmatex">\(E\)</span> 의 순서관계가 되는데 <span class="arithmatex">\(x\)</span> 는 임의의 <span class="arithmatex">\(a \in D\)</span> 보다 큰 원소이다. 따라서 <span class="arithmatex">\((E,M)\)</span> 은 정렬집합이고 <span class="arithmatex">\((E,M) \in \mathcal{X}\)</span> 인데 <span class="arithmatex">\((E,M)&gt;(D,L)\)</span> 이다. 이는 <span class="arithmatex">\((D,L)\)</span> 이 극대원소라는데 모순이므로 <span class="arithmatex">\(D=X\)</span> 이고 <span class="arithmatex">\(L\)</span> 은 <span class="arithmatex">\(X\)</span> 에 정의된 정렬순서이다. ■ </p>
</li>
</ul>
<a href="#4c5862e26"><div class="admonition def" id="4c5862e26">
<p>선택공리, 초른 보조정리, 하우스도르프 극대 원리, 체르멜로 정렬정리는 서로 동치이다.</p>
</div></a>
<ul>
<li>
<p>증명 </p>
<p><a href="#2f7ff02de">체르멜로 정렬정리</a> 를 가정하면 선택공리를 쉽게 얻을 수 있다. </p>
<p>집합 <span class="arithmatex">\(X\)</span> 가 정렬집합일 때 임의의 <span class="arithmatex">\(A \in 2 ^{X}\setminus \{\varnothing \}\)</span> 에 대하여 <span class="arithmatex">\(A\)</span> 의 최소원소를 <span class="arithmatex">\(h(A)\)</span> 라 하면 </p>
<div class="arithmatex">\[ h: 2 ^{X}\setminus \{\varnothing \} \to X \]</div>
<p>는 선택함수이다. 그러므로 선택공리, <a href="#b78f346ef">초른 보조정리</a>, <a href="#a85bbef49">하우스도르프 극대 원리</a>, <a href="#2f7ff02de">체르멜로 정렬정리</a>가 모두 동치임을 알 수 있다. ■ </p>
</li>
</ul>
<h3 id="segment">Segment<a class="headerlink" href="#segment" title="Permanent link">¶</a></h3>
<a href="#a4efa7099"><div class="admonition def" id="a4efa7099">
<p class="admonition-title">정렬집합의 절편(segment)</p>
<p>정렬집합 <span class="arithmatex">\(A\)</span> 와 <span class="arithmatex">\(x \in A\)</span> 에 대하여 다음을 <span class="arithmatex">\(x\)</span> 에 의한 <span class="arithmatex">\(A\)</span> 의 절편이라 한다.</p>
<div class="arithmatex">\[S_x = \{a \in A: a &lt; x\}\]</div>
</div></a>
<ul>
<li>
<p>절편은 정렬집합이다.</p>
</li>
<li>
<p>예시 </p>
<div class="arithmatex">\[ \forall n \in \omega , S_n = n \]</div>
<div class="arithmatex">\[ \forall m \in n, S_m = m \]</div>
</li>
<li>
<p>예시 </p>
<p><span class="arithmatex">\(\R\)</span> 의 한 절편은 <span class="arithmatex">\(S_0 = (- \infty , 0)\)</span> 이다.</p>
<p><span class="arithmatex">\(\N\)</span> 의 한 절편은 <span class="arithmatex">\(S_3 = \{1,2\}\)</span> 이다.</p>
</li>
</ul>
<a href="#402e09c82"><div class="admonition def" id="402e09c82">
<p class="admonition-title">서로소 집합의 순서 </p>
<p>서로소인 두 정렬집합 <span class="arithmatex">\(A, B\)</span> 에 대하여 합집합 <span class="arithmatex">\(A \sqcup B\)</span> 에 대하여 다음을 <span class="arithmatex">\(x \leq y\)</span> 라고 정의한다.</p>
<div class="arithmatex">\[ (x, y \in A : x \leq y) \lor (x, y \in B : x \leq y) \lor (x \in A, y \in B) \]</div>
</div></a>
<ul>
<li>
<p>이 관계는 정렬순서이다.</p>
<ul>
<li>증명 </li>
</ul>
</li>
<li>
<p><span class="arithmatex">\(A \sqcup B\)</span> 와 <span class="arithmatex">\(B \sqcup A\)</span> 는 집합으로서는 같지만 순서집합으로서는 다르다.</p>
<ul>
<li>
<p>예시 </p>
<p><span class="arithmatex">\(\omega \sqcup \{x\}\)</span> 에서는 맨 뒤에 있는 <span class="arithmatex">\(x \in \{x\}\)</span> 가 최대 원소이다. 하지만 <span class="arithmatex">\(\{x\} \sqcup \omega\)</span> 에는 최대원소가 없다. 직관에 어긋나지만, <span class="arithmatex">\(\{x\} \sqcup \omega\)</span> 와 <span class="arithmatex">\(\omega\)</span> 는 같은 순서집합이다. </p>
<div class="arithmatex">\[ \begin{equation}\begin{split} \omega : &amp; 0, 1, 2, 3, \dots\\ \{x\} \sqcup \omega : &amp; x, 0, 1, 2, \dots\\ \omega \sqcup \{x\} : &amp; 0, 1, 2, 3, \dots, x \end{split}\end{equation} \tag*{} \]</div>
</li>
</ul>
</li>
</ul>
<a href="#b5c6edca8"><div class="admonition def" id="b5c6edca8">
<p class="admonition-title">증가함수(increasing function)</p>
<p>순서집합 <span class="arithmatex">\(A, B\)</span> 사이에 정의된 함수 <span class="arithmatex">\(f: A \to B\)</span> 가 다음을 만족하면 증가함수라 한다.</p>
<div class="arithmatex">\[ x, y \in A, x \leq y \implies f(x) \leq f(y) \]</div>
</div></a>
<ul>
<li>
<p>증가함수는 단조 함수(monotonic function)인데 단조함수는 주어진 순서를 보존하는 함수이다. </p>
</li>
<li>
<p>이러한 함수 <span class="arithmatex">\(f\)</span> 에 대하여 <span class="arithmatex">\(f\)</span> 가 단조 증가(monotonically increasing) 한다고 한다.</p>
</li>
</ul>
<h3 id="order-isomorphism">Order Isomorphism<a class="headerlink" href="#order-isomorphism" title="Permanent link">¶</a></h3>
<a href="#43c6d98ec"><div class="admonition def" id="43c6d98ec">
<p class="admonition-title">순서 동형(order isomorphism)</p>
<p>순서집합 <span class="arithmatex">\(A, B\)</span> 에 정의된 전단사 함수 <span class="arithmatex">\(f: A \to B\)</span> 가 증가함수이고 그 역함수 <span class="arithmatex">\(f ^{-1}\)</span> 도 증가함수이면 <span class="arithmatex">\(A\)</span> 와 <span class="arithmatex">\(B\)</span> 는 순서동형이다. </p>
</div></a>
<ul>
<li>
<p><strong>두 순서 동형 집합 <span class="arithmatex">\(A,B\)</span> 를 <span class="arithmatex">\(A \approxeq B\)</span> 와 같이 표기한다.</strong></p>
</li>
<li>
<p>순서동형은 부분순서 집합의 동형(isomorphism)이란 무엇인지 정의해준다. 두 부분순서 집합이 순서동형이라면 두 집합은 본질적으로 같은 것으로 여겨진다. 왜냐하면 한 집합의 원소들이 이루는 순서를 다른 집합으로부터 완전히 구성할 수 있기 때문이다.</p>
</li>
<li>
<p>예시 </p>
<p>다음과 같이 정의된 함수 <span class="arithmatex">\(f: \{x\} \sqcup \omega \to \omega\)</span> 는 전단사 함수이고 증가함수 이므로 순서동형을 정의해준다. </p>
<div class="arithmatex">\[ f(a) = \begin{cases} 0 &amp; a = x\\ a + 1 &amp; a \in \omega \\ \end{cases} , \qquad f ^{-1} (a) = \begin{cases} x &amp; a = 0\\ a - 1 &amp; a &gt; 0 \\ \end{cases} \]</div>
<p>이로써 <span class="arithmatex">\(\{x\}\sqcup \omega\)</span> 와 <span class="arithmatex">\(\omega\)</span> 가 순서동형이고, 본질적으로 서로 같은 집합임을 알 수 있다.</p>
</li>
</ul>
<a href="#299eaf11b"><div class="admonition def" id="299eaf11b">
<p class="admonition-title">사전순서(lexicographical order)</p>
<p>순서집합 <span class="arithmatex">\(A,B\)</span> 의 곱집합 <span class="arithmatex">\(A \times B\)</span> 의 두 원소 <span class="arithmatex">\((a_1, b_1) \in A \times B, (a_2, b_2) \in A \times B\)</span> 에 대하여 다음이 성립할 때 <span class="arithmatex">\((a_1, b_1) \leq (a_2, b_2)\)</span> 라고 정의된 순서를 사전순서라 한다.</p>
<div class="arithmatex">\[ a_1 &lt; a_2 \lor (a_1 = a_2 \land b_1 \leq b_2) \]</div>
</div></a>
<a href="#91088f144"><div class="admonition def" id="91088f144">
<p class="admonition-title">반사전순서(anti-lexicographical order)</p>
<p>순서집합 <span class="arithmatex">\(A,B\)</span> 의 곱집합 <span class="arithmatex">\(A \times B\)</span> 의 두 원소 <span class="arithmatex">\((a_1, b_1) \in A \times B, (a_2, b_2) \in A \times B\)</span> 에 대하여 다음이 성립할 때 <span class="arithmatex">\((a_1, b_1) \leq (a_2, b_2)\)</span> 라고 정의된 순서를 사전순서라 한다.</p>
<div class="arithmatex">\[ b_1 &lt; b_2 \lor (b_1 = b_2 \land a_1 \leq a_2) \]</div>
</div></a>
<ul>
<li>
<p><span class="arithmatex">\(A,B\)</span> 가 정렬집합이면 <span class="arithmatex">\(A \times B\)</span> 에 정의된 사전순서나 반사전순서는 모두 정렬순서이다.</p>
</li>
<li>
<p>한편, 아래의 논의에서부터는 정렬집합의 곱집합에는 반사전순서가 부여된 것으로 간주하자.</p>
</li>
<li>
<p>예시 </p>
<p>정렬집합의 곱하기에는 교환법칙이 성립하지 않는다.</p>
<p>가령 <span class="arithmatex">\(X = \{x,y\}\)</span> 일 때 <span class="arithmatex">\(\omega \times X\)</span> 의 순서는 </p>
<div class="arithmatex">\[ (0, x), (1, x), (2, x), \dots, (0, y), (1, y), (2, y), \dots \]</div>
<p>로써 <span class="arithmatex">\(\omega\)</span> 가 <span class="arithmatex">\(n \in \omega\)</span> 에 대한 <span class="arithmatex">\((n, x)\)</span> 형태의 튜플에 모두 대응되어 순서동형일 수 없다. 하지만 <span class="arithmatex">\(X \times \omega\)</span> 의 순서는 </p>
<div class="arithmatex">\[ (x, 0), (y, 0), (x, 1), (y, 1), (x, 2), (y, 2), \dots \]</div>
<p>로써 <span class="arithmatex">\(\omega\)</span> 와 순서동형이다. 왜냐하면 증가함수이면서 전단사함수인 <span class="arithmatex">\(f: \omega \to X \times \omega\)</span> 가 존재하기 때문이다. </p>
<div class="arithmatex">\[ f(n) = \begin{cases} \bigg (x, \dfrac{n}{2}\bigg ) &amp; n \text{ is even }\\ \bigg (y, \dfrac{n-1}{2}\bigg ) &amp; n \text{ is odd } \end{cases} , \quad f ^{-1}(a, b) = \begin{cases} 2b &amp; a = x\\ 2b+1 &amp; a = y \end{cases} \]</div>
<p>그러므로 </p>
<div class="arithmatex">\[ \omega \approxeq X \times \omega, \quad \omega \not \approxeq \omega \times X \]</div>
<p>이다.</p>
</li>
</ul>
<a href="#90ba9203e"><div class="admonition def" id="90ba9203e">
<p class="admonition-title">정리 3.3.1</p>
<p>두 정렬집합 <span class="arithmatex">\(A, B\)</span> 가 주어지면 다음 중 하나가 성립한다. </p>
<ol>
<li>
<p><span class="arithmatex">\(A \approxeq B\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(b \in B : A \approxeq S_b\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(a \in A : S_a \approxeq B\)</span></p>
</li>
</ol>
</div></a>
<ul>
<li>
<p>이 정리는 쉽게 말해서 두 정렬집합을 비교할 때, 두 정렬집합이 서로 같거나 어느 한쪽이 다른 쪽의 절편이 됨을 말해준다. </p>
</li>
<li>
<p>증명 </p>
<p>먼저 집합 <span class="arithmatex">\(B\)</span> 의 <span class="arithmatex">\(p, q \in B\)</span> 에 대한 절편 <span class="arithmatex">\(S_q, S_p\)</span> 에 대하여 </p>
<div class="arithmatex">\[ f: S_q \to S_p \text{ 가 증가 단사함수 } \implies q \leq p \tag{1} \]</div>
<p>를 증명하자. 이를 위하여 <span class="arithmatex">\(f\)</span> 가 증가 단사함수임에도 <span class="arithmatex">\(p&lt;q\)</span> 라고 해보자. 이때 </p>
<div class="arithmatex">\[ P = \{x \in S_q: f(x) &lt; x\} \]</div>
<p>라 정의하면 <span class="arithmatex">\(P \neq \varnothing \implies \exists m \text{ s.t. }\ m = \min P\)</span> 이다. 그런데 <span class="arithmatex">\(f(m) &lt; m \implies f(f(m))&lt;f(m)\)</span> 이므로 <span class="arithmatex">\(f(m) \in P\)</span> 인데 <span class="arithmatex">\(f(m) &lt; m\)</span> 이므로 <span class="arithmatex">\(m\)</span> 이 최소원소라는 것에 모순이다. 그러므로 <span class="arithmatex">\(P = \varnothing\)</span> 이고, <span class="arithmatex">\(p&lt;q\)</span> 에서 <span class="arithmatex">\(p \in S_q \setminus P\)</span> 이므로 <span class="arithmatex">\(f(p) \geq p\)</span> 이다. 그러므로 <span class="arithmatex">\(f(p) \not\in S_p\)</span> 인데, <span class="arithmatex">\(\text{Cdm} (f) = S_p\)</span> 이므로 모순이다. 그러므로 <span class="arithmatex">\((1)\)</span> 이 증명되었다. ▲ </p>
<p>한편 그러므로 <span class="arithmatex">\((1)\)</span> 에 의하여 </p>
<div class="arithmatex">\[ p, q \in B, S_p \approxeq S_q \implies p = q \tag{2} \]</div>
<p>임이 자명하다. ▲ </p>
<p>이제 정렬집합 <span class="arithmatex">\(A\)</span> 의 부분집합 <span class="arithmatex">\(C\)</span> 를 (<em>이때 <span class="arithmatex">\(x \in X\)</span> 에 대한 절편 <span class="arithmatex">\(S_x\)</span> 는 <span class="arithmatex">\(X\)</span> 의 절편이고, <span class="arithmatex">\(y \in Y\)</span> 에 대한 절편 <span class="arithmatex">\(S_y\)</span> 는 <span class="arithmatex">\(Y\)</span> 의 절편인 것 같다. 표기가 조금 헷갈리네. <span class="arithmatex">\(S _{x \in X}, S _{y \in Y}\)</span> 로 표기했으면 안헷갈렸을텐데.</em>)</p>
<div class="arithmatex">\[ C = \{x \in A : \exists p \in B \text{ s.t. }\  S_x \approxeq S_p  \} \]</div>
<p>와 같이 정의하자.(<em>그러면 이 <span class="arithmatex">\(C\)</span> 는 만약 <span class="arithmatex">\(A\)</span> 가 <span class="arithmatex">\(B\)</span> 보다 클 경우 <span class="arithmatex">\(B\)</span> 의 사이즈에 맞는 <span class="arithmatex">\(A\)</span> 절편이 되고, <span class="arithmatex">\(A\)</span> 가 <span class="arithmatex">\(B\)</span> 보다 작을 경우 그냥 <span class="arithmatex">\(A\)</span> 가 될 것 같은데. 맞나?</em>) 또 함수 <span class="arithmatex">\(\phi : C \to B\)</span> 를 정의하는데 <span class="arithmatex">\((2)\)</span> 에 의하여 <span class="arithmatex">\(x \in A\)</span> 에 대하여 <span class="arithmatex">\(S_x \approxeq S_p \land S_x \approxeq S_q\)</span> 라면 <span class="arithmatex">\(S_p \approxeq S_q\)</span> 이므로(<em>이로써 한 입력이 두 출력을 갖지않음이 보장됨</em>) 함수 <span class="arithmatex">\(\phi\)</span> 를</p>
<div class="arithmatex">\[ \phi (x) = p \quad (\impliedby x \in C \land S_x \approxeq S_p) \]</div>
<p>라 정의할 수 있다.(<em>이때 <span class="arithmatex">\(S_x\)</span> 는 <span class="arithmatex">\(C\)</span> 의 절편이고 <span class="arithmatex">\(S_p\)</span> 는 <span class="arithmatex">\(B\)</span> 의 절편이며, 두 절편이 순서동형이라는 것은 두 절편의 크기가 같다는 말인 것 같다. 그러면 <span class="arithmatex">\(\phi\)</span> 함수는 한 절편의 원소에 대응되는 다른 절편의 원소로 가는 단사함수지.</em>) 그러면 이 함수 <span class="arithmatex">\(\phi\)</span> 는 단사함수가 된다. 왜냐하면 <span class="arithmatex">\(\phi (x) = \phi (y) = p \implies S_x \approxeq S_p \approxeq S_y\)</span> 인데 <span class="arithmatex">\((2)\)</span> 에 의하여 <span class="arithmatex">\(x = y (= p)\)</span> 이기 때문이다. 이제 </p>
<div class="arithmatex">\[ x, y \in C, x \leq y \implies \phi (x) \leq \phi (y) \tag{3} \]</div>
<p>이 성립함을 보일 것이다. <span class="arithmatex">\(f : S_x \to S _{\phi (x)}, g: S_y \to S _{\phi (y)}\)</span> 가 순서동형을 정의하므로 <span class="arithmatex">\(f, g\)</span> 는 전단사함수이며 증가함수이고 그 역함수 <span class="arithmatex">\(f ^{-1}, g ^{-1}\)</span> 도 증가함수이다. 그러면 <span class="arithmatex">\(x \leq y\)</span> 이므로 포함함수 <span class="arithmatex">\(\iota : S_x \hookrightarrow S_y\)</span> 가 존재하고, 합성함수 </p>
<div class="arithmatex">\[ g \circ \iota \circ f ^{-1}: S _{\phi (x)} \to S _{\phi (y)} \]</div>
<p>는 증가 단사함수이다. 왜냐하면 <span class="arithmatex">\(f ^{-1}\)</span> 는 증가함수이고, <span class="arithmatex">\(\iota\)</span> 는 항등함수(포함함수)이고, <span class="arithmatex">\(g\)</span> 는 증가함수이기 때문에 결국 이 합성함수는 증가함수이다. 그런데 이때 <span class="arithmatex">\((1)\)</span> 에 의하여 <span class="arithmatex">\(\phi (x) \leq \phi (y)\)</span> 가 증명되고, 이로써 함수 <span class="arithmatex">\(\phi : C \to \phi (C)\)</span> 는 순서동형을 정의한다는 것을 알 수 있다. (<em><span class="arithmatex">\(B\)</span> 가 아닌 새로운 공역 <span class="arithmatex">\(\phi (C)\)</span> 로 정의된 <span class="arithmatex">\(\phi : C \to \phi (C)\)</span> 는 전사함수이다. 왜냐하면 공역으로의 <span class="arithmatex">\(\phi (C)\)</span> 가 치역 <span class="arithmatex">\(\phi (C)\)</span> 와 같기 때문이다. <span class="arithmatex">\(\phi\)</span> 가 단사함수임은 이미 살펴보았으므로 <span class="arithmatex">\(\phi\)</span> 는 전단사함수이고, 또한 증가함수이므로 <span class="arithmatex">\(\phi\)</span> 는 순서동형을 정의한다.</em>) ▲ </p>
<p>이제 <span class="arithmatex">\(C = A\)</span> 이거나 <span class="arithmatex">\(C\)</span> 는 <span class="arithmatex">\(A\)</span> 의 절편임을 보이자. 이를 위하여 </p>
<div class="arithmatex">\[ x \in A, y \in C, x &lt; y \implies  x \in C \tag{4} \]</div>
<p>임을 보일 것이다. 먼저 <span class="arithmatex">\(y \in C\)</span> 이므로 순서동형 <span class="arithmatex">\(g : S_y \to S _{\phi (y)}\)</span> 가 존재한다.(<em><span class="arithmatex">\(y\)</span> 에 의한 <span class="arithmatex">\(C\)</span> 의 절편과 순서동형인 <span class="arithmatex">\(B\)</span> 의 절편 <span class="arithmatex">\(S _{\phi (y)}\)</span> 을 만들 수 있다는 거지.</em>) 한편 <span class="arithmatex">\(x&lt;y\)</span> 이므로 <span class="arithmatex">\(S_x \subset S_y\)</span> 인데 <span class="arithmatex">\(g(S_x) = S _{g(x)}\)</span> 임을 보이자. 만일 <span class="arithmatex">\(z \in S_y\)</span> 이면 (<em><span class="arithmatex">\(g(z)&lt;g(x)\)</span> 라는 것은 <span class="arithmatex">\(g(x)\)</span> 에 의하여 생성된 절편에 <span class="arithmatex">\(g(z)\)</span> 가 포함됨을 뜻하므로</em>)</p>
<div class="arithmatex">\[ z \in S_x \iff z&lt;x \iff g(z)&lt;g(x) \iff g(z) \in S _{g(x)} \]</div>
<p>이다. 이는 <span class="arithmatex">\(S_x\)</span> 에 속하는 임의의 원소 <span class="arithmatex">\(z\)</span> 에 대하여 <span class="arithmatex">\(g(z)\)</span> 는 <span class="arithmatex">\(S _{g(x)}\)</span> 에 속한다는 것이고, 그 역도 성립한다는 것이다. 그러므로 임의의 원소 <span class="arithmatex">\(z \in S_x\)</span> 에 대한 <span class="arithmatex">\(g(z)\)</span> 를 집합 전체로 <span class="arithmatex">\(g(S_x)\)</span> 라고 표현하면 <span class="arithmatex">\(g(S_x) \subset S _{g(x)}\)</span> 인데 그 역도 성립하므로 <span class="arithmatex">\(g(S_x) \supset S _{g(x)}\)</span> 이다. 따라서 <span class="arithmatex">\(g(S_x) = S _{g(x)}\)</span> 인데, <span class="arithmatex">\(g\)</span> 의 제한 </p>
<div class="arithmatex">\[ g | _{S_x} : S_x \to g(S_x) \]</div>
<p>은 전사함수이므로 함수 <span class="arithmatex">\(g\)</span> 처럼 순서동형을 정의한다. 따라서 <span class="arithmatex">\(g | _{S_x} : S_x \to S _{g(x)}\)</span> 도 순서동형을 정의한다. 따라서 <span class="arithmatex">\(x \in C\)</span> 이다.(<em>대충 이런 뜻인 것 같은데. <span class="arithmatex">\(y\)</span> 로 형성된 절편 <span class="arithmatex">\(S_y\)</span> 와 순서동형인 <span class="arithmatex">\(S _{\phi (y)}\)</span> 을 만들 수 있고, 이렇게 만들어주는 함수 <span class="arithmatex">\(g:S_y \to S _{\phi (y)}\)</span> 를 만들었어. 근데 <span class="arithmatex">\(x&lt;y\)</span> 이면 <span class="arithmatex">\(g\)</span> 를 <span class="arithmatex">\(S_x\)</span> 에 제한한 함수 <span class="arithmatex">\(g| _{S_x}:S_x \to S _{g(x)}\)</span> 를 만들 수 있더라. 그러니까 <span class="arithmatex">\(x \in C\)</span> 이다 라는 것 같은데.</em>) ▲ </p>
<p>일반적으로 정렬집합 <span class="arithmatex">\(A\)</span> 의 부분집합 <span class="arithmatex">\(C\)</span> 가 <span class="arithmatex">\((4)\)</span> 를 만족하면 자동으로 <span class="arithmatex">\(C=A\)</span> 이거나 <span class="arithmatex">\(C\)</span> 는 <span class="arithmatex">\(A\)</span> 의 절편이 된다. 이를 보이기 위하여 <span class="arithmatex">\(C \subsetneq A\)</span> 라 하면 <span class="arithmatex">\(A \setminus C\)</span> 는 최소 원소 <span class="arithmatex">\(l\)</span> 을 갖는다. 이 경우 <span class="arithmatex">\(C = S_l\)</span> 인데, 이것을 보이자. 만약 <span class="arithmatex">\(x \in S_l\)</span> 이면 <span class="arithmatex">\(x&lt;l\)</span> 이므로 <span class="arithmatex">\(x \in C\)</span> 이다. 왜냐하면 <span class="arithmatex">\(x \in A \setminus C\)</span> 이면 <span class="arithmatex">\(l\)</span> 이 <span class="arithmatex">\(A \setminus C\)</span> 의 최소원소라는데에 모순이기 때문이다. 그러므로 </p>
<div class="arithmatex">\[ x \in S_l \implies x \in C \]</div>
<p>이다. 반대로 <span class="arithmatex">\(x \in C\)</span> 라고 하면 <span class="arithmatex">\(l \leq x\)</span> 일 때 <span class="arithmatex">\((4)\)</span> 에 의하여 <span class="arithmatex">\(l \in C\)</span> 인데 이것도 <span class="arithmatex">\(l\)</span> 이 <span class="arithmatex">\(A \setminus C\)</span> 의 최소 원소라는데 모순이다. 따라서 <span class="arithmatex">\(x \in C\)</span> 이면 <span class="arithmatex">\(l &gt; x\)</span>, 즉 <span class="arithmatex">\(x \in S_l\)</span> 이다. 그러므로</p>
<div class="arithmatex">\[ x \in C \implies x \in S_l \]</div>
<p>이다. 따라서 <span class="arithmatex">\(x \in C \iff x \in S_l\)</span> 이므로 <span class="arithmatex">\(C = S_l\)</span> 이 증명되었다. 그러므로 <span class="arithmatex">\(l\)</span> 의 값에 따라서 <span class="arithmatex">\(C = A\)</span> 이거나 <span class="arithmatex">\(C\)</span> 는 <span class="arithmatex">\(A\)</span> 의 절편이 된다. ▲ </p>
<p>마찬가지로 <span class="arithmatex">\(\phi (C) = B\)</span> 이거나 <span class="arithmatex">\(\phi (C)\)</span> 는 <span class="arithmatex">\(B\)</span> 의 절편이다. 그러므로 다음 네 가지 경우가 생긴다. </p>
<ol>
<li>
<p><span class="arithmatex">\(C = A, \phi (C) = B\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(C = A, \phi (C)\)</span> 는 <span class="arithmatex">\(B\)</span> 의 절편이다.</p>
</li>
<li>
<p><span class="arithmatex">\(C\)</span> 는 <span class="arithmatex">\(A\)</span> 의 절편이고, <span class="arithmatex">\(\phi (C) =B\)</span> 이다.</p>
</li>
<li>
<p><span class="arithmatex">\(C\)</span> 는 <span class="arithmatex">\(A\)</span> 의 절편이고, <span class="arithmatex">\(\phi (C)\)</span> 는 <span class="arithmatex">\(B\)</span> 의 절편이다.</p>
</li>
</ol>
<p><span class="arithmatex">\(\phi : C \to \phi (C)\)</span> 가 순서동형을 정의하는 것을 보였기에 d) 만 일어나지 않음을 보이면 모든 증명이 끝난다.</p>
<p>이를 위하여 <span class="arithmatex">\(x \in A, p \in B\)</span> 에 대하여 <span class="arithmatex">\(A\)</span> 의 절편으로써의 <span class="arithmatex">\(C = S_x\)</span>, <span class="arithmatex">\(B\)</span> 의 절편으로써의 <span class="arithmatex">\(\phi (C) = S_p\)</span> 라고 하자. 그러면 <span class="arithmatex">\(C \approxeq \phi (C)\)</span> 이므로 <span class="arithmatex">\(S_x \approxeq S_p\)</span> 이다. 그런데 <span class="arithmatex">\((4)\)</span> 를 가정했으므로 이는 <span class="arithmatex">\(x \in C = S_x\)</span> 임을 뜻한다. 즉, <span class="arithmatex">\(x &lt; x\)</span> 를 뜻하는데 이는 모순이다. 그러므로 d) 는 발생하지 않는다. 그러므로 모든 증명이 끝났다. ■ </p>
</li>
</ul>
<!-- > 집합론과 수체계를 공부하다보니 이러한 증명들이 완전하게 형식화되어 있어서 문득 이해하기 어렵지만, 실상 이 증명을 떠올린 수학자들은 오로지 무모순의 제약만 걸려있는 자유롭고 자유로운 상상의 세계에서 증명을 떠올렸지 않았을까. 그러면 내가 할 일은 그 자유로운 세계에서 떠올린 핵심 아이디어이다. 그것은 이러한 형식문처럼 딱딱하고 이해하기 어렵지 않다. 실상은 그러한 직관이 통찰한 핵심 아이디어를 엄밀하게 전달하기 위하여 이러한 딱딱한 형식문으로 형식화한 것이기 때문에, 내가 알아야 할 것은 수학자들이 원래 떠올렸던 직관이다.  -->
<h2 id="ordinal">Ordinal<a class="headerlink" href="#ordinal" title="Permanent link">¶</a></h2>
<a href="#b53f2c2bf"><div class="admonition def" id="b53f2c2bf">
<p class="admonition-title">순서수, 서수(ordinal)</p>
<p>정렬집합 <span class="arithmatex">\(\alpha\)</span> 가 다음을 만족하면 서수라고 한다. </p>
<div class="arithmatex">\[ \xi \in \alpha \implies S _{\xi } = \xi \]</div>
</div></a>
<ul>
<li>
<p>서수란 집합에 순서를 부여하기 위하여 고안된 개념이다. 유한집합이나 가산 무한집합에 순서를 부여하기 위해서는 자연수만으로 충분하지만, 비가산 집합에 순서를 부여하기 위해서는 자연수만으로 불충분하다. 이것을 해결하기 위하여 자연수를 포괄하면서 순서가 주어진 수체계가 필요했는데 그것이 서수이다.</p>
<ul>
<li>서수란 쉽게 말해 정렬 전순서 집합의 "길이" 를 측정하기 위하여 고안된 수이다.</li>
</ul>
</li>
<li>
<p>임의의 유한 정렬집합 <span class="arithmatex">\(X\)</span> 는 어떤 자연수 <span class="arithmatex">\(n\)</span> 과 유일하게 순서동형이다. 가령 <span class="arithmatex">\(X = \{a, x, j\} \approxeq 3 = \{0, 1, 2\}\)</span> 이다. 이때 <span class="arithmatex">\(\text{ord }(X) = 3\)</span> 이라고 한다. 즉, 임의의 유한 정렬집합 <span class="arithmatex">\(X\)</span> 의 서수를 </p>
<div class="arithmatex">\[ \text{ord }(X) \]</div>
<p>라고 쓴다. </p>
</li>
<li>
<p>서수 <span class="arithmatex">\(\alpha\)</span> 의 원소는 <span class="arithmatex">\(\alpha\)</span> 의 부분집합이다. </p>
<ul>
<li>
<p>예시 </p>
<p><span class="arithmatex">\(\beta \in \alpha\)</span> 이면 <span class="arithmatex">\(\beta  = S _{\beta } \subset \alpha\)</span> 이다.</p>
</li>
</ul>
</li>
</ul>
<a href="#37ef33ea7"><div class="admonition def" id="37ef33ea7">
<div class="arithmatex">\[ \text{ord }(\N) = \omega \]</div>
</div></a>
<ul>
<li>
<p>이제 자연수 집합 <span class="arithmatex">\(\N\)</span> 의 서수를 <span class="arithmatex">\(\omega\)</span> 라고 쓴다. </p>
</li>
<li>
<p>예시 </p>
<p>자연수 전체의 정렬집합 <span class="arithmatex">\(\omega\)</span> 는 서수이다. <span class="arithmatex">\(n \in \omega \implies  S_n = n\)</span> 이기 때문이다.</p>
<p>각 자연수 <span class="arithmatex">\(n \in \omega\)</span> 도 서수이다. <span class="arithmatex">\(m \in n \implies  S_m = m\)</span> 이기 때문이다.</p>
</li>
</ul>
<a href="#9d2b5990a"><div class="admonition def" id="9d2b5990a">
<p class="admonition-title">절대적 무한(Absolute Infinite)</p>
<p>이것보다 더 큰 수가 존재하지 않는 수이다.</p>
</div></a>
<ul>
<li>
<p>절대 무한을 <span class="arithmatex">\(\Omega\)</span> 라고 표기한다.</p>
</li>
<li>
<p>초한수 수열 <span class="arithmatex">\(\aleph _0, \alpha _1, \alpha _2, \dots\)</span> 을 극한으로 보낼 수 있고, <span class="arithmatex">\(\alpha _{\alpha _0}, \alpha _{\alpha _1},\alpha _{\alpha _2},  \dots\)</span> 수열도 극한으로 보낼 수 있는데, 이 과정 자체를 극한으로 보내면 <span class="arithmatex">\(\Omega\)</span> 에 도달할 수 있다.</p>
</li>
</ul>
<a href="#445f8ba2c"><div class="admonition def" id="445f8ba2c">
<p class="admonition-title">초한수(Transfinite number)</p>
<p>절대적 무한이 아닌 무한이다.</p>
</div></a>
<ul>
<li>
<p>칸토어가 절대적 무한과 구별하기 위하여 사용한 용어가 초한수이다. 초한수는 모든 유한수보다 크지만 절대적 무한보다는 작다.</p>
</li>
<li>
<p>모든 유한수는 기수와 서수로 표현할 수 있는데 기수는 집합의 크기를 나타내고, 서수는 정렬집합에서의 순서 길이를 나타낸다. 이를 확장하여 초한기수와 초한서수를 얻는다.</p>
</li>
<li>
<p>자연수의 초한서수를 <span class="arithmatex">\(\omega\)</span>, 초한기수를 <span class="arithmatex">\(\aleph_0\)</span> 으로 나타낸다.</p>
</li>
</ul>
<a href="#0cde45208"><div class="admonition def" id="0cde45208">
<p class="admonition-title">유한서수 </p>
<p>자연수 <span class="arithmatex">\(0,1,2,3,\dots\)</span> 는 서수인데 이들을 유한서수라고 한다.</p>
</div></a>
<h3 id="transfinite-ordinal-number">Transfinite Ordinal Number<a class="headerlink" href="#transfinite-ordinal-number" title="Permanent link">¶</a></h3>
<a href="#967511413"><div class="admonition def" id="967511413">
<p class="admonition-title">초한서수(Transfinite ordinal number)</p>
<p>무한 정렬 집합에서의 어떤 위치를 나타내는 수이다.</p>
</div></a>
<ul>
<li>
<p>가장 작은 초한서수는 자연수 집합 <span class="arithmatex">\(\N\)</span> 을 정렬집합으로 이해할 때의 </p>
<div class="arithmatex">\[ \omega \]</div>
<p>이다. 이는 아래에서 살펴보듯이 자연수 집합을 서수로서 사용할 때 <span class="arithmatex">\(\omega\)</span> 로 쓴다.</p>
</li>
<li>
<p>초한 서수를 다음과 같이 열거할 수 있다. </p>
<div class="arithmatex">\[ \omega , \omega +1, \omega +2, \dots, \omega 2, \omega 2+1, \omega 2+2,\dots, \omega 3, \omega 3+1,\dots \]</div>
<p>마찬가지로</p>
<div class="arithmatex">\[ \omega , \omega 2, \omega 3, \dots, \omega ^{2} \]</div>
<p>을 얻고, 이런식으로 반복하면</p>
<div class="arithmatex">\[ \omega ^{2} + 1, \omega ^{2} + 2, \dots, \omega ^{2} + \omega , \omega ^{2} + \omega + 1, \omega ^{2} + \omega + 2, \omega ^{2} + \omega 2, \]</div>
<div class="arithmatex">\[ \omega ^{2}+ \omega 2+1, \omega ^{2}+ \omega 3, \dots, \omega ^{2}+ \omega 4, \omega ^{2}2, \dots, \omega ^{3}, \dots, \omega ^{4}, \dots \]</div>
<div class="arithmatex">\[ \omega ^{\omega }, \dots, \omega ^{\omega ^{\omega } }, \dots, \omega ^{\omega ^{\omega ^{\omega } } }, \dots, \epsilon_0, \epsilon_0 + 1, \epsilon_0 + 2, \dots, \epsilon_0 + \omega , \]</div>
<div class="arithmatex">\[ \epsilon_0 + \omega 2 , \dots, \epsilon_0 + \omega ^{2} , \dots, \epsilon_0 + \omega ^{\omega } , \dots, \epsilon_0 2, \dots, \epsilon_0 \omega, \epsilon_0 \omega ^{\omega } ,\dots, \epsilon_0 ^{2} \dots \]</div>
<p>와 같이 계속 된다. <span class="arithmatex">\(\epsilon_0\)</span> 은 엄밀하게 </p>
<div class="arithmatex">\[ \epsilon _0 = \sup \{0, \omega ^{0}=1, \omega ^{1}=\omega , \omega ^{\omega }, \omega ^{\omega ^{\omega }}, \dots\} \]</div>
<p>와 같이 정의되며, </p>
<div class="arithmatex">\[ \omega ^{\alpha } = \alpha \tag{1} \]</div>
<p>를 만족하는 가장 작은 <span class="arithmatex">\(\alpha\)</span> 로 여겨진다. <span class="arithmatex">\(\epsilon _1\)</span> 는 <span class="arithmatex">\((1)\)</span> 를 만족하는 두번째 <span class="arithmatex">\(\alpha\)</span> 이다. <span class="arithmatex">\(\epsilon _1\)</span> 는 <span class="arithmatex">\(\epsilon _0\)</span> 처럼 <span class="arithmatex">\(0\)</span> 부터 시작하는 수열의 상한이 아닌 <span class="arithmatex">\(\epsilon _0+1\)</span> 부터 시작하는 수열의 상한</p>
<div class="arithmatex">\[ \epsilon _1 = \sup \{\epsilon _0 + 1, \omega ^{\epsilon _0 + 1}, \omega ^{\omega ^{\epsilon _0 + 1}}, \dots\} \]</div>
<p>으로 정의된다. 이때 </p>
<div class="arithmatex">\[ \omega ^{\epsilon _0 + 1} = \omega ^{\epsilon _0} \omega \]</div>
<div class="arithmatex">\[ \omega ^{\omega ^{\epsilon _0 + 1}} = \omega ^{\epsilon _0 \omega } = (\omega ^{\epsilon _0})^{\omega }=\epsilon _0 ^{\omega } \]</div>
<div class="arithmatex">\[ \omega ^{\omega ^{\omega ^{\epsilon _0 + 1}}} = \omega ^{\epsilon _0 ^{\omega }} = \omega ^{\epsilon _0 ^{1 + \omega }} = \omega ^{\epsilon _0 \epsilon _0 ^{\omega }} = (\omega ^{\epsilon _0}) ^{\epsilon _0 ^{\omega }} = \epsilon _0 ^{\epsilon _0 ^{\omega }} \]</div>
<p>이므로 <span class="arithmatex">\(\epsilon _1\)</span> 을 다음과 같은 수열의 상한으로도 정의할 수 있다.</p>
<div class="arithmatex">\[ \epsilon _1 = \sup \{0,1,\epsilon _0, \epsilon _0 ^{\epsilon _0}, \epsilon _0 ^{\epsilon _0 ^{\epsilon _0}}, \dots\} \]</div>
<p>일반적으로 엡실론 수 <span class="arithmatex">\(\epsilon _{\alpha +1}\)</span> 은 다음과 같이 정의된다.</p>
<div class="arithmatex">\[ \begin{equation} \begin{split}   \epsilon _{\alpha +1} &amp;= \sup \{\epsilon _{\alpha }+1, \omega ^{\epsilon _{\alpha } + 1}, \omega ^{\omega ^{\epsilon _{\alpha } + 1}}\}\\ &amp;= \sup \{0, 1, \epsilon _{\alpha }, \epsilon _{\alpha } ^{\epsilon _{\alpha }}, \epsilon _{\alpha } ^{\epsilon _{\alpha } ^{\epsilon _{\alpha }}}\} \end{split} \end{equation} \tag*{} \]</div>
<p>이때 다음과 같이 엡실론 수의 수열의 극한 으로 <span class="arithmatex">\(\epsilon _{\omega }\)</span> 을 얻는다.</p>
<div class="arithmatex">\[ \epsilon _{\omega } = \sup \{\epsilon _0, \epsilon _1, \epsilon _2, \dots\} \]</div>
<p>비슷한 방식으로 <span class="arithmatex">\(\epsilon _{\epsilon _0}\)</span> 을 정의할 수 있고, 이를 기반으로 <span class="arithmatex">\(\zeta _0\)</span> 를 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ \zeta _0 = \sup \{0, \epsilon _0, \epsilon _{\epsilon _0}, \epsilon _{\epsilon _{\epsilon _0}}, \dots\} \]</div>
<p><span class="arithmatex">\(\epsilon _0\)</span> 이 최초로 <span class="arithmatex">\(\omega ^{\alpha } = \alpha\)</span> 를 만족하는 서수라는 것과 같이 <span class="arithmatex">\(\zeta _0\)</span> 는 최초로 <span class="arithmatex">\(\epsilon _{\alpha } = \alpha\)</span> 를 만족하는 서수이다. </p>
<p>그러나 그리스 알파벳은 초한서수들을 모두 나타내기에 부족하므로 초한서수들을 나타내기에 적합한 강력한 표현법인 <a href="https://en.wikipedia.org/wiki/Veblen_function">Veblen function</a> 이 고안되었다. 이 함수는 <span class="arithmatex">\(\varphi _{\gamma }(\beta )\)</span> 의 형태로 초한귀납적으로 정의되어 초깃값으로 <span class="arithmatex">\(\varphi _0(\beta ) = \omega ^{\beta }\)</span> 을 정의한 후 <span class="arithmatex">\(\varphi _1(\beta ) = \epsilon _{\beta }, \varphi _2(\beta ) = \zeta _{\beta }, \dots\)</span> 와 같이 정의 된다.</p>
</li>
</ul>
<a href="#90afe3785"><div class="admonition def" id="90afe3785">
<p class="admonition-title">극한서수(limit ordinal)</p>
<p>서수 <span class="arithmatex">\(\alpha\)</span> 가 <span class="arithmatex">\(\alpha = \beta ^{+}\)</span> 인 <span class="arithmatex">\(\beta\)</span> 를 가지지 않으면 <span class="arithmatex">\(\alpha\)</span> 를 극한서수라고 한다. </p>
</div></a>
<ul>
<li>가령 <span class="arithmatex">\(\omega\)</span> 는 <span class="arithmatex">\(\omega = \alpha ^{+}\)</span> 인 <span class="arithmatex">\(\alpha\)</span> 가 존재하지 않으므로 극한서수이다.</li>
</ul>
<a href="#7d9709305"><div class="admonition def" id="7d9709305">
<p class="admonition-title">서로소 집합 함수</p>
<p><span class="arithmatex">\(g: A \to C, h: B \to D\)</span> 에 대하여 함수 <span class="arithmatex">\(g \sqcup h : A \sqcup B \to C \sqcup D\)</span> 를 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ (g \sqcup h) (x) = \begin{cases} g(x) &amp; x \in A\\ h(x) &amp; x \in B\\ \end{cases} \]</div>
</div></a>
<ul>
<li><span class="arithmatex">\(g,h\)</span> 가 순서동형을 정의한다면 <span class="arithmatex">\(g \sqcup h\)</span> 도 순서동형을 정의한다.</li>
</ul>
<h3 id="addition-multiples-of-ordinal-number">Addition, Multiples of Ordinal Number<a class="headerlink" href="#addition-multiples-of-ordinal-number" title="Permanent link">¶</a></h3>
<a href="#fca41114a"><div class="admonition def" id="fca41114a">
<p class="admonition-title">서수의 더하기(addition of ordinal number)</p>
<p><span class="arithmatex">\(\text{ord }(A) = \alpha , \text{ord }(B) = \beta\)</span> 인 서로소인 정렬집합 <span class="arithmatex">\(A, B\)</span> 에 대하여 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ \alpha + \beta = \text{ord }(A \sqcup B) \]</div>
</div></a>
<ul>
<li>
<p>이때 <span class="arithmatex">\(A \sqcap B\)</span> 의 정렬순서는 정의 "서로소 집합의 순서" 에 의하여 결정된다.</p>
</li>
<li>
<p>교환법칙이 성립하지 않는다.</p>
<ul>
<li>
<p>예시 </p>
<p>정의 "서로소 집합의 순서" 의 예시에서 보았듯 </p>
<div class="arithmatex">\[ \omega + 1 \neq 1 + \omega = \omega \]</div>
<p>이다. </p>
</li>
</ul>
</li>
<li>
<p>결합법칙이 성립한다.</p>
<ul>
<li>증명</li>
</ul>
</li>
</ul>
<a href="#0323ca0f0"><div class="admonition def" id="0323ca0f0">
<p class="admonition-title">서수의 곱하기(multiple of ordinal number)</p>
<p>반사전순서가 부여된 <span class="arithmatex">\(A \times B\)</span> 에 대하여 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ \alpha \beta  = \text{ord }(A \times B) \]</div>
</div></a>
<ul>
<li>
<p>교환법칙이 성립하지 않는다.</p>
<ul>
<li>
<p>예시 </p>
<p>정의 "반사전순서" 의 예시에서 보았듯 <span class="arithmatex">\(\omega \approxeq X \times \omega, \quad \omega \not \approxeq \omega \times X\)</span> 으로써 </p>
<div class="arithmatex">\[ \omega 2 \neq 2 \omega = \omega \]</div>
<p>이다.</p>
</li>
</ul>
</li>
<li>
<p>결합법칙이 성립한다.</p>
<ul>
<li>증명</li>
</ul>
</li>
<li>
<p>분배법칙은 항상 성립하지 않으므로 조심히 다뤄야 한다. 즉, 왼쪽 분배법칙은 성립하나, 오른쪽 분배법칙은 성립하지 않는다.</p>
<ul>
<li>
<p>증명</p>
</li>
<li>
<p>예시 </p>
<p>가령 </p>
<div class="arithmatex">\[ (1 + 1) \omega = 2 \omega \neq \omega 2=\omega +\omega =1 \omega +1 \omega \]</div>
<p>이다. 하지만 왼쪽 분배법칙 </p>
<div class="arithmatex">\[ \alpha (\beta + \gamma ) = \alpha \beta + \alpha \gamma \]</div>
<p>은 성립한다.</p>
</li>
</ul>
</li>
</ul>
<a href="#1c9f8703c"><div class="admonition def" id="1c9f8703c">
<p class="admonition-title">서수의 제곱 </p>
<p>임의의 서수 <span class="arithmatex">\(\alpha ,\beta\)</span> 에 대하여 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ \alpha ^{\beta } = \begin{cases} \sup \{\alpha ^{\gamma } : \gamma &lt; \beta \} &amp; \beta \text{ 가 극한서수이다 }\\ \alpha ^{\gamma }\alpha &amp; \beta = \gamma + 1\\ \end{cases} \]</div>
</div></a>
<h3 id="order-of-ordinal-number">Order of Ordinal Number<a class="headerlink" href="#order-of-ordinal-number" title="Permanent link">¶</a></h3>
<a href="#f85dc3565"><div class="admonition def" id="f85dc3565">
<p class="admonition-title">서수의 순서(order of ordinal number)</p>
<p>서수 <span class="arithmatex">\(\alpha , \beta\)</span> 에 대한 <span class="arithmatex">\(\text{ord }(A) =\alpha ,\text{ord }(B) = \beta\)</span> 인 정렬집합 <span class="arithmatex">\(A, B\)</span> 에 대하여 <span class="arithmatex">\(A\)</span> 가 <span class="arithmatex">\(B\)</span> 의 절편과 순서동형이면 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ \alpha &lt; \beta \]</div>
</div></a>
<ul>
<li>
<p>서수인 정렬집합 <span class="arithmatex">\(A\)</span> 에서 임의의 <span class="arithmatex">\(a \in A\)</span> 에 대하여 <span class="arithmatex">\(a \leq A\)</span> 이다.</p>
</li>
<li>
<p>물론 <span class="arithmatex">\(\alpha &lt; \beta \lor \alpha = \beta\)</span> 이면 </p>
<div class="arithmatex">\[ \alpha \leq \beta \]</div>
<p>로 정의한다. </p>
</li>
<li>
<p><a href="#90ba9203e">정리 3.3.1</a> 는 임의의 서수 <span class="arithmatex">\(\alpha , \beta\)</span> 에 대하여 </p>
<div class="arithmatex">\[ \alpha &lt; \beta , \quad  \alpha = \beta , \quad  \alpha &gt; \beta \]</div>
<p>중 하나가 성립함을 말해준다. </p>
</li>
</ul>
<a href="#eaed9d1d0"><div class="admonition def" id="eaed9d1d0">
<p class="admonition-title">정리 3.3.2</p>
<p>정렬집합 <span class="arithmatex">\(A\)</span> 의 부분집합 <span class="arithmatex">\(B\)</span> 가 다음을 만족하면 <span class="arithmatex">\(B = A\)</span> 이다.</p>
<div class="arithmatex">\[ x \in A, S_x \subset B \implies x \in B \]</div>
</div></a>
<ul>
<li>
<p>이 정리는 정렬집합 <span class="arithmatex">\(\omega\)</span> 에 관한 귀납법이 임의의 정렬집합에 대하여 어떻게 확장되는지 보여준다. </p>
</li>
<li>
<p>증명 </p>
<p><span class="arithmatex">\(A \setminus B \neq \varnothing\)</span> 이면 최소원소 <span class="arithmatex">\(a \in A \setminus B\)</span> 를 가진다. 그러면 <span class="arithmatex">\(S_a \subset B\)</span> 이고 <span class="arithmatex">\(a \in B\)</span> 가 되어 모순이다. 그러므로 <span class="arithmatex">\(A \setminus B = \varnothing\)</span> 이다. ■ </p>
</li>
</ul>
<a href="#b91fdee1f"><div class="admonition def" id="b91fdee1f">
<p class="admonition-title">정리 3.3.3</p>
<p>정렬집합에 관한 성질 <span class="arithmatex">\(P\)</span> 와 임의의 정렬집합 <span class="arithmatex">\(X\)</span> 에 대하여 다음이 만족되면 임의의 정렬집합이 <span class="arithmatex">\(P\)</span> 를 만족한다.</p>
<ul>
<li><span class="arithmatex">\(X\)</span> 의 모든 절편이 <span class="arithmatex">\(P\)</span> 를 만족하면 <span class="arithmatex">\(X\)</span> 도 <span class="arithmatex">\(P\)</span> 를 만족한다.</li>
</ul>
</div></a>
<ul>
<li>
<p>이 정리는 정렬집합 <span class="arithmatex">\(\omega\)</span> 에 관한 귀납법이 임의의 정렬집합에 대하여 어떻게 확장되는지 보여준다. </p>
</li>
<li>
<p>증명 </p>
<p>어떤 정렬집합 <span class="arithmatex">\(X\)</span> 가 <span class="arithmatex">\(P\)</span> 를 만족하지 않는다면 </p>
<div class="arithmatex">\[ Y = \{x \in X : S_x \text{ 가 } P \text{ 를 만족하지 않는다 }\} \neq \varnothing \]</div>
<p>이고, <span class="arithmatex">\(Y\)</span> 는 최소원소 <span class="arithmatex">\(a \in X\)</span> 를 갖는다. 그러면 <span class="arithmatex">\(S_a\)</span> 의 모든 절편은 <span class="arithmatex">\(P\)</span> 를 만족하는데, 가정에 의하여 <span class="arithmatex">\(S_a\)</span> 도 <span class="arithmatex">\(P\)</span> 를 만족하므로 모순이다. ■ </p>
</li>
</ul>
<h2 id="infinite-set">Infinite Set<a class="headerlink" href="#infinite-set" title="Permanent link">¶</a></h2>
<h3 id="equinumerous">Equinumerous<a class="headerlink" href="#equinumerous" title="Permanent link">¶</a></h3>
<a href="#befc9ace5"><div class="admonition def" id="befc9ace5">
<p class="admonition-title">집합의 대등(equinumerous)</p>
<p>두 집합 <span class="arithmatex">\(X\)</span> 와 <span class="arithmatex">\(Y\)</span> 사이에 전단사함수가 존재하면 <span class="arithmatex">\(X\)</span> 와 <span class="arithmatex">\(Y\)</span> 가 대등하다고 한다.</p>
</div></a>
<ul>
<li>
<p><strong>두 집합 <span class="arithmatex">\(X\)</span> 와 <span class="arithmatex">\(Y\)</span> 가 대등한 것을 <span class="arithmatex">\(X \approx Y\)</span> 와 같이 표기한다.</strong></p>
</li>
<li>
<p>이는 집합 <span class="arithmatex">\(A\)</span> 의 크기 <span class="arithmatex">\(|A|\)</span> 를 비교하기 위한 정의로써 <span class="arithmatex">\(A \approx B \iff |A| = |B|\)</span> 가 성립한다.</p>
</li>
</ul>
<a href="#bb6bb24d0"><div class="admonition def" id="bb6bb24d0">
<div class="arithmatex">\[ \N \approx \mathbb{Z} \approx \mathbb{Q} \]</div>
</div></a>
<ul>
<li>
<p>이 정리는 자연수집합 <span class="arithmatex">\(\N\)</span>, 정수집합 <span class="arithmatex">\(\mathbb{Z}\)</span>, 유리수집합 <span class="arithmatex">\(\mathbb{Q}\)</span> 이 대등하다는 것을 말해준다.</p>
</li>
<li>
<p>증명 </p>
<p>함수 <span class="arithmatex">\(f: \N \to \mathbb{Z}\)</span> 를 </p>
<div class="arithmatex">\[ f(2n) = -n, \quad f(2n-1) = n \]</div>
<p>라 정의하면 <span class="arithmatex">\(f\)</span> 는 자연수 전체 집합 <span class="arithmatex">\(\N\)</span> 에서 정수 전체 집합 <span class="arithmatex">\(\mathbb{Z}\)</span> 로 가는 함수가 된다. 한편 함수 <span class="arithmatex">\(g : \mathbb{Z} \to \N\)</span> 를 </p>
<div class="arithmatex">\[ g(n) = 2n-1, g(-n) = 2n \]</div>
<p>이라 정의하면 <span class="arithmatex">\(f\)</span> 와 <span class="arithmatex">\(g\)</span> 는 역함수관계를 갖고 <span class="arithmatex">\(f\)</span> 와 <span class="arithmatex">\(g\)</span> 는 전단사 함수가 된다. 그러므로 </p>
<div class="arithmatex">\[ \therefore \N \approx \mathbb{Z} \]</div>
<p>이다. ▲ </p>
<p>양의 유리수 집합 <span class="arithmatex">\(\mathbb{Q} ^{+}\)</span> 를 </p>
<div class="arithmatex">\[ \dfrac{1}{1},\enspace \dfrac{1}{2}, \dfrac{2}{1},\enspace \dfrac{1}{3}, \dfrac{2}{2}, \dfrac{3}{1},\enspace \dfrac{1}{4}, \dfrac{2}{3}, \dfrac{3}{2}, \dfrac{4}{1},\enspace \dfrac{1}{5}, \dfrac{2}{4}, \dfrac{3}{3}, \dfrac{4}{2}, \dfrac{5}{1}, \dots \]</div>
<p>와 같이 나열하고 이 나열의 <span class="arithmatex">\(n\)</span>번째 유리수를 <span class="arithmatex">\(f(n)\)</span> 이라 두면 <span class="arithmatex">\(f: \N \to \mathbb{Q} ^{+}\)</span> 는 전사함수가 된다. 이때 중복되는 유리수를 제거하여 </p>
<div class="arithmatex">\[ \dfrac{1}{1},\enspace \dfrac{1}{2}, \dfrac{2}{1},\enspace \dfrac{1}{3}, \dfrac{3}{1},\enspace \dfrac{1}{4}, \dfrac{2}{3}, \dfrac{3}{2}, \dfrac{4}{1},\enspace \dfrac{1}{5}, \dfrac{5}{1}, \dots \]</div>
<p>를 만들고 마찬가지로 <span class="arithmatex">\(n\)</span> 번째 유리수를 <span class="arithmatex">\(g(n)\)</span> 라 두면 <span class="arithmatex">\(g: \N \to \mathbb{Q} ^{+}\)</span> 은 전단사함수가 된다. 그러므로 </p>
<div class="arithmatex">\[ \therefore \N \approx \mathbb{Q} ^{+} \]</div>
<p>이다. 이때 공역을 음의 유리수 <span class="arithmatex">\(\mathbb{Q} ^{-}\)</span> 와 <span class="arithmatex">\(0\)</span> 를 포함하도록 확장하고 정의역을 <span class="arithmatex">\(\N\)</span> 에서 <span class="arithmatex">\(\mathbb{Z}\)</span> 로 바꾸면 같은 방식으로 전단사 함수 <span class="arithmatex">\(h: \mathbb{Z} \to \mathbb{Q}\)</span> 를 쉽게 만들 수 있음을 알 수 있다. 그러므로 </p>
<div class="arithmatex">\[ \therefore \mathbb{Z} \approx \mathbb{Q} \]</div>
<p>이다. ▲ </p>
<p>그러므로 최종적으로</p>
<div class="arithmatex">\[ \therefore \N \approx \mathbb{Z} \approx \mathbb{Q} \]</div>
<p>이다. ■ </p>
</li>
</ul>
<a href="#a2bf99bed"><div class="admonition def" id="a2bf99bed">
<p>두 선분 위의 점들의 집합은 선분의 길이에 관계없이 항상 대등하다.</p>
</div></a>
<ul>
<li>
<p>한편 이 정리를 더 확장하여 </p>
<div class="arithmatex">\[ [x_1, x_2] \approx [y_1, y_2] \text{ s.t. }\  \forall x_1, x_2, y_1, y_2 \in \R \]</div>
<p>라고 할 수 있다.</p>
</li>
<li>
<p>증명 </p>
<p>길이가 같은 선분 사이에 전단사함수가 존재함은 자명하다. ▲ </p>
<p><img alt="image" src="https://user-images.githubusercontent.com/16812446/111862271-a2d70680-8997-11eb-8367-9aca8a3c0b07.png"/></p>
<p>위와 같이 길이가 다른 선분 <span class="arithmatex">\(\overline{AB}, \overline{CD}\)</span> 가 존재한다. 그러면 <span class="arithmatex">\(\overline{AC}\)</span> 와 <span class="arithmatex">\(\overline{BD}\)</span> 의 연장선은 평행하지 않으므로 한 점 <span class="arithmatex">\(O\)</span> 에서 만난다. 이때 선분 <span class="arithmatex">\(\overline{AB}\)</span> 위의 점 <span class="arithmatex">\(P\)</span> 에 대하여 <span class="arithmatex">\(\overline{OP}\)</span> 의 연장선이 <span class="arithmatex">\(\overline{CD}\)</span> 와 만나는 점을 <span class="arithmatex">\(f(P)\)</span> 로 두면 함수 </p>
<div class="arithmatex">\[ f: \overline{AB} \to \overline{CD} \]</div>
<p>는 전단사함수이다. ■ </p>
</li>
</ul>
<a href="#d4441515d"><div class="admonition def" id="d4441515d">
<div class="arithmatex">\[\N \not \approx [0, 1]\]</div>
</div></a>
<ul>
<li>
<p>이 정리는 자연수 집합 <span class="arithmatex">\(\N\)</span> 이 폐구간 <span class="arithmatex">\([0, 1]\)</span> 과 대등하지 않다는 것을 말해준다.</p>
</li>
<li>
<p>아래의 증명이 그 유명한 칸토어의 대각선 논법이다. </p>
</li>
<li>
<p>증명 </p>
<p><span class="arithmatex">\(\N\)</span> 에서 <span class="arithmatex">\([0,1]\)</span> 로 가는 전사함수가 존재하지 않음을 보이면 된다. 만약 함수 <span class="arithmatex">\(f: \N \to [0,1]\)</span> 이 전사함수라고 가정하자. 그러면 함수 <span class="arithmatex">\(f\)</span> 의 상은 무한소수로 표현될 수 있으므로 </p>
<div class="arithmatex">\[ f(0) = 0. x _{00} x _{01} x _{02} \dots x _{0n} \dots \]</div>
<div class="arithmatex">\[ f(1) = 0. x _{10} x _{11} x _{12} \dots x _{1n} \dots \]</div>
<div class="arithmatex">\[ f(2) = 0. x _{20} x _{21} x _{22} \dots x _{2n} \dots \]</div>
<div class="arithmatex">\[ \vdots \]</div>
<div class="arithmatex">\[ f(n) = 0. x _{n0} x _{n1} x _{n2} \dots x _{nn} \dots \]</div>
<div class="arithmatex">\[ \vdots \]</div>
<p>와 같이 표현할 수 있다. 이때 수열 <span class="arithmatex">\(\big &lt;a_n\big &gt;\)</span> 을 </p>
<div class="arithmatex">\[ a_n = \begin{cases} 0 &amp;x _{nn} \neq 0\\ 1 &amp;x _{nn} = 0 \end{cases} \]</div>
<p>로 정의하면 소수 <span class="arithmatex">\(\alpha  =0.a_0 a_1 a_2 \dots a_n \dots \in [0, 1]\)</span> 은 </p>
<div class="arithmatex">\[ \alpha \not\in \{f(0), f(1), f(2), \dots\} = \text{ran} (f)  \]</div>
<p>이다. 그러므로 <span class="arithmatex">\(f\)</span> 는 전사함수가 아니다. ■ </p>
</li>
</ul>
<a href="#334e731d3"><div class="admonition def" id="334e731d3">
<div class="arithmatex">\[\N \times \N \approx \N\]</div>
</div></a>
<ul>
<li>
<p>증명 </p>
<p><span class="arithmatex">\(\N\)</span> 에 속하는 자연수들을 다음과 같은 규칙으로 좌표평면의 1사분면에 나열하자.</p>
<div class="arithmatex">\[ \begin{equation}\begin{split} \vdots &amp;\\ 10&amp;\\ 6&amp;\enspace 11\\ 3&amp;\enspace 7\enspace 12\enspace \\ 1&amp;\enspace 4\enspace 8\enspace 13 \\ 0&amp;\enspace 2\enspace 5\enspace 9\enspace 14\enspace \dots \\ \end{split}\end{equation} \tag*{} \]</div>
<p>즉, 자연수 <span class="arithmatex">\(\N = \{0, 1, 2, 3, \dots\}\)</span> 를 <span class="arithmatex">\(\searrow\)</span> 방향으로 <span class="arithmatex">\(n, m \in \N\)</span> 에 대한 1사분면의 좌표 <span class="arithmatex">\((n, m)\)</span> 에 나열하는 것이다. 그러면 <span class="arithmatex">\(\N\)</span> 을 1사분면의 자연수 좌표에 모두 대응시킬 수 있다. 이때 첫번째 세로열에서 나타나는 좌표 <span class="arithmatex">\((0, m)\)</span> 들의 수열은 <span class="arithmatex">\(a _{0m} = 0 + \sum_{k=0}^{m+0}k\)</span> 로 나타낼 수 있다. 또 두번째 세로열에서 나타나는 좌표 <span class="arithmatex">\((1, m)\)</span> 들의 수열은 <span class="arithmatex">\(a _{1m} = 1 + \sum_{k=0}^{m+1}k\)</span> 로 나타낼 수 있다. 이때 <span class="arithmatex">\(n\)</span> 번째 세로열에서 나타나는 좌표 <span class="arithmatex">\((n,m)\)</span> 들의 수열은 <span class="arithmatex">\(a _{nm} = n + \sum_{k=0}^{m+n}k\)</span> 이다. 그러므로 임의의 좌표 <span class="arithmatex">\((n, m)\)</span> 에 대응되는 함수 <span class="arithmatex">\(f: \N \times \N \to \N\)</span> 을 </p>
<div class="arithmatex">\[ f(n, m) = n + \sum_{k=0}^{n+m}k = n + \dfrac{(n+m+1)(n+m)}{2} = \dfrac{(m+n) ^{2} + 3n + m}{2} \]</div>
<p>로 정의할 수 있다. 이는 <span class="arithmatex">\(\N \times \N\)</span> 을 <span class="arithmatex">\(\N\)</span> 으로 대응시키는 전단사 사상이다. ■ </p>
</li>
<li>
<p>(<em>이건 왜 이렇게 되는지 아직 모르겠네</em>)한편, 역함수를 정의해보면 각 <span class="arithmatex">\(k \in \N\)</span> 에 대하여 </p>
<div class="arithmatex">\[ \dfrac{1}{2}l(l+1) \leq k &lt; \dfrac{1}{2}(l+1)(l+2) \]</div>
<p>인 유일한 자연수 <span class="arithmatex">\(l \in \N\)</span> 을 잡고 </p>
<div class="arithmatex">\[ g(k) = \bigg (k - \dfrac{1}{2}l(l+1), l - \bigg [k - \dfrac{1}{2}l(l+1)\bigg ]\bigg ) \]</div>
<p>라 정의하면된다.</p>
</li>
</ul>
<a href="#c669a0451"><div class="admonition def" id="c669a0451">
<p><span class="arithmatex">\(n \in \N\)</span> 에 대하여 다음이 성립한다.</p>
<div class="arithmatex">\[\N ^{n} \approx \N\]</div>
</div></a>
<ul>
<li>
<p>증명</p>
<div class="arithmatex">\[ \because \N \times \N \approx \N \]</div>
</li>
</ul>
<a href="#bdf20edf2"><div class="admonition def" id="bdf20edf2">
<p class="admonition-title">3.16 무한 집합의 특성</p>
<p>자기자신과 대등한 진부분집합이 존재한다. 즉, 집합 <span class="arithmatex">\(X\)</span> 가 무한집합이면 다음이 만족한다.</p>
<div class="arithmatex">\[ \exists A \approx X \text{ s.t. }\ A \subset X \]</div>
</div></a>
<ul>
<li>
<p>정의 "집합의 대등" 의 여러가지 예시에서 다룬 집합들은 모두 이 특성을 만족한다. </p>
<ul>
<li>
<p>예시 </p>
<p>자연수 집합 <span class="arithmatex">\(\N\)</span> 은 짝수 집합과 대등하다. </p>
<p>실수 집합 <span class="arithmatex">\(\R\)</span> 은 개구간 <span class="arithmatex">\((0, 1)\)</span> 과 대등하다. 이 사실은 다음과 같은 탄젠트 함수 <span class="arithmatex">\(y = \tan \bigg (\pi x - \dfrac{\pi }{2}\bigg )\)</span> 를 살펴보면 쉽게 이해할 수 있다.</p>
<p><img alt="" src="https://user-images.githubusercontent.com/16812446/83792797-8868c080-a6d6-11ea-8dac-6238abb22dfa.png"/></p>
<p>즉, 놀랍게도 <span class="arithmatex">\(\R \approx (0, 1)\)</span> 이다.</p>
</li>
</ul>
</li>
</ul>
<a href="#556bbefdd"><div class="admonition def" id="556bbefdd">
<p class="admonition-title">도움정리 3.4.1</p>
<p>집합 <span class="arithmatex">\(X\)</span> 가 무한 집합의 특성을 만족하고 <span class="arithmatex">\(X \approx Y\)</span> 이면 <span class="arithmatex">\(Y\)</span> 도 무한 집합의 특성을 만족한다.</p>
</div></a>
<ul>
<li>
<p>증명 </p>
<p>집합 <span class="arithmatex">\(X\)</span> 에 대하여 <span class="arithmatex">\(\exists A \text{ s.t. }\ A \subsetneq X\)</span> 이고, 가정에 의하여 전단사함수 <span class="arithmatex">\(f: X \to A\)</span> 가 존재한다. 또한 집합 <span class="arithmatex">\(Y\)</span> 에 대하여 가정에 의하여 전단사 함수 <span class="arithmatex">\(g: X \to Y\)</span> 가 존재한다. ▲ </p>
<p>그러면 제한 <span class="arithmatex">\(g|_A : A \to g(A)\)</span> 는 전단사함수이고, 이에따라 </p>
<div class="arithmatex">\[ (g|_A) \circ f \circ g ^{-1}: Y \to g(A) \]</div>
<p>도 전단사함수이다. 그러므로 <span class="arithmatex">\(g(A)\)</span> 가 <span class="arithmatex">\(Y\)</span> 의 진부분집합이면 증명이 끝난다. ▲ </p>
<p>그런데 <span class="arithmatex">\(x \in X \setminus A \implies g(x) Y \setminus g(A)\)</span> 이므로 <span class="arithmatex">\(g(A) \subsetneq  Y\)</span> 이다. 그러므로 </p>
<div class="arithmatex">\[ \therefore g(A) \approx Y \]</div>
<p>이다. ■ </p>
</li>
</ul>
<a href="#051d85424"><div class="admonition def" id="051d85424">
<p class="admonition-title">도움정리 3.4.2</p>
<p>집합 <span class="arithmatex">\(X\)</span> 가 무한 집합의 특성을 만족하고 <span class="arithmatex">\(X \subset  Y\)</span> 이면 <span class="arithmatex">\(Y\)</span> 도 무한 집합의 특성을 만족한다.</p>
</div></a>
<ul>
<li>
<p>증명 </p>
<p>집합 <span class="arithmatex">\(X\)</span> 의 진부분집합 <span class="arithmatex">\(A\)</span> 에 대하여 전단사함수 <span class="arithmatex">\(f: X \to A\)</span> 가 존재한다. 이때 함수 <span class="arithmatex">\(g: Y \to Y\)</span> 를 </p>
<div class="arithmatex">\[ g(y) = \begin{cases} y &amp; y \in Y \setminus X\\ f(y) &amp; y \in X \end{cases} \]</div>
<p>라 정의하면 <span class="arithmatex">\(g\)</span> 는 단사함수이고 치역이 <span class="arithmatex">\(A \sqcup (Y \setminus X)\)</span> 이다. 그런데 <span class="arithmatex">\(A \subsetneq X\)</span> 이므로 </p>
<div class="arithmatex">\[A \sqcup (Y \setminus X) \subsetneq Y = X \sqcup (Y \setminus X)\]</div>
<p>이다. 그러면 함수 <span class="arithmatex">\(g\)</span> 의 공역을 축소시킨 <span class="arithmatex">\(h: Y \to A \sqcup (Y \setminus X)\)</span> 는 전사함수이다. <span class="arithmatex">\(g\)</span> 는 단사함수이었으므로 <span class="arithmatex">\(h\)</span> 는 전단사함수이고, 따라서 </p>
<div class="arithmatex">\[ \therefore  Y \approx A \sqcup (Y \setminus X) \]</div>
<p>이다. ■ </p>
</li>
</ul>
<a href="#c3505ebf1"><div class="admonition def" id="c3505ebf1">
<p class="admonition-title">비둘기 집 원리(Pigeonhole principle)</p>
<p><span class="arithmatex">\(n = \{0,1,2, \dots, n-1\} \in \N\)</span> 에 대한 임의의 단사함수 <span class="arithmatex">\(f: n \to n\)</span> 가 전사이다.</p>
</div></a>
<ul>
<li>
<p>증명</p>
<p><span class="arithmatex">\(n=0\)</span> 일 때는 자명하다. <span class="arithmatex">\(n\)</span> 일때 성립한다고 하고 <span class="arithmatex">\(n ^{+}\)</span> 일 때도 성립함을 보이기 위하여 함수 </p>
<div class="arithmatex">\[ f: n ^{+} \to n ^{+} \]</div>
<p>가 단사라고 하자. 함수 <span class="arithmatex">\(f\)</span> 를 <span class="arithmatex">\(n ^{+} = n \sqcup \{n\}\)</span> 의 부분집합 <span class="arithmatex">\(n\)</span> 에 제한하면 단사함수 <span class="arithmatex">\(f|_n:n \to n ^{+}\)</span> 를 얻는다.</p>
<p>우선 <span class="arithmatex">\(f(n) \subset n\)</span> 이라고 하면 가정에 의하여(<em><span class="arithmatex">\(f\)</span> 가 <span class="arithmatex">\(n\)</span> 에 대하여 전단사라는 가정</em>) <span class="arithmatex">\(f(n) = n \subset n ^{+}\)</span> 이다. (<em>이때 주의할 점은 <span class="arithmatex">\(f(n)=n\)</span> 을 한 원소의 대응으로 해석하는 게 아니라 <span class="arithmatex">\(n\)</span> 이라는 집합에 집합 <span class="arithmatex">\(n\)</span> 이 대응된다고 해석해야한다는 것이다. <span class="arithmatex">\(f:n \to n\)</span> 가 <span class="arithmatex">\(n\)</span> 에 대하여 전단사이므로 정의역과 치역이 <span class="arithmatex">\(n\)</span> 이다. 그런 의미에서 <span class="arithmatex">\(f(n)=n\)</span> 이라고 표기한 것이다</em>) 따라서 <span class="arithmatex">\(f(n) = n \in n ^{+}\)</span> 이고(<em>이때의 <span class="arithmatex">\(f(n)=n\)</span> 은 <span class="arithmatex">\(n\)</span> 이라는 집합이 <span class="arithmatex">\(n\)</span> 에 대응되는 것으로써 표기한 것이 아니라 한 원소 <span class="arithmatex">\(n\)</span> 이 <span class="arithmatex">\(n\)</span> 으로 대응된다는 것으로써 표기한 것이다. 그러므로 <span class="arithmatex">\(f(n) = n\)</span> 이 공역 <span class="arithmatex">\(n ^{+} = n \sqcup \{n\}\)</span> 의 <span class="arithmatex">\(\{n\}\)</span> 에 대응되므로 공역이 곧 치역이 되어 전사함수가 된다는 것이다.</em>), <span class="arithmatex">\(f\)</span> 는 전사함수이다. 그러므로 <span class="arithmatex">\(f\)</span> 는 전단사 함수이다. ▲ </p>
<p>(<em>위 증명에서 <span class="arithmatex">\(f(n) = n \subset n ^{+}\)</span> 은 정의역 <span class="arithmatex">\(n\)</span> 이 치역 <span class="arithmatex">\(n\)</span> 으로 대응된다는 것이고 <span class="arithmatex">\(f(n) = n \in n ^{+}\)</span> 은 한 원소 <span class="arithmatex">\(n\)</span> 이 <span class="arithmatex">\(n\)</span> 으로 대응된다는 것으로 표기한 것이 매우 애매하고 헷갈렸던 이유는 전자의 함수의 입출력이 집합이라는 단서가 오로지 <span class="arithmatex">\(\subset\)</span> 기호에 있고, 후자의 함수의 입출력이 원소라는 단서가 오로지 <span class="arithmatex">\(\in\)</span> 기호에 있기 때문이었던 거지..</em>)</p>
<p>이제 <span class="arithmatex">\(f(n) \not \subseteq n\)</span> 인 경우를 생각하자. 그러면 <span class="arithmatex">\(f(k) \not\in n\)</span> 인 <span class="arithmatex">\(k \in n\)</span> 이 존재한다. 그러면 <span class="arithmatex">\(f(k) \in n ^{+} \setminus n\)</span> 이므로 <span class="arithmatex">\(f(k) = n \in n ^{+}\)</span> 이다.</p>
<p>이제 함수 <span class="arithmatex">\(g: n ^{+} \to n ^{+}\)</span> 를 </p>
<div class="arithmatex">\[ g(k) = n \in n ^{+}, \enspace g(n) = k \in n ^{+}, \enspace g(x) = x, \enspace x \in n \setminus \{k\} \]</div>
<p>와 같이 정의하자. 그러면 <span class="arithmatex">\(g\)</span> 는 <span class="arithmatex">\(n ^{+} = \{n\}\sqcup \{k\}\sqcup (n \setminus \{k\})\)</span> 에서 단지 <span class="arithmatex">\(n\)</span> 과 <span class="arithmatex">\(k\)</span> 만을 바꾸고 나머지는 그대로 대응시키는 함수에 불과 하므로 자명하게 전단사함수이다. </p>
<p>합성함수 <span class="arithmatex">\(f \circ g : n ^{+} \to n ^{+}\)</span> 에 대하여 <span class="arithmatex">\((f \circ g)(n) \subset n \subset n ^{+}\)</span> 이고 (<em>이 부분도 마찬가지로 집합 <span class="arithmatex">\(n\)</span> 이 집합 <span class="arithmatex">\(n\)</span> 으로 대응됨을 뜻한다</em>) <span class="arithmatex">\((f \circ g)(n) = n \in n ^{+}\)</span> 이다. (<em>이 부분도 원소 <span class="arithmatex">\(n\)</span> 이 <span class="arithmatex">\(n\)</span> 으로 대응됨을 뜻하지</em>) </p>
<p>따라서 <span class="arithmatex">\((f \circ g)|_n:n \to n\)</span> 에 귀납법의 가정(<em><span class="arithmatex">\(f\)</span> 가 <span class="arithmatex">\(n\)</span> 에서 전단사라는 가정</em>)을 적용하면 <span class="arithmatex">\((f \circ g)|_n\)</span> 이 전단사임을 알 수 있다. (<em>이로써 <span class="arithmatex">\((f \circ g)(n) = n \subset n ^{+}\)</span> 이 보장되는 거지. 그래서 이제 함수의 제한을 풀고 <span class="arithmatex">\((f \circ g)(n) = n \in n ^{+}\)</span> 만 보이면 전사함수가 되는데 이건 이미 위에서 보였으니까</em>) 따라서 <span class="arithmatex">\(f \circ g\)</span> 는 전단사이고, <span class="arithmatex">\(f = (f \circ g) \circ g ^{-1}\)</span> 도 전단사이다.(<em><span class="arithmatex">\(g\)</span> 가 전단사이므로 <span class="arithmatex">\(g ^{-1}\)</span> 도 전단사니까</em>) ■ </p>
</li>
</ul>
<a href="#b64052abc"><div class="admonition def" id="b64052abc">
<p class="admonition-title">정리 3.4.3</p>
<p>자연수 <span class="arithmatex">\(n = \{0, 1, 2, \dots, n-1\}\)</span> 의 부분집합 <span class="arithmatex">\(A\)</span> 에 대하여 다음이 성립한다.</p>
<div class="arithmatex">\[ n \approx A \implies n = A \]</div>
</div></a>
<ul>
<li>
<p>증명 </p>
<p><span class="arithmatex">\(A \subset n\)</span> 에 대하여 <span class="arithmatex">\(n \approx A\)</span> 이므로 전단사 함수 <span class="arithmatex">\(f: n \to A\)</span> 가 존재한다. <span class="arithmatex">\(n \neq A\)</span> 라고 한다면 <span class="arithmatex">\(k \in n \setminus A\)</span> 가 존재하여 <span class="arithmatex">\(k \not\in A\)</span> 이다. 그런데 <span class="arithmatex">\(f\)</span> 는 전단사함수이므로 <span class="arithmatex">\(f(k) = l \in A\)</span> 이다. 이때 <span class="arithmatex">\(n \setminus \{k\} = A \lor n \setminus \{k\} \supsetneq A\)</span> 이다. </p>
<p><span class="arithmatex">\(n \setminus \{k\} = A\)</span> 인 경우 <span class="arithmatex">\(f\)</span> 가 전단사이므로 <span class="arithmatex">\(f(n \setminus \{k\}) = f(A) = A\)</span> 가 되어 </p>
<div class="arithmatex">\[ \exists k' \in n \setminus \{k\} \text{ s.t. }\  f(k') = l \]</div>
<p>이다. <span class="arithmatex">\(f\)</span> 는 단사이므로 <span class="arithmatex">\(f(k) = l \land f(k') = l\)</span> 는 모순이다. ▲ </p>
<p><span class="arithmatex">\(n \setminus \{k\}\supsetneq A\)</span> 인 경우 <span class="arithmatex">\(n \setminus \{k\} \neq A\)</span> 이므로 <span class="arithmatex">\(k' \in n \setminus A \cup \{k\}\)</span> 이다. 그런데 <span class="arithmatex">\(f\)</span> 는 전단사이므로 <span class="arithmatex">\(f(k') = l' \in A\)</span> 이다. 그러면 또 다시 <span class="arithmatex">\(n \setminus \{k,k'\} = A \lor n \setminus \{k,k'\} \supsetneq A\)</span> 이다. 이런식으로 <span class="arithmatex">\(A\)</span> 에 속하지 않는 <span class="arithmatex">\(n\)</span> 의 원소 <span class="arithmatex">\(k'', k''', \dots\)</span> 을 제거한 집합 <span class="arithmatex">\(n'\)</span> 을 만들어 <span class="arithmatex">\(n' = A\)</span> 가 되게 할 수 있다. 그러면 위의 논증과 마찬가지로 <span class="arithmatex">\(f(n') = A\)</span> 가 되는데 </p>
<div class="arithmatex">\[ \exists x \in n' \text{ s.t. }\ f(x) = l \]</div>
<p>에서 <span class="arithmatex">\(f(k) = l \land f(x) = l\)</span> 인데 <span class="arithmatex">\(f\)</span> 는 단사이므로 모순이 된다. ▲ </p>
<p>그러므로 </p>
<div class="arithmatex">\[ \therefore  n = A\]</div>
<p>이다.</p>
<ul>
<li>
<p><a href="#794c1114c">비둘기 집 원리</a> 는 집합 <span class="arithmatex">\(n\)</span> 에서 <span class="arithmatex">\(n\)</span> 으로 가는 단사 함수라면 전사함수이라고 말하고 있고, 이 정리는 <span class="arithmatex">\(n\)</span> 에서 <span class="arithmatex">\(A (\subset n)\)</span> 으로 가는 전단사함수가 존재하면 <span class="arithmatex">\(n=A\)</span> 라고 말하고 있네. 그럼 이 둘이 서로 역인데, 어떻게 비둘기 집 원리 정리를 적용할 수 있을까.</p>
<p>위 증명은 어떻게 비둘기 집 원리 정리가 본 정리의 증명에 적용되는지 모르겠어서 내가 만든 것이므로 오류가 있을 수 있다.</p>
</li>
</ul>
</li>
</ul>
<h3 id="finite-set">Finite Set<a class="headerlink" href="#finite-set" title="Permanent link">¶</a></h3>
<a href="#7db563b7f"><div class="admonition def" id="7db563b7f">
<p class="admonition-title">유한집합(finite set)</p>
<p>집합 <span class="arithmatex">\(X\)</span> 가 다음을 만족하면 유한집합이라 한다. </p>
<div class="arithmatex">\[ \exists n \in \N \text{ s.t. }\ n \approx X \]</div>
</div></a>
<ul>
<li>
<p><a href="#b64052abc">정리 3.4.3</a> 는 어떤 자연수 <span class="arithmatex">\(n\)</span> 도 무한집합의 특성을 만족하지 않음을 말한다.</p>
<p>따라서 도움정리 3.4.1 를 적용하면 임의의 유한집합은 무한집합의 특성을 만족하지 않는다. 이제 이 역을 보이려 하는데, 유한집합이 아니면 무한집합의 특성을 만족한다는 것을 보이려 하는 것이다. </p>
<p>도움정리 3.4.2 가 있으므로 이미 <span class="arithmatex">\(\N\)</span> 이 무한집합의 특성을 만족한다는 것을 알게 되었다. 그러므로 다음 정리를 증명하면 된다. </p>
</li>
</ul>
<a href="#8ab5072fc"><div class="admonition def" id="8ab5072fc">
<p class="admonition-title">도움정리 3.4.4</p>
<p>집합 <span class="arithmatex">\(X\)</span> 가 유한집합이 아니면, <span class="arithmatex">\(\exists A \subset X \text{ s.t. }\ \N \approx A\)</span> 이다.</p>
</div></a>
<ul>
<li>
<p>증명     </p>
<p>먼저 선택공리에 의하여 집합 <span class="arithmatex">\(X\)</span> 의 선택함수 <span class="arithmatex">\(h: 2 ^{X} \setminus \{\varnothing \} \to X\)</span> 를 택하자. <span class="arithmatex">\(X\)</span> 의 모든 유한 부분집합들의 모임 <span class="arithmatex">\(\mathcal{F}(X)\)</span> 에 대하여 <a href="../numbers#3a99b431b">정리 2.1.2</a> 를 적용할 것이다. <span class="arithmatex">\(X\)</span> 는 유한집합이 아니므로 임의의 <span class="arithmatex">\(A \in \mathcal{F}(X)\)</span> 에 대하여 <span class="arithmatex">\(X \setminus A \neq \varnothing\)</span> 이고 따라서 <span class="arithmatex">\(h(X \setminus A) \in X \setminus A\)</span> 이다. 이제 함수 <span class="arithmatex">\(F: \mathcal{F}(X) \to \mathcal{F}(X)\)</span> 를 <span class="arithmatex">\(A \in \mathcal{F}(X)\)</span> 에 대하여</p>
<div class="arithmatex">\[ F(A) = A \sqcup \{h(X \setminus A)\} \]</div>
<p>라고 정의하면 <span class="arithmatex">\(n \in \N\)</span> 에 대하여</p>
<div class="arithmatex">\[ \gamma (0) = \varnothing , \quad \gamma (n ^{+}) = F(\gamma (n)) \]</div>
<p>인 함수 <span class="arithmatex">\(\gamma : \N \to \mathcal{F}(X)\)</span> 가 존재한다.</p>
<p><span class="arithmatex">\(\forall n \in \N\)</span> 에 대하여 <span class="arithmatex">\(\gamma (n)\)</span> 은 <span class="arithmatex">\(X\)</span> 의 유한부분집합이므로 <span class="arithmatex">\(X \setminus \gamma (n) \neq \varnothing\)</span> 이고 함수 <span class="arithmatex">\(\delta : \N \to X\)</span> 를 <span class="arithmatex">\(n \in \N\)</span> 에 대하여</p>
<div class="arithmatex">\[ \delta (n) = h(X \setminus \gamma (n)) \]</div>
<p>와 같이 정의할 수 있다. 그러면 각 <span class="arithmatex">\(n \in \N\)</span> 에 대하여 </p>
<div class="arithmatex">\[ \gamma (n ^{+}) = F(\gamma (n)) = \gamma (n) \sqcup \{h(X \setminus \gamma (n))\} = \gamma (n) \sqcup \{\delta (n)\} \]</div>
<p>이므로 <span class="arithmatex">\(\gamma (n ^{+})\)</span> 란 <span class="arithmatex">\(\gamma (n) \subset X\)</span> 에 <span class="arithmatex">\(\delta (n) \in X\)</span> 이라는 원소를 추가한 것임을 알 수 있다.</p>
<p>이제 <span class="arithmatex">\(\delta : \N \to X\)</span> 가 단사함수임을 보이기 위해 <span class="arithmatex">\(n&lt;m\)</span> 라고 두는데, <span class="arithmatex">\(n ^{+} \leq m\)</span> 이므로 <span class="arithmatex">\(\delta (n) \in \gamma (n ^{+}) \subset \gamma (m)\)</span> 이다. 따라서 </p>
<div class="arithmatex">\[ \delta (m) = h(X \setminus \gamma (m)) \in X \setminus \gamma (m) \]</div>
<p>이 되어 <span class="arithmatex">\(\delta (n) \neq \delta (m)\)</span> 이다. 그러므로 함수 <span class="arithmatex">\(\delta :\N \to X\)</span> 의 상 <span class="arithmatex">\(\delta (\N)\)</span> 은 <span class="arithmatex">\(X\)</span> 의 부분집합이고, <span class="arithmatex">\(\N\)</span> 과 대등하다. 즉, <span class="arithmatex">\(X\)</span> 의 부분집합 <span class="arithmatex">\(\delta (\N)\)</span> 은</p>
<div class="arithmatex">\[ \delta (\N) \approx \N \]</div>
<p>이므로 증명이 끝났다. ■ </p>
<ul>
<li>이 증명을 쉽게 말하면 다음과 같다. <span class="arithmatex">\(x_1 \in X\)</span> 를 하나 잡으면 <span class="arithmatex">\(X \setminus \{x_1\} \neq \varnothing\)</span> 이다. 따라서 <span class="arithmatex">\(x_2 \in X \setminus \{x_1\}\)</span> 를 택할 수 있고, <span class="arithmatex">\(x_3 \in X \setminus \{x_1, x_2\}\)</span> 도 택할 수 있다. 만약 <span class="arithmatex">\(x_1, x_2, \dots, x_n \in X\)</span> 을 택했다고 해도 <span class="arithmatex">\(\forall n \in \N\)</span> 에 대하여</li>
</ul>
<div class="arithmatex">\[ X \setminus \{x_1, x_2, \dots, x_n \} \neq \varnothing \]</div>
<p>이다. 이렇게 계속 <span class="arithmatex">\(x_n\)</span> 을 택함으로써 집합 </p>
<div class="arithmatex">\[ A = \{x_n : n = 1, 2, \dots \} \]</div>
<p>을 만들자. 그러면 <span class="arithmatex">\(A\)</span> 는 <span class="arithmatex">\(X\)</span> 의 부분집합이고 <span class="arithmatex">\(A \approx \N\)</span> 이다. 이렇게 무한히 선택할 수 있다는 것이 선택공리가 주장하는 것이다.</p>
</li>
</ul>
<h3 id="definition-of-infinite-set">Definition of Infinite Set<a class="headerlink" href="#definition-of-infinite-set" title="Permanent link">¶</a></h3>
<a href="#0cf0f4f07"><div class="admonition def" id="0cf0f4f07">
<p class="admonition-title">정리 3.4.5 무한집합(infinite set)</p>
<p>다음 동치조건을 만족하는 집합 <span class="arithmatex">\(X\)</span> 를 무한집합이라 한다.</p>
<ol>
<li>
<p><span class="arithmatex">\(X\)</span> 가 유한집합이 아니다. 즉, <span class="arithmatex">\(\forall n \in \N, X \not \approx n\)</span> 이다.</p>
</li>
<li>
<p><span class="arithmatex">\(\exists A \subsetneq X \text{ s.t. }\ X \approx A\)</span></p>
</li>
</ol>
</div></a>
<ul>
<li>지금까지의 정리들의 결론이 이 무한집합의 정의이다.</li>
</ul>
<h2 id="cardinal-number">Cardinal Number<a class="headerlink" href="#cardinal-number" title="Permanent link">¶</a></h2>
<a href="#16e4feac1"><div class="admonition def" id="16e4feac1">
<p class="admonition-title">기수(cardinal number)</p>
<p>임의의 집합 <span class="arithmatex">\(X\)</span> 에 대하여 <span class="arithmatex">\(X\)</span> 와 동등한 서수 전체의 집합의 최소원소</p>
<div class="arithmatex">\[ |X| := \min \{\xi : \xi \approx X, \xi \preccurlyeq 2 ^{X}\} \]</div>
<p>를 <span class="arithmatex">\(X\)</span> 의 기수라고 한다.</p>
</div></a>
<ul>
<li>
<p>기수는 <span class="arithmatex">\(|X| = \text{card }(X)\)</span> 라고도 표기한다.</p>
</li>
<li>
<p>기수란 집합에 들어있는 원소의 갯수를 의미한다.</p>
</li>
<li>
<p>이 정의는 아래에서 살펴볼 <a href="#f69fd2ad6">정리 3.6.4</a> 를 기반으로 한다.</p>
</li>
<li>
<p>유한집합에 대해서는 기수의 정의를 다음과 같이 쉽게 생각해도 된다.</p>
<p>"유한집합 <span class="arithmatex">\(X\)</span> 와 대등한 자연수 <span class="arithmatex">\(n \in \N\)</span> 으로써 </p>
<div class="arithmatex">\[ |X| = n \]</div>
<p>이다."</p>
</li>
<li>
<p>기수는 임의의 집합 <span class="arithmatex">\(A\)</span> 에 대하여 </p>
<div class="arithmatex">\[ A_1 \approx A_2 \iff |A_1| = |A_2| \]</div>
<p>를 만족해야 한다. </p>
</li>
</ul>
<h3 id="addition-multiples-of-cardinal-number">Addition, Multiples of Cardinal Number<a class="headerlink" href="#addition-multiples-of-cardinal-number" title="Permanent link">¶</a></h3>
<a href="#1e2160e6c"><div class="admonition def" id="1e2160e6c">
<p class="admonition-title">기수의 더하기(addition of cardinal number)</p>
<p>서로소 집합 <span class="arithmatex">\(A, B\)</span> 와 그 기수 <span class="arithmatex">\(a = |A| ,b = |B|\)</span> 에 대하여 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ a + b = |A \sqcup B| \]</div>
</div></a>
<ul>
<li>
<p>이 연산은 잘 정의되어 있다. </p>
<ul>
<li>
<p>증명 </p>
<div class="arithmatex">\[ A \approx C , B \approx D \implies A \sqcup B \approx C \sqcup D \]</div>
<p>를 보이면 된다. 만약 <span class="arithmatex">\(g: A \to C, h: B \to D\)</span> 가 전단사이면 함수 <span class="arithmatex">\(g \sqcup h: A \sqcup B \to C \sqcup D\)</span> 도 전단사이므로 <span class="arithmatex">\(a+b\)</span> 가 잘 정의되어 있음을 알 수 있다.</p>
</li>
</ul>
</li>
<li>
<p>교환법칙이 성립한다. </p>
<ul>
<li>
<p>증명 </p>
<p><span class="arithmatex">\(A \sqcup B = B \sqcup A\)</span> 이므로 <span class="arithmatex">\(a+b=b+a\)</span> 이다.</p>
</li>
</ul>
</li>
<li>
<p>결합법칙이 성립한다. </p>
<ul>
<li>
<p>증명 </p>
<p>집합의 합집합의 결합법칙이 성립하므로 <span class="arithmatex">\((a+b)+c=a+(b+c)\)</span> 도 성립한다.</p>
</li>
</ul>
</li>
</ul>
<a href="#ce4ea40e8"><div class="admonition def" id="ce4ea40e8">
<p class="admonition-title">기수의 곱하기(multiple of cardinal number)</p>
<p><span class="arithmatex">\(|A| =a, |B| = b\)</span> 인 집합 <span class="arithmatex">\(A, B\)</span> 에 대하여 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ ab = |A \times B| \]</div>
</div></a>
<ul>
<li>
<p>이 연산은 잘 정의되어 있고, 교환법칙/결합법칙/분배법칙이 성립한다.</p>
<ul>
<li>증명 </li>
</ul>
</li>
</ul>
<a href="#d7190ce13"><div class="admonition def" id="d7190ce13">
<p class="admonition-title">기수의 제곱 </p>
<p><span class="arithmatex">\(|A| =a,|B| =b\)</span> 에 대하여 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ a ^{b} = |A ^{B}| \]</div>
</div></a>
<a href="#0238efac4"><div class="admonition def" id="0238efac4">
<p>기수의 제곱은 잘 정의되어 있다.</p>
</div></a>
<ul>
<li>
<p>증명 </p>
<p><span class="arithmatex">\(g:A \to C, h:B \to D\)</span> 가 전단사라고 하고 함수 <span class="arithmatex">\(f_1: A ^{B} \to C ^{D}, f_2:C ^{D} \to A ^{B}\)</span> 를 </p>
<div class="arithmatex">\[ f_1(\alpha ) = g \circ \alpha \circ h ^{-1}, \quad \alpha \in A ^{B} \]</div>
<div class="arithmatex">\[ f_2(\beta ) = g ^{-1} \circ \beta \circ h , \quad \beta \in C ^{D} \]</div>
<p>와 같이 정의하면 </p>
<div class="arithmatex">\[ f_1(f_2(\beta )) = g \circ (g ^{-1} \circ \beta \circ h) \circ h ^{-1} = \beta \]</div>
<p>이고, 마찬가지로 <span class="arithmatex">\(f_2(f_1(\alpha ))=\alpha\)</span> 이므로 <span class="arithmatex">\(f_1\)</span> 과 <span class="arithmatex">\(f_2\)</span> 는 서로 역함수이다. 그러므로 이들은 전단사 함수이고, 이는 곧 </p>
<div class="arithmatex">\[ A ^{B} \approx C ^{D} \]</div>
<p>를 의미한다. ■ </p>
</li>
</ul>
<a href="#88d837e03"><div class="admonition def" id="88d837e03">
<p><span class="arithmatex">\(B \cup C = \varnothing\)</span> 인 집합 <span class="arithmatex">\(A,B,C\)</span> 에 대한 기수 <span class="arithmatex">\(a = |A| , b = |B| , c = |C|\)</span> 에 대하여 다음이 성립한다.</p>
<ul>
<li>
<p><span class="arithmatex">\(a ^{b+c} = a ^{b}a ^{c}\)</span></p>
</li>
<li>
<p><span class="arithmatex">\((ab) ^{c} = a ^{c} b ^{c}\)</span></p>
</li>
<li>
<p><span class="arithmatex">\((a ^{b})^{c} = a ^{bc}\)</span></p>
</li>
</ul>
</div></a>
<ul>
<li>
<p>증명</p>
<p>pass</p>
</li>
</ul>
<h3 id="cantorbernstein-theorem">Cantor–Bernstein theorem<a class="headerlink" href="#cantorbernstein-theorem" title="Permanent link">¶</a></h3>
<a href="#c9bbb7032"><div class="admonition def" id="c9bbb7032">
<p>집합 <span class="arithmatex">\(A, B\)</span> 사이에 단사함수 <span class="arithmatex">\(f: A \to B\)</span> 가 존재하면 다음과 같이 표기한다.</p>
<div class="arithmatex">\[ A \preccurlyeq B \]</div>
</div></a>
<ul>
<li>
<p>임의의 집합 <span class="arithmatex">\(A\)</span> 에 대하여 <span class="arithmatex">\(A \preccurlyeq A\)</span> 이다.</p>
</li>
<li>
<p>단사의 합성이 단사이므로 </p>
<div class="arithmatex">\[ A \preccurlyeq B, B \preccurlyeq C \implies A \preccurlyeq C \]</div>
<p>이다.</p>
</li>
</ul>
<a href="#1267052d9"><div class="admonition def" id="1267052d9">
<p class="admonition-title">정리 3.5.1</p>
<p>임의의 집합 <span class="arithmatex">\(A, B\)</span> 에 대하여 다음이 성립한다.</p>
<div class="arithmatex">\[ A \preccurlyeq B \lor B \preccurlyeq A \]</div>
</div></a>
<ul>
<li>
<p>증명</p>
<p>임의의 집합 <span class="arithmatex">\(A, B\)</span> 에 대하여 <a href="#2f7ff02de">체르멜로 정렬정리</a> 를 적용하여 정렬순서를 부여하자. </p>
<p>그러면 <a href="#90ba9203e">정리 3.3.1</a> 에 의하여 <span class="arithmatex">\(A \approx B\)</span> 이거나 적절한 <span class="arithmatex">\(a \in A, b \in B\)</span> 에 대하여 <span class="arithmatex">\(A \approx S_b \subset B\)</span> 혹은 <span class="arithmatex">\(B \approx S_a \subset A\)</span> 가 성립한다.</p>
</li>
</ul>
<a href="#4b9b77cb1"><div class="admonition def" id="4b9b77cb1">
<p class="admonition-title">정리 3.5.2 베른슈타인의 정리(Cantor–Bernstein theorem)</p>
<p>집합 <span class="arithmatex">\(A, B\)</span> 에 대하여 다음이 성립한다. </p>
<div class="arithmatex">\[A \preccurlyeq B \land B \preccurlyeq A \implies A \approx B\]</div>
</div></a>
<ul>
<li>
<p>이 정리는 쉽게 말해 두 집합 <span class="arithmatex">\(A, B\)</span> 사이에 <span class="arithmatex">\(A \to B\)</span> 로 가는 단사함수와 <span class="arithmatex">\(B \to A\)</span> 로 가는 단사함수가 존재하면 <span class="arithmatex">\(A, B\)</span> 사이에 전단사 함수가 존재함을 말해준다.</p>
</li>
<li>
<p>이 정리는 기수의 연산에서 핵심적인 역할을 한다.</p>
</li>
<li>
<p>증명 </p>
<p>단사함수 <span class="arithmatex">\(f: A \to B, g: B \to A\)</span> 를 두고, <a href="#3a99b431b">정리 2.1.2</a> 를 적용하여 <span class="arithmatex">\(A\)</span> 의 부분집합 <span class="arithmatex">\(C_n\)</span> 과 <span class="arithmatex">\(B\)</span> 의 부분집합 <span class="arithmatex">\(D_n\)</span> 을 <span class="arithmatex">\(n \in \N\)</span> 에 대하여</p>
<div class="arithmatex">\[ C_0 = A \setminus g(B), \enspace D_0 = f(C_0) \]</div>
<div class="arithmatex">\[ C _{n+1} = g(D_n), \enspace D_n = f(C_n) \]</div>
<p>라고 정의하자. 이제 <span class="arithmatex">\(C = \bigcup_{n=0}^{\infty }C_n \subset A\)</span> 라 하고 함수 <span class="arithmatex">\(h: A \to B\)</span> 를 </p>
<div class="arithmatex">\[ h(x) = \begin{cases} f(x) &amp;x \in C\\ g ^{-1}(x) &amp; x \in A \setminus C\\ \end{cases} \]</div>
<p>와 같이 정의한다. <span class="arithmatex">\(x \in A \setminus C\)</span> 이면 <span class="arithmatex">\(x \in A \setminus C_0=g(B)\)</span> 이므로 <span class="arithmatex">\(g ^{-1}(x) \in B\)</span> 가 잘 정의된다. ▲ </p>
<p><span class="arithmatex">\(h\)</span> 가 단사임을 보이기 위해 <span class="arithmatex">\(x_1 \neq x_2\)</span> 인 <span class="arithmatex">\(x_1, x_2 \in A\)</span> 를 잡자. <span class="arithmatex">\(x_1, x_2 \in C\)</span> 이거나 <span class="arithmatex">\(x_1, x_2 \in A \setminus C\)</span> 이면 자명하게 <span class="arithmatex">\(h(x_1) \neq h(x_2)\)</span> 이다. 그러니 <span class="arithmatex">\(x_1 \in C, x_2 \in A \setminus C\)</span> 라고 하자.</p>
<p>그러면 적절한 <span class="arithmatex">\(n\)</span> 에 대하여 <span class="arithmatex">\(x_1 \in C_n\)</span> 이므로 <span class="arithmatex">\(h(x_1) = f(x_1) \in D_n\)</span> 이다. 한편 <span class="arithmatex">\(h(x_2) = g ^{-1}(x_2) \in D_n\)</span> 이면 <span class="arithmatex">\(x_2 \in g(D_n) \subset C\)</span> 이므로 <span class="arithmatex">\(x_2 \not\in C\)</span> 라는 것에 모순이다. 따라서 <span class="arithmatex">\(h(x_2) \not\in D_n\)</span> 이다. 그러므로 <span class="arithmatex">\(h(x_1) \neq h(x_2)\)</span> 이다. ▲ </p>
<p><span class="arithmatex">\(h\)</span> 가 전사임을 보이기 위해 <span class="arithmatex">\(D = \bigcup_{n=0}^{\infty  }\)</span> 라고 두자. 우선 <span class="arithmatex">\(h(C) = f(C) = D\)</span> 이므로 <span class="arithmatex">\(D \subset h(A)\)</span> 이다. 이제 <span class="arithmatex">\(B \setminus D \subset h(A)\)</span> 임을 보이면 <span class="arithmatex">\(h\)</span> 는 전사가 된다. </p>
<p>이를 위하여 <span class="arithmatex">\(y \in B \setminus D\)</span> 라고 하면 <span class="arithmatex">\(C_0 = A \setminus g(B)\)</span> 이므로 <span class="arithmatex">\(g(y) \not\in C_0\)</span> 은 당연하다. 또 각 <span class="arithmatex">\(n = 0,1,2,\dots\)</span> 에 대하여 <span class="arithmatex">\(y \not\in D_n\)</span> 이고 <span class="arithmatex">\(C _{n+1}=g(D_n)\)</span> 인데 <span class="arithmatex">\(g\)</span> 가 단사이므로 <span class="arithmatex">\(D\)</span> 에 속하지 않는 원소 <span class="arithmatex">\(y\)</span> 의 상은 <span class="arithmatex">\(C\)</span> 에 속하지 않는다. 즉, <span class="arithmatex">\(g(y) \not\in C _{n+1}\)</span> 이다.</p>
<p>그러므로 <span class="arithmatex">\(g(y) \not\in C\)</span> 인데, <span class="arithmatex">\(h\)</span> 의 정의에 의하여 <span class="arithmatex">\(y = g ^{-1}(g(y)) = h(g(y)) \in h(A)\)</span> 에서 결국 임의의 <span class="arithmatex">\(B \setminus D\)</span> 의 원소 <span class="arithmatex">\(y\)</span> 에 대하여</p>
<div class="arithmatex">\[ y \in h(A) \]</div>
<p>가 성립하여, <span class="arithmatex">\(h\)</span> 가 전사임이 증명되었다. ▲ </p>
<p>그러므로 <span class="arithmatex">\(h\)</span> 는 전단사이고 모든 증명이 끝났다. ■ </p>
</li>
<li>
<p>또 다른 증명</p>
<p>pass</p>
</li>
</ul>
<h3 id="order-of-cardinal-number">Order of Cardinal Number<a class="headerlink" href="#order-of-cardinal-number" title="Permanent link">¶</a></h3>
<a href="#8025d14e9"><div class="admonition def" id="8025d14e9">
<p class="admonition-title">기수의 순서(order of cardinal number)</p>
<p>두 기수 <span class="arithmatex">\(a = |A| , b = |B|\)</span> 에 대하여 다음과 같이 정의한다.</p>
<div class="arithmatex">\[ A \preccurlyeq B \iff a \leq b \]</div>
</div></a>
<ul>
<li>이 순서는 잘 정의되어 있고, 순서관계의 조건을 만족시킨다.</li>
</ul>
<a href="#209160b34"><div class="admonition def" id="209160b34">
<p>기수 <span class="arithmatex">\(a, b, c\)</span> 에 대하여 <span class="arithmatex">\(a \leq b \iff \exists c \text{ s.t. }\ b = a + c\)</span> 이다.</p>
</div></a>
<ul>
<li>
<p>이 정리는 기수의 순서가 자연수의 순서와 유사한 성질을 갖는다는 것을 말해준다.</p>
</li>
<li>
<p>증명 </p>
<p>먼저 <span class="arithmatex">\(a \leq b\)</span> 이면 <span class="arithmatex">\(A \preccurlyeq B\)</span> 이므로 단사함수 <span class="arithmatex">\(f: A \to B\)</span> 가 존재한다. 이때 <span class="arithmatex">\(c = |B \setminus f(A)|\)</span> 라 두면 <span class="arithmatex">\(a + c = |A \sqcup (B \setminus f(A))| = |B| = b\)</span> 이다. 왜냐하면 기수간의 <span class="arithmatex">\(=\)</span> 은 전단사함수의 존재성을 뜻하는데 서로소 집합 <span class="arithmatex">\(A, B\)</span> 에 대하여 <span class="arithmatex">\(B \setminus f(A)\)</span> 에 <span class="arithmatex">\(A\)</span> 를 <span class="arithmatex">\(\sqcup\)</span> 된 집합은 <span class="arithmatex">\(B\)</span> 와 일대일 대응될 수 있기 때문이다. ▲ </p>
<p>역으로 <span class="arithmatex">\(c =|C|\)</span> 인 집합 <span class="arithmatex">\(C\)</span> 가 존재하고 <span class="arithmatex">\(f: A \sqcup C \to B\)</span> 가 전단사이면 <span class="arithmatex">\(f|_A: A \to B\)</span> 는 단사이고 따라서 <span class="arithmatex">\(a \leq b\)</span> 이다. ■ </p>
</li>
</ul>
<h2 id="transfinite-cardinal-number">Transfinite Cardinal Number<a class="headerlink" href="#transfinite-cardinal-number" title="Permanent link">¶</a></h2>
<a href="#87b89e0b4"><div class="admonition def" id="87b89e0b4">
<p>임의의 무한집합 <span class="arithmatex">\(X\)</span> 에 대하여 다음이 성립한다.</p>
<div class="arithmatex">\[ |\N| \leq |X|\]</div>
</div></a>
<ul>
<li>
<p>증명</p>
<p><span class="arithmatex">\(X\)</span> 가 무한집합이면 <a href="#8ab5072fc">도움정리 3.4.4</a> 에 의하여 단사함수 <span class="arithmatex">\(f: \N \to X\)</span> 가 존재한다. ■ </p>
</li>
</ul>
<h3 id="size-of-natual-number">Size of Natual Number<a class="headerlink" href="#size-of-natual-number" title="Permanent link">¶</a></h3>
<a href="#993047c5e"><div class="admonition def" id="993047c5e">
<p class="admonition-title">자연수의 초한기수</p>
<div class="arithmatex">\[\aleph _0 = |\N|\]</div>
</div></a>
<ul>
<li>
<p>이는 가장 작은 초한기수이다.</p>
</li>
<li>
<p><span class="arithmatex">\(\N \approx \mathbb{Z} \approx \mathbb{Q}\)</span> 이므로 </p>
<div class="arithmatex">\[ |\N| = |\mathbb{Z}| = |\mathbb{Q}| = \aleph _0 \]</div>
<p>이다.</p>
</li>
</ul>
<h3 id="size-of-real-number">Size of Real Number<a class="headerlink" href="#size-of-real-number" title="Permanent link">¶</a></h3>
<a href="#eef6e2e8a"><div class="admonition def" id="eef6e2e8a">
<p class="admonition-title">실수의 초한기수</p>
<div class="arithmatex">\[\mathfrak{c} = |\R|\]</div>
</div></a>
<ul>
<li>
<p>단사함수 <span class="arithmatex">\(f: \N \to \R\)</span> 은 존재하지만 <span class="arithmatex">\(\R\)</span> 을 <span class="arithmatex">\(\N\)</span> 으로 보내는 단사함수는 존재하지 않으므로 </p>
<div class="arithmatex">\[ \aleph _0 &lt; \mathfrak{c} \]</div>
<p>이다.</p>
</li>
</ul>
<h3 id="countable-set">Countable Set<a class="headerlink" href="#countable-set" title="Permanent link">¶</a></h3>
<a href="#bb2738fdf"><div class="admonition def" id="bb2738fdf">
<p class="admonition-title">가산 집합(countable set)</p>
<p>집합 <span class="arithmatex">\(X\)</span> 의 기수가 다음을 만족하면 <span class="arithmatex">\(X\)</span> 를 셀 수 있는 집합이라고 한다.</p>
<div class="arithmatex">\[ |X| \leq \aleph _0 \]</div>
</div></a>
<ul>
<li>
<p>유한집합은 가산집합이다. </p>
</li>
<li>
<p><span class="arithmatex">\(\N , \mathbb{Z} , \mathbb{Q}\)</span> 는 가산 무한집합이다. 가산 무한집합을 가부번 집합이라고도 한다.</p>
</li>
</ul>
<h3 id="uncountable-set">Uncountable Set<a class="headerlink" href="#uncountable-set" title="Permanent link">¶</a></h3>
<a href="#76bf8f088"><div class="admonition def" id="76bf8f088">
<p class="admonition-title">비가산 집합(uncountable set)</p>
<p>집합 <span class="arithmatex">\(X\)</span> 의 기수가 다음을 만족하면 <span class="arithmatex">\(X\)</span> 를 셀 수 없는 집합이라고 한다.</p>
<div class="arithmatex">\[ |X| &gt; \aleph _0 \]</div>
</div></a>
<ul>
<li><span class="arithmatex">\(\R\)</span> 는 비가산집합이다.</li>
</ul>
<h3 id="properties-of-transfinite-cardinal-number">Properties of Transfinite Cardinal Number<a class="headerlink" href="#properties-of-transfinite-cardinal-number" title="Permanent link">¶</a></h3>
<a href="#7713aafcf"><div class="admonition def" id="7713aafcf">
<div class="arithmatex">\[ \aleph _0 \aleph _0 = \aleph _0 \]</div>
</div></a>
<ul>
<li>
<p>이것은 무한기수의 독특한 특징이다.</p>
</li>
<li>
<p>증명 </p>
<div class="arithmatex">\[ \because \N \times \N \approx \N \]</div>
</li>
</ul>
<a href="#530ae8378"><div class="admonition def" id="530ae8378">
<p class="admonition-title">정리 3.5.3</p>
<p>임의의 무한기수 <span class="arithmatex">\(a\)</span> 에 대하여 <span class="arithmatex">\(aa = a\)</span> 이다.</p>
</div></a>
<ul>
<li>
<p>증명 </p>
<p><span class="arithmatex">\(|A|  = a\)</span> 인 무한집합 <span class="arithmatex">\(A\)</span> 를 잡으면 <a href="#8ab5072fc">도움정리 3.4.4</a> 에 의하여 <span class="arithmatex">\(\exists D \subset A \text{ s.t. }\  D \approx \N\)</span> 이다. 이때 <span class="arithmatex">\(\N \times \N \approx \N\)</span> 이므로 <span class="arithmatex">\(D \approx D \times D\)</span> 가 되어 전단사 함수 <span class="arithmatex">\(f: D \to D \times D\)</span> 가 존재한다. 이때 </p>
<div class="arithmatex">\[ D \subset B \subset A, \quad  g|_D=f, \quad g:B \to B \times B \text{ is bijection } \]</div>
<p>을 만족하는 순서쌍 <span class="arithmatex">\((B, g)\)</span> 들의 전체 집합 <span class="arithmatex">\(\mathcal{B}\)</span> 을 정의하고, 여기에 </p>
<div class="arithmatex">\[ (B_1, g_1) \leq (B_2, g_2) \iff B_1 \subset B_2, g_2| _{B_1} = g_1 \]</div>
<p>와 같은 순서를 부여하면 <span class="arithmatex">\(\mathcal{B}\)</span> 는 순서집합이 된다. 또 이로써 <a href="#b78f346ef">초른 보조정리</a>의 조건부가 만족된다. 그러므로 <span class="arithmatex">\(\mathcal{B}\)</span> 에는 극대원소 <span class="arithmatex">\((C, h)\)</span> 가 존재한다.</p>
<p>이제 <span class="arithmatex">\(|C| = c\)</span> 로 두고, <span class="arithmatex">\(c=a\)</span> 을 보이면 증명이 끝난다. ▲ </p>
<p><span class="arithmatex">\(c&lt;a\)</span> 라고 가정하면, <span class="arithmatex">\(b = |A \setminus C|\)</span> 가 존재한다. 이때 </p>
<div class="arithmatex">\[ c  = 0 + c \leq c + c = 1c + 1c = 2c \leq cc = c \]</div>
<p>이므로 <span class="arithmatex">\(c + c \leq c\)</span> 인데, 애초에 <span class="arithmatex">\(c \leq c + c\)</span> 이므로 <span class="arithmatex">\(c = c+ c\)</span> 이다. 만약 <span class="arithmatex">\(b \leq c\)</span> 이면 </p>
<div class="arithmatex">\[ a = b + c \leq c + c = c \]</div>
<p>이므로 <span class="arithmatex">\(a \leq c\)</span> 가 되어 모순이므로 <a href="#1267052d9">정리 3.5.1</a> 에 의하여 <span class="arithmatex">\(c &lt; b\)</span> 이다. <span class="arithmatex">\(C\)</span> 보다 <span class="arithmatex">\(A \setminus C\)</span> 가 더 크므로 <span class="arithmatex">\(C \approx E\)</span> 인 <span class="arithmatex">\(E \subset A \setminus C\)</span> 가 존재한다. 이때 합집합과 곱집합의 분배법칙에 의하여</p>
<div class="arithmatex">\[ (C \sqcup E) \times (C \sqcup E) = (C \times C) \sqcup (C \times E) \sqcup (E \times C) \sqcup (E \times E) \]</div>
<p>인데, <span class="arithmatex">\((C \times E) , (E \times C) , (E \times E)\)</span> 들의 기수는 <span class="arithmatex">\(c\)</span> 이므로 </p>
<div class="arithmatex">\[ |(C \times E) \sqcup (E \times C) \sqcup (E \times E)| = (c+c)+c=c+c=c \]</div>
<p>이다. 그러므로 전단사 함수 </p>
<div class="arithmatex">\[ k: E \to (C \times E) \sqcup (E \times C) \sqcup (E \times E) \]</div>
<p>가 존재한다. 한편 전단사 함수 <span class="arithmatex">\(h:C \to C \times C\)</span> 에 대하여 서로소 집합 함수 <span class="arithmatex">\(h \sqcup k\)</span> 는 </p>
<div class="arithmatex">\[ h \sqcup k:C \sqcup E \to (C \sqcup E) \times (C \sqcup E) \]</div>
<p>는 전단사 함수가 된다. 그러면 <span class="arithmatex">\((C \sqcup E, h \sqcup k) &gt; (C, h)\)</span> 인데, 이는 <span class="arithmatex">\((C, h)\)</span> 가 극대 원소라는데 모순이다. 그러므로 <span class="arithmatex">\(c = a\)</span> 이다. ▲ </p>
<p><span class="arithmatex">\(c\)</span> 는 조건에 의하여 <span class="arithmatex">\(cc = c\)</span> 였으므로 결국 <span class="arithmatex">\(aa=a\)</span> 이다. ■ </p>
</li>
</ul>
<a href="#3a3a2e5d7"><div class="admonition def" id="3a3a2e5d7">
<p>무한기수 <span class="arithmatex">\(a, b\)</span> 에 대하여 다음이 성립한다.</p>
<ol>
<li>
<p><span class="arithmatex">\(a \leq b \implies a + b = ab = b\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(a ^{b} = 2 ^{b}\)</span></p>
</li>
</ol>
</div></a>
<ul>
<li>
<p>증명</p>
<p><span class="arithmatex">\(1 \leq a\)</span> 에서 <span class="arithmatex">\(b = 1b \leq ab \leq bb = b\)</span> 이므로 <span class="arithmatex">\(ab = b\)</span> 이다. ▲ </p>
<p>또한 <span class="arithmatex">\(b = 0+b \leq a+b \leq b + b = 2b \leq bb = b\)</span> 이므로 <span class="arithmatex">\(a + b = b\)</span> 인데 이때의 <span class="arithmatex">\(a\)</span> 는 어떤 기수라도 관계 없다. ▲ </p>
<p>무한 기수 <span class="arithmatex">\(a = |A|\)</span> 와 <span class="arithmatex">\(2 ^{a} = |2 ^{A}|\)</span> 에 대하여 <span class="arithmatex">\(a \leq 2 ^{a}\)</span> 이므로 <span class="arithmatex">\(a ^{b} \leq (2 ^{a})^{b} = 2 ^{ab} = 2 ^{b}\)</span> 이고, <span class="arithmatex">\(2 \leq a\)</span> 이므로 <span class="arithmatex">\(2 ^{b} \leq a ^{b}\)</span> 이다. ■ </p>
</li>
</ul>
<a href="#9c130f58d"><div class="admonition def" id="9c130f58d">
<p>다음은 동치이다.</p>
<ol>
<li>
<p>임의의 기수 <span class="arithmatex">\(a\)</span> 에 대하여 <span class="arithmatex">\(a &lt; 2 ^{a}\)</span> 이다.</p>
</li>
<li>
<p>임의의 집합 <span class="arithmatex">\(X\)</span> 에 대하여 임의의 함수 <span class="arithmatex">\(f: X \to 2 ^{X}\)</span> 는 전사가 아니다.</p>
</li>
</ol>
</div></a>
<ul>
<li>
<p>이 정리는 어떤 집합의 기수가 그것의 부분집합 전체 집합의 기수보다 반드시 작다는 것인데, 이것도 칸토어의 대각선 논법이다.</p>
</li>
<li>
<p>한편 이 정리는 더욱 더 큰 기수를 발견할 수 있다는 가능성을 보여준다.</p>
</li>
<li>
<p>증명 </p>
<p>함수 <span class="arithmatex">\(f: X \to 2 ^{X}\)</span> 에 대하여 </p>
<div class="arithmatex">\[ A = \{x \in X: x \not\in f(x)\} \]</div>
<p>라 두고, <span class="arithmatex">\(f\)</span> 가 전사라고 가정하자. 그러면 이 함수 <span class="arithmatex">\(f\)</span> 는 임의의 <span class="arithmatex">\(x \in X\)</span> 를 <span class="arithmatex">\(X\)</span> 의 모든 부분집합으로 대응시키기 때문에 <span class="arithmatex">\(X\)</span> 의 부분집합인 <span class="arithmatex">\(A\)</span> 에 대해서도 <span class="arithmatex">\(f(x_0) = A\)</span> 인 <span class="arithmatex">\(x_0\)</span> 가 존재한다. ▲ </p>
<p><span class="arithmatex">\(x_0 \in A\)</span> 이면 <span class="arithmatex">\(A\)</span> 의 정의에 의하여 <span class="arithmatex">\(x_0 \not\in f(x_0)\)</span> 인데 <span class="arithmatex">\(f(x_0) = A\)</span> 이므로 <span class="arithmatex">\(x_0 \not\in A\)</span> 이다. 따라서 모순이다. ▲ </p>
<p><span class="arithmatex">\(x_0 \not \in A\)</span> 이면 <span class="arithmatex">\(x_0 \in f(x_0) = A\)</span> 이 또한 모순이다. ▲ </p>
<p>그러므로 <span class="arithmatex">\(f(x_0) = A\)</span> 인 <span class="arithmatex">\(x_0\)</span> 는 존재하지 않고, <span class="arithmatex">\(f\)</span> 는 전사가 아니다. ■ </p>
</li>
</ul>
<h3 id="relation-between-n-and-r">Relation between <span class="arithmatex">\(|\N|\)</span> and <span class="arithmatex">\(|\R|\)</span><a class="headerlink" href="#relation-between-n-and-r" title="Permanent link">¶</a></h3>
<a href="#bf64c0903"><div class="admonition def" id="bf64c0903">
<div class="arithmatex">\[ 2 ^{\aleph_0} = \mathfrak{c} \]</div>
</div></a>
<ul>
<li>
<p>증명 (<a href="https://proofwiki.org/wiki/Continuum_equals_Cardinality_of_Power_Set_of_Naturals">https://proofwiki.org/wiki/Continuum_equals_Cardinality_of_Power_Set_of_Naturals</a>)</p>
<p><a href="../numbers#458a3d85a">실수 집합과 데데킨트 절단 집합 사이에 전단사 사상이 존재하므로</a> 전단사 사상 </p>
<div class="arithmatex">\[ f: \R \to \mathscr{D} \]</div>
<p>가 존재한다. 절단은 <span class="arithmatex">\(\mathbb{Q}\)</span> 의 부분집합이므로 <span class="arithmatex">\(\mathscr{D} \subset 2 ^{\mathbb{Q}}\)</span> 이고, 곧 <span class="arithmatex">\(|\mathscr{D}| \leq |2 ^{\mathbb{Q} }|\)</span> 이다. <span class="arithmatex">\(\mathbb{Q} \approx \mathbb{N}\)</span> 이므로 <span class="arithmatex">\(2 ^{\N} \approx 2 ^{\mathbb{Q} }\)</span> 이고, <span class="arithmatex">\(\mathscr{D} \approx \R\)</span> 이므로</p>
<div class="arithmatex">\[ |\R| \leq |2^{\N}| \iff \mathfrak{c} \leq 2 ^{\aleph _0} \]</div>
<p>이다. ▲ </p>
<p>사상 <span class="arithmatex">\(h: \text{Fin}(\N) \times  2 ^{\N} \to \R ^{+}\)</span> 을 </p>
<div class="arithmatex">\[ \forall F \in \text{Fin}(\N), A \in 2 ^{\N} : h(F, A) = \sum_{i \in F} 2 ^{i} + \sum_{i \in A} \bigg (\dfrac{1}{2}\bigg ) ^{i} \]</div>
<p>와 같이 정의하자. <span class="arithmatex">\(\text{Fin}(\N)\)</span> 은 <span class="arithmatex">\(\N\)</span> 의 모든 유한 부분집합의 집합이다.</p>
<p>그러면 <span class="arithmatex">\((F, A)\)</span> 는 실수 <span class="arithmatex">\(h(F, A)\)</span> 로 대응된다. 이는 <span class="arithmatex">\(h\)</span> 가 전사 사상임을 뜻한다. 전사 사상의 정의역과 공역은 </p>
<div class="arithmatex">\[ |\text{Fin}(\N) \times 2 ^{\N}| \leq |\R^{+}| \]</div>
<p>의 관계를 갖는다. 이때 정의에 의하여 <span class="arithmatex">\(\text{Fin}(\N) \subset 2 ^{\N}\)</span> 이므로 <span class="arithmatex">\(|\text{Fin}(\N)| \leq |2^{\N}|\)</span> 이다. 임의의 무한 기수 <span class="arithmatex">\(a\)</span> 와 유한 기수 <span class="arithmatex">\(b\)</span> 에 대하여 <span class="arithmatex">\(ab = a\)</span> 이므로 <span class="arithmatex">\(|\text{Fin}(\N) \times 2 ^{\N}| = |2^{\N}|\)</span> 이고, <span class="arithmatex">\(\R ^{+} \subset \R\)</span> 이므로 <span class="arithmatex">\(|\R^{+}| \leq |\R|\)</span> 이다. 그러므로 </p>
<div class="arithmatex">\[ |2^{\N}| \leq |\R| \iff 2 ^{\aleph _0} \leq \mathfrak{c} \]</div>
<p>이다. ▲ </p>
<p>그러므로 <span class="arithmatex">\(2 ^{\aleph _0} = \mathfrak{c}\)</span> 이다. ■ </p>
</li>
</ul>
<h2 id="properties-of-ordinal-number">Properties of Ordinal Number<a class="headerlink" href="#properties-of-ordinal-number" title="Permanent link">¶</a></h2>
<a href="#6d3c99905"><div class="admonition def" id="6d3c99905">
<p class="admonition-title">도움정리 3.6.1</p>
<p>서수 <span class="arithmatex">\(\alpha , \beta\)</span> 에 대하여 <span class="arithmatex">\(\alpha \approxeq \beta \implies \alpha = \beta\)</span> 이다.</p>
</div></a>
<ul>
<li>
<p>증명 </p>
<p>함수 <span class="arithmatex">\(f: \alpha \to \beta\)</span> 가 순서동형을 정의할 때 <span class="arithmatex">\(\forall \xi \in \alpha, f(\xi ) = \xi\)</span> 임을 보이면 본 정리가 증명된다. </p>
<div class="arithmatex">\[ X = \{a \in \alpha : f(a ) = a \} \]</div>
<p>라고 정의하고, <span class="arithmatex">\(\xi \in \alpha\)</span> 에 대하여 <span class="arithmatex">\(S _{\xi } \subset X\)</span> 라고 가정하자. 즉, <span class="arithmatex">\(b &lt; \xi \implies f(b ) = b\)</span> 를 가정한다. </p>
<p>먼저 <span class="arithmatex">\(\eta \in \xi = S _{\xi } \implies \eta &lt; \xi \implies f(\eta )&lt;f(\xi )\)</span> 인데 가정에 의하여 <span class="arithmatex">\(\eta \in X \implies \eta = f(\eta )&lt;f(\xi )\)</span>, 즉 <span class="arithmatex">\(\eta \in  S _{f(\xi )} = f(\xi )\)</span> 이다. 즉, </p>
<div class="arithmatex">\[ \eta \in \xi  \implies \eta \in f(\xi ) \]</div>
<p>이다. ▲ </p>
<p>반대로 <span class="arithmatex">\(f(\eta ) \in f(\xi ) = S _{f(\xi )} \implies f(\eta ) &lt; f(\xi )\)</span> 인데 <span class="arithmatex">\(f\)</span> 는 순서를 보존하므로 <span class="arithmatex">\(\eta &lt; \xi\)</span> 이다. 그러면 가정이 성립하여 <span class="arithmatex">\(\eta  = f(\eta )\)</span> 이므로 <span class="arithmatex">\(f(\eta ) &lt; \xi\)</span> 이다. 그러므로 </p>
<div class="arithmatex">\[ f(\eta ) \in f(\xi ) \implies f(\eta) \in \xi \]</div>
<p>이다. ▲ </p>
<p>이는 어떤 원소가 <span class="arithmatex">\(\xi\)</span> 에 속하면 <span class="arithmatex">\(f(\xi)\)</span> 에 속하고, 역으로 <span class="arithmatex">\(f(\xi)\)</span> 에 속하면 <span class="arithmatex">\(\xi\)</span> 에도 속함을 뜻한다. 그러므로 <span class="arithmatex">\(\xi = f(\xi )\)</span> 즉, <span class="arithmatex">\(\xi \in X\)</span> 이다. 그러면 <a href="#eaed9d1d0">정리 3.3.2</a> 에 의하여 <span class="arithmatex">\(X = \alpha\)</span> 이다. ■ </p>
</li>
</ul>
<a href="#1d485307d"><div class="admonition def" id="1d485307d">
<p class="admonition-title">도움정리 3.6.2</p>
<p>서수 <span class="arithmatex">\(\alpha ,\beta\)</span> 에 대하여 다음이 성립한다.</p>
<div class="arithmatex">\[ \alpha &lt; \beta \iff \alpha \in \beta \iff \alpha \subsetneq \beta \]</div>
</div></a>
<ul>
<li>
<p>증명 </p>
<p><span class="arithmatex">\(\alpha &lt; \beta \implies \gamma \in \beta \text{ s.t. }\ \alpha \approxeq S _{\gamma }\)</span> 이다. 이때 <span class="arithmatex">\(\alpha , S _{\gamma }\)</span> 가 서수이므로 <a href="#6d3c99905">도움정리 3.6.1</a> 에 의하여 <span class="arithmatex">\(\alpha = S _{\gamma } = \gamma \in \beta\)</span> 이다. ▲ </p>
<p><span class="arithmatex">\(\alpha \in \beta\)</span> 이면 <span class="arithmatex">\(\alpha = S _{\alpha } \subsetneq \beta\)</span> 이다. ▲ </p>
<p><span class="arithmatex">\(\alpha \subsetneq \beta\)</span> 라고 하자. <span class="arithmatex">\(\exists \gamma \in \alpha \text{ s.t. }\ \beta \approxeq S _{\gamma }\)</span> 이면 <span class="arithmatex">\(\beta = S _{\gamma } = \gamma \subset \alpha\)</span> 가 되어 모순이다. (<em>즉 <span class="arithmatex">\(\beta\)</span> 가 <span class="arithmatex">\(\alpha\)</span> 의 절편과 순서동형인가 했더니 모순이라는 것이다.</em>) 따라서 <a href="#90ba9203e">정리 3.3.1</a> 에 의하여 <span class="arithmatex">\(\alpha\)</span> 는 <span class="arithmatex">\(\beta\)</span> 의 절편과 순서동형이고, 따라서 <span class="arithmatex">\(\alpha &lt; \beta\)</span> 이다. ■ </p>
</li>
<li>
<p><span class="arithmatex">\(A \iff B \iff C\)</span> 를 보이기 위하여 <span class="arithmatex">\(A \implies B \implies C \implies A\)</span> 를 증명했네. 이러면 <span class="arithmatex">\(B \implies C \land C \implies A \implies B\)</span> 니까 <span class="arithmatex">\(B \iff C\)</span> 이고, 결국 <span class="arithmatex">\(A \iff B \iff C\)</span> 가 증명되는 식인듯.</p>
</li>
</ul>
<a href="#7eb0ecfb3"><div class="admonition def" id="7eb0ecfb3">
<p class="admonition-title">정리 3.6.3</p>
<p>임의의 정렬집합 <span class="arithmatex">\(A\)</span> 에 대하여 <span class="arithmatex">\(A \approxeq \alpha\)</span> 인 서수 <span class="arithmatex">\(\alpha\)</span> 가 유일하게 존재한다.</p>
</div></a>
<ul>
<li>
<p>증명</p>
<p>먼저 유일성 증명은 <a href="#6d3c99905">도움정리 3.6.1</a> 에 의하여 해결되므로 존재성 증명만 하면 된다.</p>
<p><span class="arithmatex">\(\forall a \in A\)</span> 에 대하여 <span class="arithmatex">\(S_a\)</span> 가 어떤 서수 <span class="arithmatex">\(\alpha (a)\)</span> 가 존재하여 <span class="arithmatex">\(S_a \approxeq \alpha (a)\)</span> 를 만족한다고 가정하자. 그러면 </p>
<div class="arithmatex">\[ S = \{\alpha (a):a \in A\} \]</div>
<p>를 정의할 수 있다. 이때 <a href="#b91fdee1f">정리 3.3.3</a> 에 의하여 <span class="arithmatex">\(S\)</span> 가 서수이고 <span class="arithmatex">\(S \approxeq A\)</span> 을 보이면 임의의 정렬집합과 순서동형인 서수가 존재한다는 것이 증명된다. ▲ </p>
<p>먼저 <span class="arithmatex">\(\alpha (a) \leq \alpha (b) \iff a \leq b\)</span> 라 정의하면 <span class="arithmatex">\(S\)</span> 는 정렬집합이 된다. ▲ </p>
<p>임의의 <span class="arithmatex">\(b \in A\)</span> 에 대하여 <a href="#1d485307d">도움정리 3.6.2</a> 에 의하여</p>
<div class="arithmatex">\[ \alpha (b) \in \alpha (a) \iff \alpha (b) &lt; \alpha (a) \iff \alpha (b) \in S _{\alpha (a)} \]</div>
<p>이므로 <span class="arithmatex">\(\alpha (a) = S _{\alpha (a)}\)</span> 이고, <span class="arithmatex">\(S\)</span> 가 서수임을 알 수 있다. ▲ </p>
<p><span class="arithmatex">\(a \mapsto \alpha (a)\)</span> 가 <span class="arithmatex">\(A\)</span> 에서 <span class="arithmatex">\(S\)</span> 로 가는 순서동형이므로 <span class="arithmatex">\(A \approxeq S\)</span> 이다. ■ </p>
</li>
</ul>
<a href="#f69fd2ad6"><div class="admonition def" id="f69fd2ad6">
<p class="admonition-title">정리 3.6.4</p>
<p>비어있지 않은 임의의 서수들의 집합은 최소원소를 가진다. </p>
</div></a>
<ul>
<li>
<p>증명 </p>
<p>서수들의 집합 <span class="arithmatex">\(E\)</span> 의 원소 <span class="arithmatex">\(\alpha\)</span> 를 선택하자. <span class="arithmatex">\(\forall \beta \in E, \alpha \leq \beta\)</span> 이면 증명이 끝난다. </p>
<p>따라서 <span class="arithmatex">\(\beta &lt; \alpha\)</span> 라고 하자. 그러면 <span class="arithmatex">\(\beta \in \alpha \implies \alpha \cap E \neq \varnothing\)</span> 이다. <span class="arithmatex">\(\alpha \cap E\)</span> 는 정렬집합 <span class="arithmatex">\(\alpha\)</span> 의 부분집합이므로 최소원소 <span class="arithmatex">\(\gamma\)</span> 를 가진다.</p>
<p><span class="arithmatex">\(\delta \in E\)</span> 라고 하자. <span class="arithmatex">\(\alpha \leq \delta \implies \gamma &lt; \alpha \leq \delta\)</span> 이고, <span class="arithmatex">\(\alpha &gt; \delta \implies \delta \in \alpha \cap E\)</span> 이므로 <span class="arithmatex">\(\gamma \leq \delta\)</span> 이다. 언제나 <span class="arithmatex">\(\gamma \leq \delta\)</span> 이므로 <span class="arithmatex">\(\gamma\)</span> 가 <span class="arithmatex">\(E\)</span> 의 최소원소이다.</p>
</li>
</ul>
<a href="#d64d10bb4"><div class="admonition def" id="d64d10bb4">
<p>서수 <span class="arithmatex">\(\alpha\)</span> 가 집합 <span class="arithmatex">\(X\)</span> 에 대하여 <span class="arithmatex">\(\alpha = |X|\)</span> 이면 다음이 성립한다.</p>
<div class="arithmatex">\[ \beta \leq \alpha , \beta \approx \alpha \implies \beta = \alpha \]</div>
</div></a>
<ul>
<li>이는 기수의 정의에서 <span class="arithmatex">\(\xi \approx X\)</span> 인 <span class="arithmatex">\(\xi\)</span> 중 최소인 <span class="arithmatex">\(\xi\)</span> 가 <span class="arithmatex">\(\alpha\)</span> 라는 말이므로 <span class="arithmatex">\(\beta \leq \alpha\)</span> 가 <span class="arithmatex">\(\beta \approx \alpha\)</span> 이면 <span class="arithmatex">\(\beta =\alpha\)</span> 임이 당연하다.</li>
</ul>
<a href="#71af40ea5"><div class="admonition def" id="71af40ea5">
<p class="admonition-title">시작서수</p>
<p>어떤 기수 <span class="arithmatex">\(\alpha\)</span> 에 대하여 기수의 정의에 의해 <span class="arithmatex">\(\alpha\)</span> 보다 작은 서수는 <span class="arithmatex">\(\alpha\)</span> 와 동등하지 않은데, 이러한 서수 <span class="arithmatex">\(\alpha\)</span> 를 시작서수라고 한다.</p>
</div></a>
<ul>
<li>
<p>즉, 모든 기수는 시작서수이다. </p>
<p>역으로, <span class="arithmatex">\(\alpha\)</span> 가 시작서수이면 <span class="arithmatex">\(\alpha = |\alpha|\)</span> 이므로 기수가 된다. 즉, 임의의 시작서수는 기수이다.</p>
</li>
</ul>
<a href="#2e4a7fa8c"><div class="admonition def" id="2e4a7fa8c">
<p class="admonition-title">정리 3.6.5</p>
<p>임의의 서수들의 집합은 최소상계를 가진다.</p>
</div></a>
<ul>
<li>
<p>증명 </p>
<p><a href="#f69fd2ad6">정리 3.6.4</a> 에 의하여 서수들의 집합 <span class="arithmatex">\(C\)</span> 에 대한 집합</p>
<div class="arithmatex">\[ \alpha  = \bigcup_{}^{}\{\xi :\xi \in C\} \]</div>
<p>은 정렬집합이다. 또한 <span class="arithmatex">\(\xi \in \alpha\)</span> 의 절편을 <span class="arithmatex">\(\alpha\)</span> 안에서 취하나 <span class="arithmatex">\(\xi\)</span> 안에서 취하나 마찬가지이므로 <span class="arithmatex">\(\alpha\)</span> 는 서수이다(<em>이거 왜 이해가 안되지</em>).</p>
<p><span class="arithmatex">\(\forall \xi \in C\)</span> 에 대하여 <span class="arithmatex">\(\xi \in \alpha\)</span> 이므로 <span class="arithmatex">\(\xi \leq \alpha\)</span> 이다. <span class="arithmatex">\(\beta\)</span> 가 <span class="arithmatex">\(C\)</span> 의 상계이면 <span class="arithmatex">\(\forall \xi \in C\)</span> 에 대하여 <span class="arithmatex">\(\xi \subset \beta\)</span> 이고, 따라서 <span class="arithmatex">\(\alpha \subset \beta \implies \alpha \leq \beta\)</span> 이다(<em>뭔가 너무 추상적인 논증이라 이해가 안되는 느낌인데</em>). </p>
<p>그러므로 <span class="arithmatex">\(\alpha = \sup C\)</span> 이다. ■ </p>
</li>
</ul>
<h2 id="continuum-hypothesis">Continuum Hypothesis<a class="headerlink" href="#continuum-hypothesis" title="Permanent link">¶</a></h2>
<a href="#afe337e0c"><div class="admonition def" id="afe337e0c">
<p class="admonition-title"><span class="arithmatex">\(\aleph _1\)</span> </p>
<div class="arithmatex">\[ \aleph _1 := \min \{\xi : \aleph _0 &lt; |\xi| \leq 2 ^{\aleph _0} \} \]</div>
</div></a>
<ul>
<li>
<p>이렇게 정의된 <span class="arithmatex">\(\aleph _1\)</span> 은 정의에 의하여 기수가 되고,</p>
<div class="arithmatex">\[ \aleph _1 &gt; \aleph _0, \quad \xi \in \aleph _1 \implies |S _{\xi }| \leq  \aleph _0 \]</div>
<p>이 성립한다.</p>
</li>
</ul>
<a href="#c5e51e16e"><div class="admonition def" id="c5e51e16e">
<div class="arithmatex">\[\aleph _1 = \sup \{\xi : \xi \approx \aleph _0\}\]</div>
</div></a>
<ul>
<li>증명</li>
</ul>
<a href="#90af6e075"><div class="admonition def" id="90af6e075">
<p class="admonition-title">연속체 가설(Continuum hypothesis)</p>
<div class="arithmatex">\[\aleph _1 = 2 ^{\aleph _0}\]</div>
</div></a>
<ul>
<li>
<p>이 정리는 쉽게 말해 자연수의 개수보다 많고 실수의 개수보다 적은 집합이 존재하지 않음을 말한다.</p>
</li>
<li>
<p>증명 </p>
<p>선택공리를 가정한 체르멜로-프렝켈 집합론(ZFC) 가 무모순이라면, 연속체 가설은 ZFC 와 독립적이다. 즉, 연속체 가설이 참이든, 거짓이든 ZFC 공리체계로 증명되지도 않고 반박되지도 않는다.</p>
<p>결론은 "증명할 수 없다." 이다.</p>
</li>
<li>
<p>유클리드 기하학의 평행선 공리는 역사적으로 증명되거나, 반박되려 했으나 모두 실패했다. 수학자들은 평행선 공리가 거짓임을 증명하려고 일단 평행선 공리를 가정하고 공리체계를 이끌어내어 모순을 얻으려 했으나, 결국 모순을 얻지 못하였고 그들이 만들어낸 새로운 기하학 공리체계가 비유클리드 기하학을 형성했음을 알게 되었다. </p>
<p>연속체 가설이 기하학에서의 평행선 공리와 같은 위치에 있다.</p>
</li>
</ul>
<a href="#0f6c1ff46"><div class="admonition def" id="0f6c1ff46">
<p class="admonition-title"><span class="arithmatex">\(\aleph _n\)</span> </p>
<div class="arithmatex">\[ \aleph _n := \min \{\xi : \aleph _{n-1} &lt; |\xi| \leq 2 ^{\aleph _{n-1}} \} \]</div>
</div></a>
<ul>
<li>
<p>이 정의는 <a href="../numbers#3a99b431b">정리 2.1.2</a> 를 사용하여 <span class="arithmatex">\(\aleph _1\)</span> 의 정의를 임의의 자연수 <span class="arithmatex">\(n = 1, 2, \dots\)</span> 에 대하여 확장한 것이다.</p>
</li>
<li>
<p>또한 <span class="arithmatex">\(\aleph _{\omega } = \sup \{\aleph _n:n &lt; \omega \}\)</span> 라 두면 새로운 기수를 계속해서 얻을 수 있다.</p>
</li>
</ul>
<a href="#b9f63e9a0"><div class="admonition def" id="b9f63e9a0">
<p class="admonition-title">일반 연속체 가설(generalized continuum hypothesis)</p>
<p>임의의 기수 <span class="arithmatex">\(\alpha\)</span> 에 대하여 <span class="arithmatex">\(\aleph _{\alpha ^{+}} = 2 ^{\aleph _{\alpha }}\)</span> 이다.</p>
</div></a>
<ul>
<li>증명</li>
</ul>
<hr/>
<dl>
<dt>ref:</dt>
<dd>
<p>집합과 수의 체계</p>
</dd>
</dl>
</article>
</div>
</div>
<a class="md-top md-icon" data-md-component="top" data-md-state="hidden" href="#">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path></svg>
            Back to top
          </a>
</main>
<!-- 
<footer class="md-footer">
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        
      </div>
      
    </div>
  </div>
</footer> -->
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.tabs", "navigation.top", "header.autohide"], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../../assets/javascripts/workers/search.409db549.min.js", "version": null}</script>
<script src="../../../assets/javascripts/bundle.756773cc.min.js"></script>
<script src="../../../javascripts/highlight.min.js"></script>
<script src="../../../javascripts/config.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script>
<script src="../../../javascripts/b27b3e6448.js"></script>
</body>
</html>